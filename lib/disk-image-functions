#!/bin/sh
# shellcheck disable=SC1117,SC2039

#############################################################################
##
##  disk-image-functions
##
##  Copyright 2021-2023 Dermot Bradley <dermot_bradley@yahoo.com>
##
##  Licensed via GPL version 2.0
##
#############################################################################


#
# Additional OS configuration.
#
additional_os_configuration() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Doing additional OS configuration"
	{
	EOF

  if [ -z "$image_barebones" ]; then
    case $image_alpine_release in
      v3.13 | v3.14 | v3.15 | v3.16 | v3.17 )
        cat <<-'EOF' >> "$run_script"
	  # FIXUP: stop update-ca-certificates displaying a warning
	  sed -i \
	    -e 's|/etc/ssl/certs|/etc/ssl/certs 2>/dev/null|' \
	    /etc/ca-certificates/update.d/certhash
	
	EOF
        ;;
      * )
        # Fix not required in recent Alpine releases
        : ;;
    esac
  fi

  case $image_auth_control in
    doas | both )
      configure_doas ;;

    sudo )
      cat <<-'EOF' >> "$run_script"
	  # No specific configuration required for sudo
	  :
	EOF
      ;;
  esac

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Append specific cmdline settings.
#
add_cmdline_settings() {
  local _cmdline_additions

  case $image_acpi_power_method in
    generic )
      if is_in_comma_list "$CADI_SUPPORTED_ACPI_BUTTON" "tiny-button"; then
        # Using tiny-power-button but Busybox init doesn't handle the usual
        # signal this sends, so specify USR2 which Busybox accepts for
        # "poweroff" situations.
        _cmdline_additions="tiny_power_button.power_signal=12"
      fi
      ;;
    tiny-power-button )
      # Using tiny-power-button but Busybox init doesn't handle the usual
      # signal this sends, so specify USR2 which Busybox accepts for
      # "poweroff" situations.
      _cmdline_additions="tiny_power_button.power_signal=12" ;;
  esac

  case $image_class in
    physical )
      : ;;
    * )
      # For non-physical machines always ensure that the
      # console output is visible.
      _cmdline_additions="$_cmdline_additions consoleblank=0" ;;
  esac

  if [ -n "$CADI_DEFAULT_CLOCKSOURCE" ]; then
    if [ -n "$CADI_SUPPORTED_CLOCKSOURCES" ] && \
       is_in_comma_list "$CADI_SUPPORTED_CLOCKSOURCES" \
                        "$CADI_DEFAULT_CLOCKSOURCE"; then
      case $CADI_DEFAULT_CLOCKSOURCE in
        arch_sys_counter )
          _cmdline_additions="$_cmdline_additions clocksource=arch_sys_counter"
          ;;
        hyperv )
          _cmdline_additions="$_cmdline_additions clocksource=hyperv_clocksource_tsc_page"
          ;;
        kvm )
          _cmdline_additions="$_cmdline_additions clocksource=kvm-clock" ;;
      esac
    fi
  fi

  # Add any extra defined cmdline options
  if [ -n "$CADI_EXTRA_CMDLINE_OPTIONS" ]; then
    _cmdline_additions="$_cmdline_additions $CADI_EXTRA_CMDLINE_OPTIONS"
  fi

  if [ -z "$debug_enabled" ]; then
    if [ -z "$CADI_CMDLINE_QUIET" ] || [ "$CADI_CMDLINE_QUIET" = "true" ]; then
      _cmdline_additions="$_cmdline_additions quiet"
    fi
  fi

  if [ -n "$_cmdline_additions" ]; then
    echo " $_cmdline_additions"
  fi
}


#
# Basic OS configuration.
#
basic_os_configuration() {
  local _color_prompt_file _locale_file _login_banner

  cat <<-'EOF' >> "$run_script"
	
	write_log "Doing basic OS configuration"
	{
	  write_log "Setting the login and MOTD messages" 2
	  printf '\nWelcome\n\n' > /etc/issue
	EOF

  case $image_class in
    cloud )
      _login_banner="Alpine $image_arch $image_cloud_type Cloud server"
      ;;
    physical )
      case $image_physical_type in
        pc )
          _login_banner="Alpine $image_arch PC server" ;;
        rpi* )
          _login_banner="Alpine $image_arch Raspberry Pi server" ;;
      esac
      ;;
    virtual )
      _login_banner="Alpine $image_arch $image_vm_type VM server"
      ;;
  esac

  cat <<-EOF >> "$run_script"
	  printf '\n\n%s\n\n' "$_login_banner" > /etc/motd
	EOF

  cat <<-'EOF' >> "$run_script"
	
	  write_log "Setting the keymap to '\$keymap'" 2
	  # shellcheck disable=SC2086
	  setup-keymap \$keymap >> "/chroot.log" 2>&1
	EOF

  # https://gitlab.alpinelinux.org/alpine/aports/-/merge_requests/46718
  case $image_alpine_release in
    v3.13 | v3.14 | v3.15 | v3.16 | v3.17 )
      _locale_file="locale.sh" ;;
    v3.18 )
      _locale_file="20locale.sh" ;;
    * )
      _locale_file="50-cloud-init-locale.sh" ;;
  esac
  cat <<-EOF >> "$run_script"
	
	  locale_file="$_locale_file"
	  if [ -e "\\\$locale_file" ]; then
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	    # Debug
	    cp /etc/profile.d/\${locale_file} /etc/profile.d/\${locale_file}-orig
	
	EOF
  fi

  cat <<-EOF >> "$run_script"
	    write_log "Setting locale to \\\$locale" 2
	    sed -i -E -e "s/^(export LANG=)C.UTF-8/\1\\\$locale/" \\\\
	      /etc/profile.d/\\\${locale_file}
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    diff /etc/profile.d/\${locale_file}-orig /etc/profile.d/\${locale_file} \
	      >> /chroot.log || true
	    rm /etc/profile.d/\${locale_file}-orig
	EOF
  fi

  cat <<-EOF >> "$run_script"
	  else
	    write_log "Creating profile file to set locale to \\\$locale" 2
	    {
	      printf '# Created by create-alpine-disk-image\n#\n'
	      printf 'export LANG=%s\n' "\\\$locale"
	    } > /etc/profile.d/\\\${locale_file}
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    cat /etc/profile.d/\${locale_file} >> /chroot.log || true
	EOF
  fi

  cat <<-EOF >> "$run_script"
	  fi
	EOF

  harden_etc_profile

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  cp /etc/rc.conf /etc/rc.conf-orig
	EOF
  fi
  cat <<-'EOF' >> "$run_script"
	
	  write_log "Set OpenRC to log init.d start/stop sequences" 2
	  sed -i -e 's|[#]rc_logger=.*|rc_logger="YES"|g' /etc/rc.conf
	EOF
  case $image_alpine_release in
    v3.13 | v3.14 | v3.15 | v3.16 | v3.17 )
      cat <<-'EOF' >> "$run_script"
	
	  write_log "Fixup rc.conf so that keyboards and screens use Unicode" 2
	  sed -i -e 's/^#unicode="NO"/unicode="YES"/' /etc/rc.conf
	EOF
      ;;
    * )
      # Unicode is default from Edge/v3.18 onwards
      : ;;
  esac
  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  diff /etc/rc.conf-orig /etc/rc.conf >> /chroot.log || true
	  rm /etc/rc.conf-orig
	EOF
  fi


  cat <<-'EOF' >> "$run_script"
	
	  write_log \
	    "Configure /etc/init.d/bootmisc to keep previous dmesg logfile" 2
	  sed -i -e 's|[#]previous_dmesg=.*|previous_dmesg=yes|g' /etc/conf.d/bootmisc
	EOF
  case $image_alpine_release in
    v3.13 | v3.14 | v3.15 )
      cat <<-'EOF' >> "$run_script"
	
	  write_log "Create dummy dmesg logfile to workaround openrc bug" 2
	  touch /var/log/dmesg
	EOF
      ;;
  esac


  case $image_alpine_release in
    v3.13 )
      _color_prompt_file="color_prompt" ;;
    * )
      _color_prompt_file="color_prompt.sh.disabled" ;;
  esac
  cat <<-EOF >> "$run_script"
	
	  write_log "Enable colour shell prompt" 2
	  cp /etc/profile.d/${_color_prompt_file} /etc/profile.d/color_prompt.sh
	
	EOF


  if [ "$image_tmp_on_tmpfs" != "true" ]; then
    case $image_alpine_release in
      v3.13 | v3.14 | v3.15 )
        : ;;
      * )
        # From Alpine 3.16 onwards /tmp is not automatically wiped at boot
        cat <<-'EOF' >> "$run_script"
	  write_log "Ensuring /tmp is wiped at boot" 2
	  sed -i -e 's/^wipe_tmp=.*/wipe_tmp="YES"/g' /etc/conf.d/bootmisc
	
	EOF
      ;;
    esac
  fi


  # Enable mdevd or eudev where appropriate
  case $image_alpine_release in
    v3.13 | v3.14 | v3.15 | v3.16 )
      case $image_cloud_software in
        cloud-init )
          # Nothing to do, setup-cloud-init will enable udev
          : ;;
        none )
          case $image_device_management_type in
            mdev )
              # Nothing to do, already enabled
              : ;;
            udev )
              cat <<-EOF >> "$run_script"	
	  write_log "Enable udev init.d services" 2
	  setup-udev  >> /chroot.log 2>&1 || true
	EOF
              ;;
          esac
          ;;
        tiny-cloud )
          # tiny-cloud takes care of this itself
          : ;;
      esac
      ;;

    * )
      case $image_cloud_software in
        cloud-init | none )
          cat <<-EOF >> "$run_script"
	  write_log "Enable $image_device_management_type init.d services" 2
	  setup-devd $image_device_management_type >> /chroot.log 2>&1 || true
	EOF
          ;;
        tiny-cloud )
          # tiny-cloud takes care of this itself
          : ;;
      esac
      ;;
  esac


  if [ "$image_class" != "virtual" ] || [ "$image_vm_type" != "vmware" ]; then
    cat <<-EOF >> "$run_script"
	
	  rmdir /media/floppy
	EOF
  fi

  cat <<-EOF >> "$run_script"
	}
	EOF
}


#
# Calculate size of the resultant disk image taking into account
# whether bootloader/ESP, boot and cloud-init partitions are needed.
#
calculate_image_size() {
  local _boot_part_size _image_total_size _reserved_disk_size _swap_part_size

  if [ -n "$debug_sizing_enabled" ]; then
    printf '[calculate_image_size] determining image size\n' >> "$sizing_debug"
  fi

  if [ "$image_encryption_type" = "both" ] || \
     [ "$image_encryption_type" = "luks" ]; then
    # LUKS (including LVM-inside-LUKS)

    if [ -n "$debug_sizing_enabled" ]; then
      printf \
        '[calculate_image_size] image contains LUKS partition, determining LUKS partition size\n' \
        >> "$sizing_debug"
    fi

    _image_total_size=$(( $(calculate_luks_part_size) ))

    if [ -n "$debug_sizing_enabled" ]; then
      printf '[calculate_image_size] size for LUKS partition is %s MiB\n' \
        "$_image_total_size" >> "$sizing_debug"
    fi
  elif [ -n "$image_lvm_rootfs" ]; then
    # LVM

    if [ -n "$debug_sizing_enabled" ]; then
      printf \
        '[calculate_image_size] image contains LVM partition, determining LVM partition size\n' \
        >> "$sizing_debug"
    fi

    _image_total_size=$(( $(calculate_lvm_part_size) ))

    if [ -n "$debug_sizing_enabled" ]; then
      printf '[calculate_image_size] size for LVM partition is %s MiB\n' \
        "$_image_total_size" >> "$sizing_debug"
    fi
  else
    # Neither LUKS nor LVM

    if [ -n "$debug_sizing_enabled" ]; then
      printf '[calculate_image_size] determining rootfs partition size\n' \
        >> "$sizing_debug"
    fi

    _image_total_size=$(calculate_root_part_size)

    if [ -n "$debug_sizing_enabled" ]; then
      printf '[calculate_image_size] size for root partition is %s MiB\n' \
        "$_image_total_size" >> "$sizing_debug"
    fi
  fi


  if [ "$image_class" = "physical" ] && \
     [ "$image_cloud_software" = "cloud-init" ]; then
    if [ -n "$debug_sizing_enabled" ]; then
      printf '[calculate_image_size] image also contains CIDATA partition\n' \
        >> "$sizing_debug"
    fi

    _image_total_size="$(( _image_total_size + CADI_CIDATA_PART_SIZE ))"

    if [ -n "$debug_sizing_enabled" ]; then
      printf \
        '[calculate_image_size] adding on %s MiB CIDATA partition, giving %s MiB\n' \
        "$CADI_CIDATA_PART_SIZE" "$_image_total_size" >> "$sizing_debug"
    fi
  fi

  case $image_swap_boot_partition in
    true )
      # Swap partition to account for
      if [ -n "$debug_sizing_enabled" ]; then
        printf '[calculate_image_size] image also contains swap partition\n' \
          >> "$sizing_debug"
      fi

      _swap_part_size=$(calculate_swap_part_size)
      _image_total_size="$(( _image_total_size + _swap_part_size ))"

      if [ -n "$debug_sizing_enabled" ]; then
        printf \
          '[calculate_image_size] adding on %s MiB Swap partition, giving %s MiB\n' \
          "$_swap_part_size" "$_image_total_size" >> "$sizing_debug"
      fi
      ;;
  esac

  case $image_create_boot_partition in
    true )
      # Separate boot partition to account for
      if [ -n "$debug_sizing_enabled" ]; then
        printf '[calculate_image_size] image also contains boot partition\n' \
          >> "$sizing_debug"
      fi

      _boot_part_size=$(calculate_boot_part_size)
      _image_total_size="$(( _image_total_size + _boot_part_size ))"

      if [ -n "$debug_sizing_enabled" ]; then
        printf \
          '[calculate_image_size] adding on %s MiB Boot partition, giving %s MiB\n' \
          "$_boot_part_size" "$_image_total_size" >> "$sizing_debug"
      fi
      ;;
  esac

  case $image_boot_type in
    bios )
      # Account for 1MiB boot sector
      _reserved_disk_size=1

      _image_total_size="$(( _image_total_size + _reserved_disk_size ))"

      if [ -n "$debug_sizing_enabled" ]; then
        if [ "$image_os_partitioning_type" = "unpartitioned" ]; then
          printf \
            '[calculate_image_size] size unchanged for unpartitioned disk, giving %s MiB\n' \
            "$_image_total_size" >> "$sizing_debug"
        else
          printf \
            '[calculate_image_size] adding on %s MiB for boot sector, giving %s MiB\n' \
            "$_reserved_disk_size" "$_image_total_size" >> "$sizing_debug"
        fi
      fi
      ;;
    rpi )
      # Account for 1MiB boot sector
      _reserved_disk_size=1

      _image_total_size="$(( _image_total_size + _reserved_disk_size ))"
      if [ -n "$debug_sizing_enabled" ]; then
        printf \
          '[calculate_image_size] adding on %s MiB for boot sector, giving %s MiB\n' \
          "$_reserved_disk_size" "$_image_total_size" >> "$sizing_debug"
      fi
      ;;
    secure-uefi | uefi )
      # Account for GPT reserved space at start of device
      case $image_os_device_sector_size in
        512 )
          # with GPT 34 x 512-byte sectors are reserved (so 17K)
          _reserved_disk_size=1 ;;
        4096 )
          # with GPT 6 x 4K sectors are reserved (so 24K)
          _reserved_disk_size=1 ;;
      esac

      # Account for ESP partition
      if [ -n "$debug_sizing_enabled" ]; then
        printf '[calculate_image_size] image also contains ESP partition\n' \
          >> "$sizing_debug"
      fi

      _image_total_size="$(( _image_total_size + _reserved_disk_size + $(calculate_uefi_part_size) ))"

      if [ -n "$debug_sizing_enabled" ]; then
        printf \
          '[calculate_image_size] adding on %s MiB GPT overhead and %s MiB ESP partition, giving %s MiB\n' \
          "$_reserved_disk_size" "$(calculate_uefi_part_size)" \
          "$_image_total_size" >> "$sizing_debug"
      fi
      ;;
  esac

  if [ -n "$debug_sizing_enabled" ]; then
    printf '[calculate_image_size] total image size of %s MiB\n' \
      "$_image_total_size" >> "$sizing_debug"
  fi

  echo "$_image_total_size"
}


#
# Configure whatever software is used to manage auto-configuration.
#
configure_autoconfiguration_software() {
  case $image_cloud_software in
    cloud-init )
      configure_cloud_init ;;
    none )
      configure_non_autoconfiguration ;;
    tiny-cloud )
      configure_tiny_cloud ;;
  esac
}


#
# Define the base options for the cmdline list used by the bootloader.
#
configure_base_cmdline_values() {
  local _console_list _console_list_item

  base_cmdline="rootfstype=$image_fs_type"

  case $image_alpine_release in
    v3.13 | v3.14 | v3.15 | v3.16 | v3.17 | v3.18 )
      # Kernels in these Alpine releases didn't have a large enough buffer
      # to retain all kernel messages during boot.
      base_cmdline="$base_cmdline log_buf_len=32768" ;;
  esac

  case $image_fs_type in
    btrfs | ext4 )
      case $image_os_device_media in
        flash | sdcard | ssd )
          case $image_alpine_release in
            v3.13 | v3.14 | v3.15 | v3.16 )
              # For older Alpine releases add commit mount option for rootfs
              # when on flash device as this is *not* read from /etc/fstab by
              # initramfs' init when it mounts rootfs and later during boot
              # the /etc/init.d/root script does not use options from
              # /etc/fstab when remounting rootfs.
              base_cmdline="$base_cmdline rootflags=commit=300" ;;
            * )
              : ;;
          esac
          ;;
      esac
      ;;
  esac

  # Consoles to use
  if [ -n "$image_serial_console_name" ] && \
     [ -n "$image_serial_console_port_speed" ]; then
    case $image_console_device_type in
      generic | normal_and_serial | serial )
        base_cmdline="$base_cmdline console=${image_serial_console_name},${image_serial_console_port_speed}"
        if [ -n "$image_serial_console_parity" ]; then
          base_cmdline="${base_cmdline}${image_serial_console_parity}"
          if [ -n "$image_serial_console_data_bits" ]; then
            base_cmdline="${base_cmdline}${image_serial_console_data_bits}"
          fi
        fi
        ;;
    esac
  fi
  if [ -n "$image_console_device_name" ] && \
     [ "$image_console_device_type" != "none" ] && \
     [ "$image_console_device_type" != "serial" ]; then
    if is_single_entry_in_comma_list "$image_console_device_name"; then
      base_cmdline="$base_cmdline console=$image_console_device_name"
    else
      _console_list="$image_console_device_name"
      while true; do 
        _console_list_item="$(first_entry_in_comma_list "$_console_list")"
        base_cmdline="$base_cmdline console=$_console_list_item"
        if [ "${_console_list%,*}" = "$_console_list" ]; then
          # No more entries
          break
        else
          _console_list="${_console_list#$_console_list_item,}"
        fi
      done
    fi
  fi

  # IPv6
  if [ -n "$image_disable_ipv6" ]; then
    base_cmdline="$base_cmdline ipv6.disable=1"
  fi

  # Bootchart
  if [ -n "$image_bootchart" ]; then
    base_cmdline="$base_cmdline chart rootflags=rw"
  fi

  # ZSWAP
  if [ -n "$image_disable_zswap" ]; then
    base_cmdline="$base_cmdline zswap.enabled=1"
  fi

  # LUKS
  case $image_encryption_type in
    both | luks )
      base_cmdline="$base_cmdline \\\$(define_cmdline_for_luks_encryption)" ;;
  esac

  base_cmdline="${base_cmdline}$(add_cmdline_settings)"

  # Console
  case $image_console_device_type in
    hypervisor | none | serial )
      case $image_boot_type in
        bios )
          base_cmdline="$base_cmdline nomodeset" ;;
        esac
        ;;

    * )
      if [ "$image_console_output_type" = "text" ] || \
         { [ "$image_console_output_type" = "generic" ] && \
           { [ -z "$image_enable_graphics" ] || \
             [ "$image_enable_graphics" != "true" ]; }; }; then
        case $image_boot_type in
          bios )
            base_cmdline="$base_cmdline nomodeset"

            if [ -n "$image_graphics_driver" ]; then
              case $image_graphics_driver in
                generic )
                  base_cmdline="$base_cmdline i915.modeset=0 nouveau.modeset=0"
                  ;;
                i915 )
                  base_cmdline="$base_cmdline i915.modeset=0" ;;
                nouveau )
                  base_cmdline="$base_cmdline nouveau.modeset=0" ;;
              esac
            fi
            ;;
        esac
      fi
      ;;
  esac

  if [ -n "$image_extra_cmdline_options" ]; then
    # Add any additionally specified cmdline options
    base_cmdline="$base_cmdline $image_extra_cmdline_options"
  fi
}


#
# Configure whichever tool is used to create/manage initramfs.
#
configure_initramfs_tool() {
  case $image_initramfs_tool in
    booster )
      configure_booster ;;
    dracut )
      configure_dracut ;;
    mkinitfs )
      configure_mkinitfs ;;
  esac
}


#
# Convert RAW disk image to another format.
#
convert_raw_disk_image() {
  local _compression_tool _convert_cli _new_format
  local _new_format_extension _new_format_options

  if [ -n "$CADI_DISK_IMAGE_FORMAT" ]; then
    case $CADI_DISK_IMAGE_FORMAT in
      parallels | qcow2 | vdi | vhd | vmdk )
        if [ "$CADI_DISK_IMAGE_FORMAT" = "vhd" ]; then
          _new_format="vpc"
          _new_format_extension="$CADI_DISK_IMAGE_FORMAT"
        else
          _new_format="$CADI_DISK_IMAGE_FORMAT"
          _new_format_extension="$_new_format"
        fi
        if [ -n "$CADI_DISK_IMAGE_FORMAT_OPTIONS" ]; then
          _new_format_options="$CADI_DISK_IMAGE_FORMAT_OPTIONS"
        fi
    esac

    if [ -n "$_new_format" ]; then
      _convert_cli="-f raw -O $_new_format"
      if [ -n "$_new_format_options" ]; then
        _convert_cli="$_convert_cli $_new_format_options"
      fi

      cat <<-EOF >> "$run_script"
	
	write_log "Converting image from RAW format to ${_new_format_extension} format"
	new_filename="\$(basename -s img \$image_filename)$_new_format_extension"
	qemu-img convert $_convert_cli \$images_dir/\$image_filename \\
	  \$images_dir/"\$new_filename" >> "\$logfile"
	rm \$images_dir/\$image_filename
	EOF

      if [ -n "$CADI_DISK_IMAGE_COMPRESSION" ]; then
        _compression_tool="$CADI_DISK_IMAGE_COMPRESSION"

        cat <<-EOF >> "$run_script"
	
	write_log "Compressing image using ${_compression_tool}"
	compression_tool="$_compression_tool"
	\$compression_tool \$images_dir/"\$new_filename" \\
	  >> "\$logfile"
	EOF
      fi
    fi
  fi
}


#
# Basic settings and checks.
#
basic_settings() {
  # Chroot directory
  : "${chroot_directory:=$CADI_DEFAULT_CHROOT_DIRECTORY}"

  # Images directory
  : "${images_directory:=$CADI_DEFAULT_IMAGES_DIRECTORY}"

  # Whether to use ramdisk
  if [ -n "$use_ramdisk" ] && [ -z "$ramdisk_directory" ]; then
    # If ramdisk directory not specified then assume default
    ramdisk_directory=$CADI_DEFAULT_RAMDISK_DIRECTORY
  fi

  # Alpine repo mirror site
  : "${alpine_mirror_site:=$CADI_DEFAULT_MIRROR_SITE}"

  # Override default root partition size
  if [ -n "$override_rootfs_size" ]; then
    general_rootfs_size=$override_rootfs_size
  fi


  # Alpine Release
  : "${image_alpine_release:=$CADI_DEFAULT_ALPINE_RELEASE}"

  # Machine type defaults to QEMU VM
  if [ -z "$image_class" ]; then
    image_class="virtual"
    image_vm_type="qemu"
  fi

  # Kernel type
  : "${image_kernel_type:=normal}"

  # Whether /tmp is on disk or tmpfs
  : "${image_tmp_on_tmpfs:=true}"
}


#
# Perform some initial validation checks.
#
do_generic_validation_checks() {
  # Kernel type
  case $image_kernel_type in
    edge )
      case $image_alpine_release in
        v3.13 | v3.14 )
          error_message \
            "There is no edge kernel package for Alpine $image_alpine_release!"
          ;;
        v3.15 )
          # Both linux-edge and linux-edge4virt packages exist.
          : ;;
        * )
          # linux-edge4virt package no longer exists so
          # linux-edge will be used instead.
          : ;;
      esac
      ;;
  esac

  # ifupdown command
  case $image_ifupdown_package in
    ifupdown )
      case $image_alpine_release in
        v3.13 | v3.14 | v3.15 | v3.16 | v3.17 | v3.18 )
          : ;;
        * )
          error_message "Alpine no longer has a 'ifupdown' package!" ;;
      esac
      ;;
  esac

  if [ -n "$image_ntp_servers" ] && [ "$image_class" != "physical" ]; then
    error_message \
      "NTP servers can only be specified for physical servers, other machine type obtain this information either from defaults for their hypervisor/cloud provider or from user-data!"
  fi

  # UTMP
  if [ -n "$image_enable_utmp" ] && [ "$image_enable_utmp" = "true" ]; then
    case $image_alpine_release in
      v3.13 | v3.14 | v3.15 )
        error_message "UTMP does not function in this Alpine release!" ;;
    esac
  fi

  if [ -n "$image_disable_cloud_provider_cli" ] && \
     [ "$image_class" != "cloud" ]; then
    error_message \
      "The 'disable-cloud-provider-cli' option only applies for cloud disk images!"
  fi
}


#
# After type of cloud/VM/physical machine settings have been determined
# perform further validation checks.
#
do_specific_validation_checks() {
  # Default assumption is to use cloud-init for configuration
  if [ -n "$image_barebones" ] && \
     is_in_comma_list "$CADI_SUPPORTED_CONFIGURATION_TOOLS" "none"; then
    image_cloud_software="none"
  elif [ -n "$image_barebones" ]; then
    error_message "Unable to use barebones with '$class_type_description'!"
  elif [ -z "$image_cloud_software" ]; then
    if [ -n "$CADI_DEFAULT_CONFIGURATION_TOOL" ] && \
       is_in_comma_list "$CADI_SUPPORTED_CONFIGURATION_TOOLS" \
                        "$CADI_DEFAULT_CONFIGURATION_TOOL"; then
      image_cloud_software="$CADI_DEFAULT_CONFIGURATION_TOOL"
    elif [ -n "$CADI_SUPPORTED_CONFIGURATION_TOOLS" ] && \
         is_in_comma_list "$CADI_SUPPORTED_CONFIGURATION_TOOLS" \
                          "cloud-init"; then
      image_cloud_software="cloud-init"
    elif [ -n "$CADI_SUPPORTED_CONFIGURATION_TOOLS" ] && \
         is_in_comma_list "$CADI_SUPPORTED_CONFIGURATION_TOOLS" \
                          "tiny-cloud"; then
      image_cloud_software="tiny-cloud"
    else
      image_cloud_software="none"
    fi
  else
    # Check that the specified configuration software is supported by
    # the particular cloud/hypervisor/machine.
    if [ -n "$CADI_SUPPORTED_CONFIGURATION_TOOLS" ] && \
         is_in_comma_list "$CADI_SUPPORTED_CONFIGURATION_TOOLS" \
                          "$image_cloud_software"; then
      # selected configuration software is supported
      :
    else
      error_message \
        "configuration software '$image_cloud_software' is not supported for $class_type_description!"
    fi
  fi

  # Cloud-init
  if [ "$image_cloud_software" = "cloud-init" ]; then
    if [ -n "$CADI_SUPPORTED_CLOUD_INIT_DATASOURCES" ]; then
      image_cloud_init_datasources="$CADI_SUPPORTED_CLOUD_INIT_DATASOURCES"
    fi

    if [ -n "$image_cloud_init_seed_define" ]; then
      case $image_cloud_init_seed_define in
        cmdline | config )
          if [ -z "$image_cloud_init_seed_url" ]; then
            error_message "'--cloud-init-seed-url' also needs to be specified!"
          fi
          ;;
        dhcp | none )
          : ;;
      esac
    elif [ -n "$image_cloud_init_seed_url" ]; then
      error_message \
        "When defining a cloud-init seed URL you also need to specify '--cloud-init-seed-define' accordingly!"
    fi
  else
    # Not cloud-init
    if [ -n "$image_cloud_init_seed_define" ]; then
      error_message \
        "'--cloud-init-seed-define' only applies when cloud-init is being used!"
    elif [ -n "$image_cloud_init_seed_url" ]; then
      error_message \
        "'--cloud-init-seed-url' only applies when cloud-init is being used!"
    else
      image_cloud_init_seed_define="none"
    fi
  fi

  # Barebones
  if [ -n "$image_barebones" ]; then
    if [ -n "$image_cloud_software" ] && \
       [ "$image_cloud_software" != "none" ]; then
      error_message "'--barebones' implies '--no-cloud-configuration'!"
    fi
    if [ -n "$image_device_management" ] && \
       [ "$image_device_management" != "mdev" ]; then
      error_message "'--barebones' implies '--device-management mdev'!"
    fi
    if [ -n "$image_disable_optimisation" ] && \
       [ "$image_disable_optimisation" = "true" ]; then
      error_message "'--barebones' implies optimisation!"
    fi
    if [ -n "$image_enable_utmp" ] && [ "$image_enable_utmp" = "true" ]; then
      error_message "'--barebones' implies no UTMP!"
    fi
  fi

  # NTP
  if [ -n "$image_ntp_use" ]; then
    case $image_ntp_use in
      ptp )
        if [ "$image_class" = "physical" ] && \
           [ "$image_ntp_use" = "ptp" ]; then
          error_message \
            "PTP host sync can not be specified for physical servers!"
        fi
        if [ "$image_cloud_software" = "cloud-init" ]; then
          case $image_alpine_release in
            v3.13 | v3.14 | v3.15 | v3.16 | v3.17 | v3.18 | edge )
              error_message \
                "PTP host clock sync support is not present in this Alpine release."
              ;;
            edge-special )
              : ;;
          esac
        fi
        ;;
    esac
  fi
}


#
# Boot type/Partitioning type/Bootloader/etc settings.
#
default_boot_related_settings() {
  # Boot type: BIOS / Hybrid / RPI / Secure UEFI / UEFI etc
  if [ -z "$image_boot_type" ]; then
    # If boot type has not been explicitly specified then use default for
    # the particular arch and cloud/physical/virtual type
    if [ -n "$CADI_DEFAULT_BOOT_TYPE" ]; then
      image_boot_type="$CADI_DEFAULT_BOOT_TYPE"
    elif is_in_comma_list "$CADI_SUPPORTED_BOOT_TYPES" "hybrid"; then
      image_boot_type="hybrid"
    elif is_in_comma_list "$CADI_SUPPORTED_BOOT_TYPES" "bios"; then
      image_boot_type="bios"
    elif is_in_comma_list "$CADI_SUPPORTED_BOOT_TYPES" "uefi"; then
      image_boot_type="uefi"
    elif is_in_comma_list "$CADI_SUPPORTED_BOOT_TYPES" "rpi"; then
      image_boot_type="rpi"
    else
      error_message "Unable to determine boot type to use!"
    fi
  else
    if is_in_comma_list "$CADI_SUPPORTED_BOOT_TYPES" "$image_boot_type"; then
      # Specified boot_type is supported by particular arch and
      # cloud/physical/virtual type
      :
    else
      error_message \
        "Boot type '$image_boot_type' is not supported by $class_type_description!"
    fi
  fi

  # Boot partitioning type: GPT / Hybrid / MBR / Unpartitioned
  if [ -z "$image_os_partitioning_type" ]; then
    # If partitioning type has not been explicitly specified then use default
    # for the particular boot type
    case $image_boot_type in
      bios )
        if [ -n "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" ] && \
           { [ "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" = "unpartitioned" ] || \
             [ "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" = "mbr" ]; }; then
          image_os_partitioning_type="$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE"
        elif is_in_comma_list "$CADI_SUPPORTED_DISK_IMAGE_PARTITIONING_TYPES" \
                              "mbr"; then
          image_os_partitioning_type="mbr"
        elif is_in_comma_list "$CADI_SUPPORTED_DISK_IMAGE_PARTITIONING_TYPES" \
                              "unpartitioned"; then
          image_os_partitioning_type="unpartitioned"
        else
          error_message \
            "No supported partitioning type for $image_boot_type booting!"
        fi
        ;;
      hybrid )
        if [ -n "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" ] && \
           { [ "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" = "gpt" ] || \
             [ "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" = "mbr" ]; }; then
          image_os_partitioning_type="hybrid"
        elif is_in_comma_list "$CADI_SUPPORTED_DISK_IMAGE_PARTITIONING_TYPES" \
                              "gpt" || \
             is_in_comma_list "$CADI_SUPPORTED_DISK_IMAGE_PARTITIONING_TYPES" \
                              "mbr"; then
          image_os_partitioning_type="hybrid"
        else
          error_message \
            "No supported partitioning type for $image_boot_type booting!"
        fi
        ;;
      secure-uefi | uefi )
        if [ -n "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" ] && \
           [ "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" = "gpt" ]; then
          image_os_partitioning_type="$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE"
        elif is_in_comma_list "$CADI_SUPPORTED_DISK_IMAGE_PARTITIONING_TYPES" \
                              "gpt"; then
          image_os_partitioning_type="gpt"
        else
          error_message \
            "No supported partitioning type for $image_boot_type booting!"
        fi
        ;;
    esac
  elif [ -n "$image_os_partitioning_type" ]; then
    if is_in_comma_list "$CADI_SUPPORTED_BOOT_TYPES" \
                        "$image_os_partitioning_type"; then
      # Specified partitioning type is supported by particular boot type
      :
    else
      error_message \
        "Partitioning type '$image_boot_type' is not supported for $image_boot_type booting!"
    fi
  else
    error_message "Invalid partitioning type specified!"
  fi

  # Bootloader: EFISTUB, Grub, Limine, RPI, Syslinux, UKI etc
  if [ -z "$image_bootloader" ]; then
    # If bootloader has not been explicitly specified then use default for
    # the particular arch and cloud/physical/virtual type
    if [ -n "$CADI_DEFAULT_BOOTLOADER" ]; then
      case $image_boot_type in
        bios )
          if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_BIOS" \
                              "$CADI_DEFAULT_BOOTLOADER"; then
            image_bootloader="$CADI_DEFAULT_BOOTLOADER"
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_BIOS" "grub"; then
            image_bootloader="grub"
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_BIOS" \
                                "syslinux"; then
            image_bootloader="syslinux"
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_BIOS" \
                                "limine"; then
            image_bootloader="limine"
          else
            error_message \
              "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        hybrid )
          if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_HYBRID" \
                              "$CADI_DEFAULT_BOOTLOADER"; then
            image_bootloader="$CADI_DEFAULT_BOOTLOADER"
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_HYBRID" \
                                "grub"; then
            image_bootloader="grub"
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_HYBRID" \
                                "limine"; then
            image_bootloader="limine"
          else
            error_message \
              "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        rpi )
          if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_RPI" \
                              "$CADI_DEFAULT_BOOTLOADER"; then
            image_bootloader="$CADI_DEFAULT_BOOTLOADER"
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_RPI" "rpi"; then
            image_bootloader="rpi"
          else
            error_message \
              "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        secure-uefi )
          if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" \
                              "$CADI_DEFAULT_BOOTLOADER"; then
            image_bootloader="$CADI_DEFAULT_BOOTLOADER"
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" "grub"; then
            image_bootloader="grub"
          else
            error_message \
              "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        uefi )
          if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" \
                              "$CADI_DEFAULT_BOOTLOADER"; then
            image_bootloader="$CADI_DEFAULT_BOOTLOADER"
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" \
                                "efistub" && \
               [ -n "$image_experimental" ]; then
            image_bootloader="efistub"
            if [ -n "$image_efi_bootstub" ]; then
              case $image_efi_bootstub in
                gummiboot | stubby )
                  : ;;
                * )
                  error_message \
                    "Unknown UEFI bootstub '$image_efi_bootstub'!" ;;
              esac
            else
              image_efi_bootstub="$CADI_DEFAULT_EFI_BOOTSTUB"
            fi
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" "uki" && \
               [ -n "$image_experimental" ]; then
            image_bootloader="uki"
            if [ -n "$image_efi_bootstub" ]; then
              case $image_efi_bootstub in
                gummiboot | stubby )
                  : ;;
                * )
                  error_message \
                    "Unknown UEFI bootstub '$image_efi_bootstub'!" ;;
              esac
            else
              image_efi_bootstub="$CADI_DEFAULT_EFI_BOOTSTUB"
            fi
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" "grub"; then
            image_bootloader="grub"
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" \
                                "limine"; then
            image_bootloader="limine"
          else
            error_message \
              "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
      esac
    elif [ -n "$CADI_SUPPORTED_BOOT_TYPES" ]; then
      case $image_boot_type in
        bios )
          if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_BIOS" "grub"; then
            image_bootloader="grub"
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_BIOS" \
                                "syslinux"; then
            image_bootloader="syslinux"
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_BIOS" \
                                "limine"; then
            image_bootloader="limine"
          else
            error_message \
              "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        hybrid )
          if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_HYBRID" "grub"; then
            image_bootloader="grub"
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_HYBRID" \
                                "limine"; then
            image_bootloader="limine"
          else
            error_message \
              "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        rpi )
          if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_RPI" "rpi"; then
            image_bootloader="rpi"
          else
            error_message \
              "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        secure-uefi )
          if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" "grub"; then
            image_bootloader="grub"
          else
            error_message \
              "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        uefi )
          if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" "efistub" && \
             [ -n "$image_experimental" ]; then
            image_bootloader="efistub"
            if [ -n "$image_efi_bootstub" ]; then
              case $image_efi_bootstub in
                gummiboot | stubby )
                  : ;;
                * )
                  error_message \
                    "Unknown UEFI bootstub '$image_efi_bootstub'!" ;;
              esac
            else
              image_efi_bootstub="$CADI_DEFAULT_EFI_BOOTSTUB"
            fi
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" "uki" && \
             [ -n "$image_experimental" ]; then
            image_bootloader="uki"
            if [ -n "$image_efi_bootstub" ]; then
              case $image_efi_bootstub in
                gummiboot | stubby )
                  : ;;
                * )
                  error_message \
                    "Unknown UEFI bootstub '$image_efi_bootstub'!" ;;
              esac
            else
              image_efi_bootstub="$CADI_DEFAULT_EFI_BOOTSTUB"
            fi
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" "grub"; then
            image_bootloader="grub"
          elif is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" \
                                "limine"; then
            image_bootloader="limine"
          else
            error_message \
              "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
      esac
    else
      error_message "Unable to determine $image_boot_type bootloader to use!"
    fi
  elif [ -n "$image_bootloader" ]; then
    case $image_boot_type in
      bios )
        if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_BIOS" \
                            "$image_bootloader"; then
          :
        else
          error_message \
            "Bootloader '$image_bootloader' is not a valid bootloader to use for $image_boot_type booting!"
        fi
        ;;
      hybrid )
        if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_HYBRID" \
                            "$image_bootloader"; then
          :
        else
          error_message \
            "Bootloader '$image_bootloader' is not a valid bootloader to use for $image_boot_type booting!"
        fi
        ;;
      rpi )
        if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_RPI" \
                            "$image_bootloader"; then
          :
        else
          error_message \
            "Bootloader '$image_bootloader' is not a valid bootloader to use for $image_boot_type booting!"
        fi
        ;;
      secure-uefi )
        if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" \
                            "$image_bootloader"; then
          :
        else
          error_message \
            "Bootloader '$image_bootloader' is not a valid bootloader to use for $image_boot_type booting!"
        fi
        ;;
      uefi )
        if is_in_comma_list "$CADI_SUPPORTED_BOOTLOADERS_UEFI" \
                            "$image_bootloader"; then
          if [ -z "$image_experimental" ] && \
             { [ "$image_bootloader" = "efistub" ] || \
               [ "$image_bootloader" = "uki" ]; }; then
            error_message \
              "$image_bootloader bootloader support is an experimental option!"
          else
            case $image_bootloader in
              efistub | uki )
                if [ -n "$image_efi_bootstub" ]; then
                  case $image_efi_bootstub in
                    gummiboot | stubby )
                      : ;;
                    * )
                      error_message \
                        "Unknown UEFI bootstub '$image_efi_bootstub'!" ;;
                  esac
                else
                  image_efi_bootstub="$CADI_DEFAULT_EFI_BOOTSTUB"
                fi
                ;;
              * )
                # Specified bootloader is supported by particular arch and
                # cloud/physical/virtual type
                : ;;
            esac
          fi
        else
          error_message \
            "Bootloader '$image_bootloader' is not a valid bootloader to use for $image_boot_type booting!"
        fi
        ;;
    esac
  else
    error_message "Invalid bootloader specified!"
  fi

  # Boot device logical sector size (in bytes): 512 bytes / 4K
  : "${image_os_device_sector_size:=512}"

  # Check whether the particular boot method works with 4K sector devices.
  case $image_boot_type in
    bios | rpi )
      if [ "$image_os_device_sector_size" = 4096 ]; then
        error_message "4K sector size is not supported for BIOS/MBR booting!"
      fi
      ;;
  esac

  # Whether to refer to boot filesystem by UUID or device name
  if [ -z "$image_boot_reference" ]; then
    if [ -n "$CADI_DEFAULT_BOOT_REFERENCE" ] && \
       [ -n "$CADI_SUPPORTED_BOOT_REFERENCES" ] && \
       is_in_comma_list "$CADI_SUPPORTED_BOOT_REFERENCES" \
                        "$CADI_DEFAULT_BOOT_REFERENCE"; then
      image_boot_reference="$CADI_DEFAULT_BOOT_REFERENCE"
    elif [ -n "$CADI_SUPPORTED_BOOT_REFERENCES" ]; then
      image_boot_reference="$(first_entry_in_comma_list "$CADI_SUPPORTED_BOOT_REFERENCES")"
    else
      error_message \
        "Unable to determine whether to use UUID or device name to refer to boot filesystem!"
    fi
  elif [ -n "$CADI_SUPPORTED_BOOT_REFERENCES" ] && \
       is_in_comma_list "$CADI_SUPPORTED_BOOT_REFERENCES" \
                        "$image_boot_reference"; then
    :
  else
    error_message \
      "Boot reference '$image_boot_reference' is not supported by $class_type_description!"
  fi

  # OS Boot device type:
  #     nvme / pvscsi / sata / scsi / sd / usb / virtio-blk / virtio-scsi
  if [ -z "$image_os_device_type" ]; then
    # Automatically decide OS boot device type
    if [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ]; then
      if [ -n "$CADI_DEFAULT_OS_DEVICE_TYPE" ]; then
        if [ "$CADI_DEFAULT_OS_DEVICE_TYPE" = "generic" ] && \
           is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" "generic"; then
          image_os_device_type="generic"
        elif is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" \
                              "$CADI_DEFAULT_OS_DEVICE_TYPE"; then
          image_os_device_type="$CADI_DEFAULT_OS_DEVICE_TYPE"
        else
          error_message \
            "Default OS device type '$CADI_DEFAULT_OS_DEVICE_TYPE' is not defined in CADI_SUPPORTED_OS_DEVICE_TYPES!"
        fi
      elif is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" \
                            "virtio-blk"; then
        image_os_device_type="virtio-blk"
      elif is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" \
                            "virtio-scsi"; then
        image_os_device_type="virtio-scsi"
      elif is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" "nvme"; then
        image_os_device_type="nvme"
      elif is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" "pvscsi"; then
        image_os_device_type="pvscsi"
      elif is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" "sata"; then
        image_os_device_type="sata"
      elif is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" "scsi"; then
        image_os_device_type="scsi"
      elif is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" "usb"; then
        image_os_device_type="usb"
      elif is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" "sd"; then
        image_os_device_type="sd"
      else
        error_message \
          "Unable to determine OS device type to use for $class_type_description!"
      fi
    else
      error_message \
        "Unable to determine OS device type to use for $class_type_description as CADI_SUPPORTED_OS_DEVICE_TYPES is not defined!"
    fi
  elif [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ] && \
       is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" \
                        "$image_os_device_type"; then
    # Boot device type specified is fine
    :
  else
      error_message \
        "Specified OS device type '$image_os_device_type' is not valid for $class_type_description!"
  fi

  # OS Boot device media: disk / flash / sdcard / ssd
  if [ -z "$image_os_device_media" ]; then
    # Automatically decide OS boot device media
    if [ -n "$CADI_SUPPORTED_OS_DEVICE_MEDIAS" ]; then
      case $image_os_device_type in
        nvme )
          if is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_MEDIAS" "ssd"; then
            image_os_device_media="ssd"
          else
            error_message \
              "Unable to determine OS device media to use for $class_type_description with $image_os_device_type storage device!"
          fi
          ;;
        sd )
          if is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_MEDIAS" "sdcard"; then
            image_os_device_media="sdcard"
          else
            error_message \
              "Unable to determine OS device media to use for $class_type_description with $image_os_device_type storage device!"
          fi
          ;;
        usb )
          if is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_MEDIAS" "flash"; then
            image_os_device_media="flash"
          else
            error_message \
              "Unable to determine OS device media to use for $class_type_description with $image_os_device_type storage device!"
          fi
          ;;
        * )
          if is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_MEDIAS" "disk"; then
            image_os_device_media="disk"
          else
            error_message \
              "Unable to determine OS device media to use for $class_type_description with $image_os_device_type storage device!"
          fi
          ;;
      esac
    else
      error_message \
        "Unable to determine OS device media to use as no storage medias defined for $class_type_description with $image_os_device_type storage device!"
    fi
  elif [ -n "$CADI_SUPPORTED_OS_DEVICE_MEDIAS" ] && \
       is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_MEDIAS" \
                        "$image_os_device_media"; then
    case $image_os_device_type in
      nvme )
        if [ "$image_os_device_media" != "ssd" ]; then
          error_message \
            "OS device media $image_os_device_media is not valid for $image_os_device_type storage device!"
        fi
        ;;
      sd )
        if [ "$image_os_device_media" != "sdcard" ]; then
          error_message \
            "OS device media $image_os_device_media is not valid for $image_os_device_type storage device!"
        fi
        ;;
      usb )
        if [ "$image_os_device_media" != "flash" ]; then
          error_message \
            "OS device media $image_os_device_media is not valid for $image_os_device_type storage device!"
        fi
        ;;
      * )
        if [ "$image_os_device_media" != "disk" ] && \
           [ "$image_os_device_media" != "ssd" ]; then
          error_message \
            "Specified OS device media $image_os_device_media is not valid for $image_os_device_type storage device!"
        fi
        ;;
    esac
  else
    error_message \
      "Specified OS device media '$image_os_device_media' is not valid for $class_type_description!"
  fi

  # Filesystem type: btrfs/  f2fs / ext4 / xfs
  if [ -z "$image_fs_type" ]; then
    # If filesystem type has not been explicitly specified then use default
    # or one of the supported alternative filesystems for the particular
    # cloud/physical/virtual type
    if [ -n "$CADI_DEFAULT_OS_FILESYSTEM" ] && \
       is_in_comma_list "$CADI_SUPPORTED_OS_FILESYSTEMS" \
                        "$CADI_DEFAULT_OS_FILESYSTEM"; then
      image_fs_type="$CADI_DEFAULT_OS_FILESYSTEM"
    elif is_in_comma_list "$CADI_SUPPORTED_OS_FILESYSTEMS" "ext4"; then
      image_fs_type="ext4"
    elif is_in_comma_list "$CADI_SUPPORTED_OS_FILESYSTEMS" "xfs"; then
      image_fs_type="xfs"
    elif [ -n "$image_experimental" ] && \
         is_in_comma_list "$CADI_SUPPORTED_OS_FILESYSTEMS" "btrfs"; then
      image_fs_type="btrfs"
    elif [ -n "$image_experimental" ] && \
         is_in_comma_list "$CADI_SUPPORTED_OS_FILESYSTEMS" "f2fs"; then
      image_fs_type="f2fs"
    else
      error_messages "Unable to determine filesystem type to use!"
    fi
  elif [ -n "$image_fs_type" ]; then
    if is_in_comma_list "$CADI_SUPPORTED_OS_FILESYSTEMS" "$image_fs_type"; then
      if [ -z "$image_experimental" ] && \
         { [ "$image_fs_type" = "btrfs" ] || \
           [ "$image_fs_type" = "f2fs" ]; }; then
        error_message \
          "Support for '$image_fs_type' filesystem type is experimental!"
      else
        # Specified boot_type is supported by particular
        # cloud/physical/virtual type
        :
      fi
    else
      error_message \
        "Boot type '$image_fs_type' ia not supported by $class_type_description!"
    fi
  else
    error_message "Invalid filesystem type specified!"
  fi

  if [ "$image_class" != "virtual" ] || \
     { [ "$image_vm_type" != "firecracker" ] && \
       [ "$image_vm_type" != "qemu-microvm" ]; }; then
    # Verify that specific bootloader can boot from specific filesystem type
    check_bootloader_supports_fs
  fi

  # Storage encryption: fscrypt / luks / both
  if [ -z "$image_encryption_type" ]; then
    image_encryption_type="none"
  elif [ -n "$CADI_SUPPORTED_OS_LUKS_ENCRYPTION" ] && \
       [ "$CADI_SUPPORTED_OS_LUKS_ENCRYPTION" = "false" ] && \
       { [ "$image_encryption_type" = "luks" ] || \
         [ "$image_encryption_type" = "both" ]; }; then
    error_message \
      "LUKS encryption is not supported by $class_type_description!"
  else
    case $image_encryption_type in
      both | fscrypt )
        case $image_fs_type in
          ext4 | f2fs )
            : ;;
          * )
            error_message \
              "Filesystem type $image_fs_type does not support fscrypt encryption!"
            ;;
        esac
        ;;
    esac

    case $image_encryption_type in
      both | luks )
        if [ -n "$luks_remote_unlock_enabled" ] && \
           [ "$image_class" = "cloud" ]; then
          error_message \
            "Remote unlocking of encrypted rootfs is not supported in cloud!"
        fi
        ;;
    esac
  fi

  case $image_encryption_type in
    both | luks )
      decide_luks_version ;;
  esac

  # Decide whether a separate boot partition is required
  if [ -z "$image_create_boot_partition" ]; then
    if [ -n "$CADI_BOOT_PARTITION_REQUIRED" ]; then
      case $CADI_BOOT_PARTITION_REQUIRED in
        true )
          if [ "$image_os_partitioning_type" = "unpartitioned" ]; then
            error_message \
              "Contradiction in settings, a separate /boot partition is required but disk is unpartitioned!"
          elif [ -n "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" ] && \
             [ "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" = "true" ]; then
            image_create_boot_partition=true
          elif [ -n "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" ]; then
            error_message \
              "Contradiction in settings, a separate /boot partition is required but not supported by $class_type_description!"
          else
            image_create_boot_partition=false
          fi
          ;;
        * )
          image_create_boot_partition=false ;;
      esac
    else
      case $image_bootloader in
        efistub | uki )
          # EFISTUB and UKI are UEFI only so no need for a separate /boot
          image_create_boot_partition=false ;;
        grub )
          case $image_encryption_type in
            both | luks )
              # When GRUB is bootloader a separate boot partition is required
              # if using an LUKS encrypted rootfs:
              #   - with remote unlock OR
              #   - with Adiantum encryption (GRUB's LUKS module does
              #     not support this)
              if { [ -n "$image_experimental" ] && \
                   [ -n "$luks_remote_unlock_enabled" ]; } || \
                 [ "$image_luks_cipher" = "adiantum" ]; then
                if [ "$image_os_partitioning_type" = "unpartitioned" ]; then
                  error_message \
                    "Contradiction in settings, a separate /boot partition is required but not supported by $class_type_description!"
                elif [ -n "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" ] && \
                     [ "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" = "true" ]; then
                  image_create_boot_partition=true
                else
                  error_message \
                    "A separate /boot partition is required but is not clear if supported by $class_type_description!"
                fi
              else
                image_create_boot_partition=false
              fi
              ;;
          esac
          if [ "$image_create_boot_partition" = "true" ]; then
            # By creating a separate boot partition this means that GRUB should
            # not enable its own FDE encryption support as that would make no
            # sense (why have separate yet both encrypted boot and rootfs?).
            image_no_grub_luks_fde_encryption=true
          fi
          ;;
        limine | syslinux )
          if [ "$image_encryption_type" = "both" ] || \
             [ "$image_encryption_type" = "luks" ] || \
             [ -n "$image_lvm_rootfs" ]; then
            # When Syslinux is bootloader a separate boot partition is
            # required with LUKS encrypted rootfs or LVM rootfs.
            if [ "$image_os_partitioning_type" = "unpartitioned" ]; then
              error_message \
                "A separate /boot partition is required but is not clear if supported by $class_type_description!"
            else
              image_create_boot_partition=true
            fi
          fi
          ;;
      esac
    fi
  elif [ "$image_create_boot_partition" = "true" ]; then
    if [ "$image_os_partitioning_type" = "unpartitioned" ]; then
      error_message \
        "A separate /boot partition was spcified but disk is unpartitioning!"
    elif [ -n "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" ] && \
       [ "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" = "true" ]; then
    # Separate /boot is supported
      image_create_boot_partition=true
    else
      error_message \
        "A separate /boot partition is not supported by $class_type_description!"
    fi
  else
    image_create_boot_partition=false
  fi

  # Swapfile
  : "${image_swap_file_size:=0}"
  if [ "$image_swap_file_size" != "0" ]; then
    image_create_swap_file=true
  else
    image_create_swap_file=false
  fi

  # Swap partition
  : "${image_swap_partition_size:=0}"
  if [ "$image_swap_partition_size" != "0" ] && \
     [ "$image_os_partitioning_type" != "unpartitioned" ]; then
    if [ -n "$CADI_SUPPORTED_OS_BOOT_DISK_SWAP" ] && \
       [ "$CADI_SUPPORTED_OS_BOOT_DISK_SWAP" = "true" ]; then
      image_create_swap_partition=true
    else
      image_create_swap_partition=false
    fi
  elif [ "$image_swap_partition_size" != "0" ]; then
    error_message \
      "Disk is unpartitioned and so cannot create a swap partition!"
  else
    image_create_swap_partition=false
  fi
}


#
# Console related settings.
#
default_console_related_settings() {
  # Console device type
  if [ -n "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES" ]; then
    if [ -n "$image_console_device_type" ]; then
      if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES" \
                          "$image_console_device_type"; then
        # image_console_device_type value is ok
        :
      else
        error_message \
          "Console device type '$image_console_device_type' is not supported for '$class_type_description'!"
      fi
    else
      # Automatically determine console type
      if [ -n "$CADI_DEFAULT_CONSOLE_DEVICE_TYPE" ]; then
        if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES" \
                            "$CADI_DEFAULT_CONSOLE_DEVICE_TYPE"; then
          image_console_device_type="$CADI_DEFAULT_CONSOLE_DEVICE_TYPE"
        else
          error_message \
            "Console device type '$image_console_device_type' is not supported for '$class_type_description'!"
        fi
      elif is_single_entry_in_comma_list \
           "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES"; then
        image_console_device_type="$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES"
      else
        error_message \
          "CADI_DEFAULT_CONSOLE_DEVICE_TYPE is not defined for '$class_type_description'!"
      fi
    fi
  else
    error_message \
      "CADI_SUPPORTED_CONSOLE_DEVICE_TYPES is not defined for '$class_type_description'!"
  fi


  # UEFI does not handle text output, only graphics, so check for this
  # and override output mode and enable graphics if required.
  case $image_boot_type in
    hybrid | secure-uefi | uefi )
      case $image_console_device_type in
        none | hypervisor | serial )
          # No UEFI console output
          : ;;
        * )
          image_console_output_type="graphics"
          image_enable_graphics=true
          ;;
      esac
      ;;
  esac

  # Console output type
  case $image_console_device_type in
    generic )
      if [ -n "$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE" ]; then
        if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" \
                            "$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE"; then
          image_console_output_type="$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE"
        else
          error_message \
            "Default console output type is not defined in CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES for $class_type_description!"
        fi
      elif is_in_comma_list "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" \
                            "generic"; then
        # Use "generic" if in list
        image_console_output_type="generic"
      elif is_in_comma_list "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" \
                            "graphics"; then
        # Use "graphics" if in list
        image_console_output_type="graphics"
      elif is_in_comma_list "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" \
                            "text"; then
        # Use "text" if in list
        image_console_output_type="text"
      else
        error_message \
          "Unable to select console output type from $CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES for $class_type_description!"
      fi
      ;;

    hypervisor | serial )
      if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" "text"; then
        image_console_output_type="text"
      else
        error_message \
          "Unable to select 'text' console output type from $CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES for $class_type_description!"
      fi
      ;;

    none )
      if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" "none"; then
        image_console_output_type="none"
      else
        error_message \
          "Unable to select 'none' console output type from $CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES for $class_type_description!"
      fi
      ;;

    * )
      # normal or normal_and_serial
      if [ -n "$image_enable_graphics" ] && \
         [ "$image_enable_graphics" = "true" ]; then
        # Graphics output is required
        if [ -n "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" ] && \
           is_in_comma_list "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" \
                            "graphics"; then
          image_console_output_type="graphics"
        else
          error_message \
            "Graphics console forced but graphics console output type not defined in CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES for $class_type_description!"
        fi
      elif [ -z "$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE" ]; then
        # No default output type defined so look at what is supported
        if [ -n "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" ]; then
          if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" \
                              "generic"; then
            image_console_output_type="generic"
          elif is_in_comma_list "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" \
                                "graphics"; then
            image_console_output_type="graphics"
          elif is_in_comma_list "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" \
                                "text" && \
               [ "$image_boot_type" = "bios" ]; then
            # Text mode can only be used for BIOS based systems   
            image_console_output_type="text"
          elif is_in_comma_list "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" \
                                "none"; then
            image_console_output_type="none"
          else
            error_message \
              "Unable to determine console output type from CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES for $class_type_description!"
          fi
        else
          error_message \
            "Unable to determine console output type for $class_type_description as CADI_DEFAULT_CONSOLE_OUTPUT_TYPE and CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES are undefined!"
        fi
      else
        # Default console output type is defined, use that if supported.
        if [ -n "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" ]; then
          if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" \
                              "$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE"; then
            case $CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES in
              text )
                case $image_boot_type in
                  bios )
                    # VGA Text mode can only be used for BIOS based systems
                    image_console_output_type="text" ;;
                  secure-uefi | uefi )
                    if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" \
                                        "graphics"; then
                      # Text mode can not be used for UEFI based systems
                      image_console_output_type="graphics"
                    else
                      error_message \
                        "Cannot determine which type of console output to use for $image_boot_type boot type and $class_type_description as 'graphics' is not defined in CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES!"
                    fi
                    ;;
                  * )
                    error_message \
                      "Cannot determine which type of console output to use for $image_boot_type boot type and $class_type_description!"
                    ;;
                esac
                ;;
              *)
                image_console_output_type="$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE"
                ;;
            esac
          else
            error_message \
              "Cannot use default console output type for $class_type_description as it is not defined in CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES!"
          fi
        else
          error_message \
            "Cannot use default console output type for $class_type_description as CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES is not defined!"
        fi
      fi
      ;;
  esac

  # Console graphics & graphics driver
  case $image_console_output_type in
    generic )
      case $image_boot_type in
        hybrid | secure-uefi | uefi )
          image_enable_graphics=true
          : "${image_graphics_driver:=$CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER}"
          ;;
      esac
      ;;
    graphics )
      image_enable_graphics=true
      : "${image_graphics_driver:=$CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER}"
      ;;
  esac

  # Console keyboard
  case $image_console_device_type in
    hypervisor | serial )
      if [ -n "$image_keyboard_type" ]; then
        error_message \
          "Keyboard type '$image_keyboard_type' makes no sense for a $image_console_device_type console!"
      else
        image_keyboard_type="none"
      fi
      ;;

    * )
      if [ -n "$CADI_SUPPORTED_CONSOLE_KEYBOARD_TYPES" ]; then
        if [ -n "$image_keyboard_type" ]; then
          if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_KEYBOARD_TYPES" \
                              "$image_keyboard_type"; then
            # Use specified keyboard type
            :
          else
            error_message \
              "Console keyboard type '$image_keyboard_type' is not supported for '$class_type_description'!"
          fi
        else
          # Automatically determine console keyboard type
          if [ -n "$CADI_DEFAULT_CONSOLE_KEYBOARD_TYPE" ]; then
            if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_KEYBOARD_TYPES" \
                                "$CADI_DEFAULT_CONSOLE_KEYBOARD_TYPE"; then
              image_keyboard_type="$CADI_DEFAULT_CONSOLE_KEYBOARD_TYPE"
            else
              error_message \
                "Console keyboard type '$image_keyboard_type' is not supported for '$class_type_description'!"
            fi
          elif is_single_entry_in_comma_list \
               "$CADI_SUPPORTED_CONSOLE_KEYBOARD_TYPES"; then
            image_keyboard_type="$CADI_SUPPORTED_CONSOLE_KEYBOARD_TYPES"
          else
            error_message \
              "CADI_DEFAULT_CONSOLE_KEYBOARD_TYPE is not defined for '$class_type_description'!"
          fi
        fi
      else
        error_message \
          "CADI_SUPPORTED_CONSOLE_KEYBOARD_TYPES is not defined for '$class_type_description'!"
      fi
      ;;
  esac

  # Serial config
  case $image_console_device_type in
    normal_and_serial | serial | generic )
      if [ -n "$CADI_SUPPORTED_SERIAL_CONSOLE_PORT_NUMBER" ]; then
        : "${image_serial_console_port_number:=$CADI_SUPPORTED_SERIAL_CONSOLE_PORT_NUMBER}"
      else
        error_message \
          "CADI_SUPPORTED_SERIAL_CONSOLE_PORT_NUMBER is not defined for '$class_type_description'!"
      fi
      if [ -n "$CADI_SUPPORTED_SERIAL_CONSOLE_PORT_BASE_NAME" ]; then
        image_serial_console_name="${CADI_SUPPORTED_SERIAL_CONSOLE_PORT_BASE_NAME}${image_serial_console_port_number}"
      else
        error_message \
          "CADI_SUPPORTED_SERIAL_CONSOLE_PORT_BASE_NAME is not defined for '$class_type_description'!"
      fi
      if [ -n "$CADI_SUPPORTED_SERIAL_CONSOLE_PORT_SPEED" ]; then
        image_serial_console_speed="${CADI_SUPPORTED_SERIAL_CONSOLE_PORT_SPEED}"
      else
        image_serial_console_speed="9600"
      fi
      if [ -n "$CADI_SUPPORTED_SERIAL_CONSOLE_DATA_BITS" ]; then
        image_serial_console_data_bits="${CADI_SUPPORTED_SERIAL_CONSOLE_DATA_BITS}"
      fi
      if [ -n "$CADI_SUPPORTED_SERIAL_CONSOLE_PARITY" ]; then
        image_serial_console_parity="${CADI_SUPPORTED_SERIAL_CONSOLE_PARITY}"
      fi
      if [ -n "$CADI_SUPPORTED_SERIAL_CONSOLE_STOP_BITS" ]; then
        image_serial_console_stop_bits="${CADI_SUPPORTED_SERIAL_CONSOLE_STOP_BITS}"
      fi
      ;;
  esac

  # Console device name
  case $image_console_device_type in
    generic )
      image_console_device_name="tty0"
      if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES" \
                          "hypervisor"; then
        image_console_device_name="${image_console_device_name},hvc0"
      fi
      ;;
    normal | normal_and_serial )
      image_console_device_name="tty0" ;;
    hypervisor )
      image_console_device_name="hvc0" ;;
    serial )
      image_console_device_name=$image_serial_console_name ;;
  esac
}


#
# NTP related settings.
#
default_ntp_related_settings() {
  if [ -n "$CADI_DEFAULT_NTP_METHOD" ]; then
    case $CADI_DEFAULT_NTP_METHOD in
      none )
        image_ntp_method="none" ;;

      pools )
        image_ntp_method="pools" ;;

      ptp )
        if [ "$image_cloud_software" = "cloud-init" ] && \
           [ "$image_class" != "physical" ]; then
          case $image_alpine_release in
            v3.13 | v3.14 | v3.15 | v3.16 | v3.17 | v3.18 | edge)
              # PTP not supported, fallback to another option
              if is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "servers" && \
                 { [ -n "$image_ntp_servers" ] || \
                   [ -n "$CADI_NTP_SERVERS" ] || \
                   [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
                   [ -n "$CADI_NTP_IPV6_SERVERS" ]; }; then
                image_ntp_method="servers"
              elif is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "pools"; then
                image_ntp_method="pools"
              else
                image_ntp_method="unknown"
              fi
              ;;
            edge-special )
              image_ntp_method="ptp" ;;
          esac
        elif [ "$image_cloud_software" != "cloud-init" ] && \
             [ "$image_ntp_daemon" = "chrony" ] && \
             [ "$image_class" != "physical" ]; then
          image_ntp_method="ptp"
        else
          # PTP not supported, fallback to another option
          if is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "servers" && \
             { [ -n "$image_ntp_servers" ] || \
               [ -n "$CADI_NTP_SERVERS" ] || \
               [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
               [ -n "$CADI_NTP_IPV6_SERVERS" ]; }; then
            image_ntp_method="servers"
          elif is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "pools"; then
            image_ntp_method="pools"
          else
            image_ntp_method="unknown"
          fi
        fi
        ;;

      servers )
        if [ -n "$image_ntp_servers" ] || \
           [ -n "$CADI_NTP_SERVERS" ] || \
           [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
           [ -n "$CADI_NTP_IPV6_SERVERS" ]; then
          image_ntp_method="servers"
        elif is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "pools" && \
             [ -n "$CADI_NTP_POOLS" ]; then
          image_ntp_method="pools"
        else
          image_ntp_method="unknown"
        fi
        ;;

      servers_and_pools )
        if { [ -n "$image_ntp_servers" ] || \
             [ -n "$CADI_NTP_SERVERS" ] || \
             [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
             [ -n "$CADI_NTP_IPV6_SERVERS" ]; } && \
           { is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "pools" && \
             [ -n "$CADI_NTP_POOLS" ]; }; then
          image_ntp_method="servers_and_pools"
        elif { [ -n "$image_ntp_servers" ] || \
               [ -n "$CADI_NTP_SERVERS" ] || \
               [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
               [ -n "$CADI_NTP_IPV6_SERVERS" ]; } && \
             { ! is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "pools" || \
               [ -z "$CADI_NTP_POOLS" ]; }; then
          image_ntp_method="servers"
        elif is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "pools" && \
             [ -n "$CADI_NTP_POOLS" ]; then
          image_ntp_method="pools"
        else
          image_ntp_method="unknown"
        fi
        ;;
    esac
  elif is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "ptp"; then
    image_ntp_method="ptp"
  elif is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "servers_and_pools" && \
       { [ -n "$image_ntp_servers" ] || \
         [ -n "$CADI_NTP_SERVERS" ] || \
         [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
         [ -n "$CADI_NTP_IPV6_SERVERS" ]; } && \
       is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "pools"; then
    image_ntp_method="servers_and_pools"
  elif is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "servers" && \
       { [ -n "$image_ntp_servers" ] || \
         [ -n "$CADI_NTP_SERVERS" ] || \
         [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
         [ -n "$CADI_NTP_IPV6_SERVERS" ]; }; then
    image_ntp_method="servers"
  elif is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "pools"; then
    image_ntp_method="pools"
  else
    image_ntp_method="unknown"
  fi


  case $image_ntp_method in
    pools )
      if [ -n "$CADI_NTP_POOLS" ]; then
        image_ntp_pools_list="$CADI_NTP_POOLS"
      else
        image_ntp_pools_list="$CADI_GENERAL_NTP_POOLS"
      fi
      image_ntp_pools_options="iburst"
      ;;

    ptp )
      if [ -n "$CADI_PTP_DEVICE_NAME" ]; then
        image_chrony_phc_device="$CADI_PTP_DEVICE_NAME"
      else
        image_chrony_phc_device="/dev/ptp0"
      fi
      if [ -n "$CADI_PTP_DPOLL" ]; then
        image_chrony_phc_dpoll="$CADI_PTP_DPOLL"
      fi
      if [ -n "$CADI_PTP_OFFSET" ]; then
        image_chrony_phc_offset="$CADI_PTP_OFFSET"
      fi
      if [ -n "$CADI_PTP_POLL" ]; then
        image_chrony_phc_poll="$CADI_PTP_POLL"
      fi
      if [ -n "$CADI_PTP_STRATUM" ]; then
        image_chrony_phc_stratum="$CADI_PTP_STRATUM"
      fi
      ;;

    servers )
      if [ -n "$image_ntp_servers" ]; then
        image_ntp_servers_list="$image_ntp_servers"
      else
        if [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
           [ -n "$CADI_NTP_IPV6_SERVERS" ]; then
          if [ -z "$image_disable_ipv4" ] && \
             [ -n "$CADI_NTP_IPV4_SERVERS" ]; then
            image_ntp_servers_list="$CADI_NTP_IPV4_SERVERS"
          fi
          if [ -z "$image_disable_ipv6" ] && \
             [ -n "$CADI_NTP_IPV6_SERVERS" ]; then
            if [ -n "$image_ntp_servers_list" ]; then
              image_ntp_servers_list="$image_ntp_servers_list $CADI_NTP_IPV6_SERVERS"
            else
              image_ntp_servers_list="$CADI_NTP_IPV6_SERVERS"
            fi
          fi
        fi
	if [ -n "$CADI_NTP_SERVERS" ]; then
          if [ -n "$image_ntp_servers_list" ]; then
            image_ntp_servers_list="$image_ntp_servers_list $CADI_NTP_SERVERS"
          else
            image_ntp_servers_list="$CADI_NTP_SERVERS"
          fi
        fi
      fi
      if [ -n "$CADI_NTP_SERVERS_OPTIONS" ]; then
        image_ntp_servers_options="$CADI_NTP_SERVERS_OPTIONS"
      else
        image_ntp_servers_options="$CADI_GENERAL_NTP_SERVERS_OPTIONS"
      fi
      ;;

    servers_and_pools )
      if [ -n "$image_ntp_servers" ]; then
        image_ntp_servers_list="$image_ntp_servers"
      else
        if [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
           [ -n "$CADI_NTP_IPV6_SERVERS" ]; then
          if [ -z "$image_disable_ipv4" ] && \
             [ -n "$CADI_NTP_IPV4_SERVERS" ]; then
            image_ntp_servers_list="$CADI_NTP_IPV4_SERVERS"
          fi
          if [ -z "$image_disable_ipv6" ] && \
             [ -n "$CADI_NTP_IPV6_SERVERS" ]; then
            image_ntp_servers_list="$CADI_NTP_IPV6_SERVERS"
          fi
        fi
	if [ -n "$CADI_NTP_SERVERS" ]; then
          if [ -n "$image_ntp_servers_list" ]; then
            image_ntp_servers_list="$image_ntp_servers_list $CADI_NTP_SERVERS"
          else
            image_ntp_servers_list="$CADI_NTP_SERVERS"
          fi
        fi
      fi
      if [ -n "$CADI_NTP_SERVERS_OPTIONS" ]; then
        image_ntp_servers_options="$CADI_NTP_SERVERS_OPTIONS"
      else
        image_ntp_servers_options="$CADI_GENERAL_NTP_SERVERS_OPTIONS"
      fi

      if [ -n "$CADI_NTP_POOLS" ]; then
        image_ntp_pools_list="$CADI_NTP_POOLS"
        image_ntp_pools_options="iburst"
      fi
      ;;

    none | unknown )
      : ;;

    * )
      error_message "Not a valid NTP method: '$image_ntp_method'!"
      ;;
  esac

  if [ "$image_ntp_daemon" = "chrony" ]; then
    if [ -n "$CADI_CHRONY_INITSTEPSLEW_THRESHOLD" ]; then
      image_chrony_initstepslew_threshold="$CADI_CHRONY_INITSTEPSLEW_THRESHOLD"
      case $image_ntp_method in
        pools )
          image_chrony_initstepslew_hosts=$image_ntp_pools_list ;;

        servers | servers_and_pools )
          image_chrony_initstepslew_hosts=$image_ntp_servers_list ;;
      esac
    fi
    if [ -n "$CADI_CHRONY_MAKESTEP_THRESHOLD" ]; then
      image_chrony_makestep_threshold="$CADI_CHRONY_MAKESTEP_THRESHOLD"
    fi
    if [ -n "$CADI_CHRONY_MAKESTEP_LIMIT" ]; then
      image_chrony_makestep_limit="$CADI_CHRONY_MAKESTEP_LIMIT"
    fi
  fi
}


#
# Partition sizing related settings.
#
partition_sizing_related() {
  local _base_bootfs_size _base_rootfs_size _bootfs_extra_space
  local _bootloader_files_size _bootloader_packages_size
  local _cloud_cli_packages_size _config_software_packages_size
  local _hypervisor_agent_packages_size _kernel_rootfs_files_size
  local _packages_additional_size _packages_extra_size
  local _packages_optional_size _sbom_packages_size

  # Set the ESP partition filesystem type now that the boot method is known
  case $image_boot_type in
    hybrid | secure-uefi | uefi )
      if [ -z "$image_esp_type" ]; then
        case $image_bootloader in
          efistub | uki )
            image_esp_type="${image_esp_type:=$CADI_DEFAULT_EFISTUB_ESP_TYPE}"
            ;;
          * )
            image_esp_type="${image_esp_type:=$CADI_DEFAULT_ESP_TYPE}" ;;
        esac
      fi
      ;;
  esac

  if [ "$image_create_boot_partition" = "true" ] && \
     [ -n "$boot_part_size" ]; then
    # Explicitly set the size of the /boot partition
    image_boot_part_size="${boot_part_size}"
  fi


  # Sort out partition sizing
  #---------------------------

  # Bootloader related sizing
  case $image_bootloader in
    grub | limine | rpi | syslinux )
      # shellcheck disable=SC2018,SC2019
      eval \
        _bootloader_files_size='$'CADI_BOOTLOADER_"$(echo "$image_bootloader" | tr 'a-z' 'A-Z')"_BOOT_FILES_SIZE
      # shellcheck disable=SC2018,SC2019
      eval \
        _bootloader_packages_size='$'CADI_BOOTLOADER_"$(echo "$image_bootloader" | tr 'a-z' 'A-Z')"_PACKAGES_SIZE
      ;;
  esac
  : "${_bootloader_files_size:=0}"
  : "${_bootloader_packages_size:=0}"

  # Additional kernel driver packages specific to the cloud/virtual/physical
  # machine type
  # shellcheck disable=SC2018,SC2019
  eval \
    _driver_packages_list='$'CADI_"$(echo "$image_class" | tr 'a-z' 'A-Z')"_DRIVER_PACKAGES_LIST
  # shellcheck disable=SC2018,SC2019
  eval \
    _driver_packages_size='$'CADI_"$(echo "$image_class" | tr 'a-z' 'A-Z')"_DRIVER_PACKAGES_SIZE
  # shellcheck disable=SC2018,SC2019
  eval \
    _driver_packages_notpresentin='$'CADI_"$(echo "$image_class" | tr 'a-z' 'A-Z')"_DRIVER_PACKAGES_NOTPRESENTIN
  if [ -n "$_driver_packages_list" ]; then
    if [ -n "$_driver_packages_notpresentin" ] && \
       ! is_in_comma_list "$_driver_packages_notpresentin" \
                          "$image_alpine_release"; then
      # Packages are not available for this release of Alpine
      _driver_packages_list=""
    elif [ -z "$_driver_packages_size" ]; then
      error_message \
        "Kernel driver packages for $class_type_description defined but no installed size defined for them!"
    else
      _driver_packages_list="$(echo $_driver_packages_list | tr ',' ' ')"
    fi
  fi

  # Additional packages specific to the cloud/virtual/physical machine type
  if [ -n "$CADI_PACKAGES_ADDITIONAL" ]; then
    if [ -n "$CADI_PACKAGES_ADDITIONAL_SIZE" ]; then
      packages_additional="$(echo "$CADI_PACKAGES_ADDITIONAL" | tr ',' ' ')"
      _packages_additional_size=$CADI_PACKAGES_ADDITIONAL_SIZE
    else
      error_message \
        "Additional packages for $class_type_description defined but no installed size defined for them!"
    fi
  fi
  : "${_packages_additional_size:=0}"

  if [ -z "$image_barebones" ]; then
    # Agent packages such as Hyper-V / QEMU Agent / Virtualbox Guest / VMware
    # Agent which are not installed for barebones machines
    if [ -n "$CADI_HYPERVISOR_AGENT_PACKAGES" ] && \
       [ -z "$image_hypervisor_agent_disable" ]; then
      if [ -n "$CADI_HYPERVISOR_AGENT_PACKAGES_SIZE" ]; then
        hypervisor_agent_packages="$(echo "$CADI_HYPERVISOR_AGENT_PACKAGES" | tr ',' ' ')"
        _hypervisor_agent_packages_size=$CADI_HYPERVISOR_AGENT_PACKAGES_SIZE
      else
        error_message \
          "Agent packages defined but no installed size defined for them!"
      fi
    fi

    # CLI packages specific to the cloud/virtual/physical machine type
    # which are not installed for barebones machines
    if [ -n "$CADI_CLOUD_CLI_PACKAGES" ]; then
      if [ -n "$CADI_CLOUD_CLI_PACKAGES_NOTPRESENTIN" ] && \
         ! is_in_comma_list "$CADI_CLOUD_CLI_PACKAGES_NOTPRESENTIN" \
                            "$image_alpine_release"; then
        # Package is not available for this release of Alpine
        :
      elif [ -z "$CADI_CLOUD_CLI_PACKAGES_SIZE" ]; then
        error_message \
          "CLI packages for $class_type_description defined but no installed size defined for them!"
      else
        cloud_cli_packages="$(echo "$CADI_CLOUD_CLI_PACKAGES" | tr ',' ' ')"
        _cloud_cli_packages_size=$CADI_CLOUD_CLI_PACKAGES_SIZE
      fi
    fi

    # Extra packages specific to the cloud/virtual/physical machine type
    # which are not installed for barebones machines
    if [ -n "$CADI_PACKAGES_EXTRA" ]; then
      if [ -n "$CADI_PACKAGES_EXTRA_SIZE" ]; then
        packages_extra="$(echo "$CADI_PACKAGES_EXTRA" | tr ',' ' ')"
        _packages_extra_size=$CADI_PACKAGES_EXTRA_SIZE
      else
        error_message \
          "Extra packages for $class_type_description defined but no installed size defined for them!"
      fi
    fi

    # Optional packages specific to the cloud/virtual/physical machine type
    # which are not installed for barebones machines
    if [ -n "$CADI_PACKAGES_OPTIONAL" ]; then
      if [ -n "$CADI_PACKAGES_OPTIONAL_SIZE" ]; then
        packages_optional="$(echo "$CADI_PACKAGES_OPTIONAL" | tr ',' ' ')"
        _packages_optional_size=$CADI_PACKAGES_OPTIONAL_SIZE
      else
        error_message \
          "Optional packages for $class_type_description defined but no installed size defined for them!"
      fi
    fi
  fi
  : "${_hypervisor_agent_packages_size:=0}"
  : "${_cloud_cli_packages_size:=0}"
  : "${_packages_extra_size:=0}"
  : "${_packages_optional_size:=0}"

  # ESP partition sizing
  #----------------------
  case $image_boot_type in
    secure-uefi | uefi )
      case $image_bootloader in
        efistub | uki )
          case $image_kernel_type in
            edge )
              general_uefi_part_size=${esp_part_size:-$CADI_DEFAULT_EDGE_EFISTUB_ESP_PART_SIZE} ;;
            * )
              general_uefi_part_size=${esp_part_size:-$CADI_DEFAULT_EFISTUB_ESP_PART_SIZE} ;;
          esac
          ;;
        * )
          case $image_esp_type in
            fat32 )
              # FAT32 is handled the same way for Cloud/PhysicalVirtual
              # in the cli-functions code
              : ;;
            * )
              general_uefi_part_size=${esp_part_size:-$CADI_DEFAULT_ESP_PART_SIZE} ;;
          esac
          ;;
      esac
      if [ -n "$debug_sizing_enabled" ]; then
        printf \
          '[partition_sizing_related] size for ESP partition is: %s MiB\n' \
          "$general_uefi_part_size" >> "$sizing_debug"
      fi
      ;;
  esac

  # Bootfs sizing
  #---------------

  # This accounts for System.map, config, kernel, DTB files,
  # initramfs, and microcode in /boot
  : "${CADI_MICROCODE_SIZE:=0}"
  # shellcheck disable=SC1102,SC2018,SC2019,SC2046
  eval \
    _base_bootfs_size="$((CADI_BOOTFS_KERNEL_$(get_kernel_type | tr 'a-z' 'A-Z')_FILES_SIZE + CADI_INITRAMFS_SIZE + CADI_MICROCODE_SIZE))"

  # Allow space for kernel package updates
  eval \
    _bootfs_extra_space=$((CADI_BOOTFS_KERNEL_$(get_kernel_type | tr 'a-z' 'A-Z')_FILES_SIZE))

  if [ -n "$debug_sizing_enabled" ]; then
    {
      printf '[partition_sizing_related] base size of bootfs is: %s MiB\n' \
        "$_base_bootfs_size"
      printf \
        '[partition_sizing_related]   based on:  kernel=%s, initramfs=%s, microcode=%s\n' \
        "$(eval echo '$'CADI_BOOTFS_KERNEL_$(get_kernel_type | tr 'a-z' 'A-Z')_FILES_SIZE)" \
        "$CADI_INITRAMFS_SIZE" \
        "$CADI_MICROCODE_SIZE"
      if [ "$image_os_partitioning_type" != "unpartitioned" ]; then
        printf \
          '[partition_sizing_related] size of bootloader files in bootfs is: %s MiB\n' \
          "$_bootloader_files_size"
      fi
      printf \
        '[partition_sizing_related] extra free space for bootfs is: %s MiB\n' \
        "$_bootfs_extra_space"
    } >> "$sizing_debug"
  fi

  # Add on size of bootloader-specific installed files to bootfs size
  general_bootfs_size=$((_base_bootfs_size + _bootfs_extra_space))
  if [ "$image_os_partitioning_type" != "unpartitioned" ]; then
    general_bootfs_size=$((general_bootfs_size + _bootloader_files_size))
  fi

  if [ -n "$debug_sizing_enabled" ]; then
    printf '[partition_sizing_related] total size for bootfs is: %s MiB\n' \
      "$general_bootfs_size" >> "$sizing_debug"
  fi

  # Rootfs sizing
  #---------------

  _base_rootfs_size=$CADI_ROOTFS_SIZE
  case $image_kernel_type in
    edge | normal )
      # shellcheck disable=SC2018,SC2019
      eval \
        _kernel_rootfs_files_size='$'CADI_ROOTFS_KERNEL_"$(get_kernel_type | tr 'a-z' 'A-Z')"_FILES_SIZE ;;
  esac

  : "${general_rootfs_size:=$_base_rootfs_size}"

  case $image_cloud_software in
    cloud-init )
      _config_software_packages_size=$CADI_CLOUDINIT_PACKAGES_SIZE ;;
    tiny-cloud )
      _config_software_packages_size=$CADI_TINYCLOUD_PACKAGES_SIZE ;;
  esac
  : "${_config_software_packages_size:=0}"

  if [ -n "$debug_sizing_enabled" ]; then
    {
      printf '[partition_sizing_related] base size for rootfs is: %s MiB\n' \
        "$general_rootfs_size"
      printf \
        '[partition_sizing_related] size of kernel package files is: %s MiB\n' \
        "$_kernel_rootfs_files_size"
      printf \
        '[partition_sizing_related] size of bootloader packages is: %s MiB\n' \
        "$_bootloader_packages_size"
      printf \
        '[partition_sizing_related] size of configuration software packages is: %s MiB\n' \
        "$_config_software_packages_size"
      case $image_class in
        cloud )
          printf \
            '[partition_sizing_related] size of Cloud Provider CLI packages is: %s MiB\n' \
            "$_cloud_cli_packages_size" ;;
        virtual )
          printf \
            '[partition_sizing_related] size of VM Hypervisor agent packages is: %s MiB\n' \
            "$_hypervisor_agent_packages_size" ;;
      esac
      printf \
        '[partition_sizing_related] size of additional packages is: %s MiB\n' \
        "$_packages_additional_size"
      printf '[partition_sizing_related] size of extra packages is: %s MiB\n' \
        "$_packages_extra_size"
      printf \
        '[partition_sizing_related] size of optional packages is: %s MiB\n' \
        "$_packages_optional_size"
    } >> "$sizing_debug"
  fi

  # Add on size of kernel, bootloader-specific, cloud config software,
  # hypervisor-specific packages, Cloud CLI package, additional packages,
  # optional packages & extra packages to rootfs size
  general_rootfs_size=$((general_rootfs_size + _kernel_rootfs_files_size + _bootloader_packages_size + _config_software_packages_size + _packages_additional_size + _packages_extra_size + _packages_optional_size))
  case $image_class in
    cloud )
      general_rootfs_size=$((general_rootfs_size + _cloud_cli_packages_size)) ;;
    virtual )
      general_rootfs_size=$((general_rootfs_size + _hypervisor_agent_packages_size)) ;;
  esac

  if [ -n "$debug_sizing_enabled" ]; then
    printf \
      '[partition_sizing_related] size of user-specified additional packages is: %s MiB\n' \
      "$image_additional_packages_size" >> "$sizing_debug"
  fi

  # Add on size of user-specified additional packages to rootfs size
  general_rootfs_size=$((general_rootfs_size + image_additional_packages_size ))

  if [ -n "$debug_sizing_enabled" ]; then
    printf '[partition_sizing_related] total size for rootfs is: %s MiB\n' \
      "$general_rootfs_size" >> "$sizing_debug"
  fi
}


#
# Settings shared between Cloud/Physical/Virtual machines.
#
default_settings() {
  local _base_bootfs_size _bootfs_extra_space _base_rootfs_size
  local _bootloader_files_size _bootloader_packages_size
  local _config_software_packages_size
  local _kernel_rootfs_files_size _sbom_packages_size

  do_generic_validation_checks

  source_additional_definitions_files

  do_specific_validation_checks

  # APK static version
  if [ -z "$apk_static_checksum" ]; then
    # shellcheck disable=SC2018,SC2019
    eval \
      apk_static_checksum='$'"CADI_APK_STATIC_$(echo "$image_arch" | tr 'a-z' 'A-Z')_CHECKSUM"
  fi
  : "${apk_static_version:=$CADI_APK_STATIC_VERSION}"
  : "${apk_static_url:=$CADI_APK_STATIC_URL}"

  # Set disk image filename
  filename_for_image="${filename_for_image:-./alpine-$image_alpine_release-$image_arch-$image_class-$image_class_subtype.img}"


  # If graphics is not specifically enabled then disable it
  : "${image_enable_graphics:=false}"


  # NTP use
  if [ -z "$image_ntp_use" ]; then
    case $image_ntp_use in
      none )
        if [ -n "$CADI_SUPPORTED_NTP_METHODS" ] && \
           is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "none"; then
          image_ntp_daemon="none"
          unset image_ntp_pools
          unset image_ntp_servers
        else
          error_message "Not using a NTP is not supported!"
        fi
        ;;

      ptp )
        if [ -n "$CADI_SUPPORTED_NTP_METHODS" ] && \
           is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "ptp"; then
          image_ntp_daemon="chrony"
          unset image_ntp_pools
          unset image_ntp_servers
        else
          error_message "PTP is not supported!"
        fi
        ;;
    esac
  fi

  # Cron daemon, DHCP client, NTP daemon, SSH server, Syslog server,
  # user/group management software, UTMP.
  if [ -n "$image_barebones" ]; then
    # Use barebones options for various software
    : "${image_cron_daemon:=busybox}"
    if is_in_comma_list "$CADI_SUPPORTED_DHCP_CLIENTS" "udhcpc"; then
      : "${image_dhcp_client:=udhcpc}"
    fi
    : "${image_login_package:=busybox}"
    : "${image_ntp_daemon:=busybox}"
    : "${image_ssh_server:=dropbear}"
    : "${image_syslog_server:=busybox}"
    : "${image_user_management:=busybox}"

    image_device_management_type=mdev

    case $image_arch in
      x86 | x86_64 )
        case $image_boot_type in
          bios | none | rpi )
            : ;;
          * )
            # Override setting as UEFI requires graphics
            image_enable_graphics=true
            : "${image_graphics_driver:=$CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER}"
            ;;
        esac
        ;;
    esac
  else
    if [ -n "$CADI_HYPERVISOR_AGENT_PACKAGES" ]; then
      case $image_class in
        virtual )
          if [ -n "$CADI_DEFAULT_NTP_METHOD" ] && \
             [ "$CADI_DEFAULT_NTP_METHOD" = "none" ]
             is_in_comma_list "$CADI_SUPPORTED_NTP_METHODS" "none" && \
             [ -z "$image_ntp_use" ]; then
            case $image_class_subtype in
              virtualbox )
                # For these hypervisors the agent manages timesync
                image_ntp_daemon="none"
                ;;
            esac
          fi
          ;;
      esac
    fi

    : ${image_cron_daemon:=$CADI_DEFAULT_CRON_DAEMON}
    : ${image_login_package:=$CADI_DEFAULT_LOGIN_PACKAGE}
    if [ -n "$image_ntp_use" ] && \
       [ "$image_ntp_use" = "none" ]; then
      image_ntp_daemon="none"
    else
      : ${image_ntp_daemon:=$CADI_GLOBAL_DEFAULT_NTP_DAEMON}
    fi
    : ${image_ssh_server:=$CADI_DEFAULT_SSH_SERVER}
    : ${image_syslog_server:=$CADI_DEFAULT_SYSLOG_SERVER}
    : ${image_user_management:=$CADI_DEFAULT_USER_MANAGEMENT_PACKAGE}
  fi

  : "${image_enable_utmp:=false}"

  # ACPI poweroff
  #---------------
  if [ -z "$image_acpi_power_method" ]; then
    if [ -n "$CADI_DEFAULT_ACPI_BUTTON" ] && \
       is_in_comma_list "$CADI_SUPPORTED_ACPI_BUTTONS" \
                        "$CADI_DEFAULT_ACPI_BUTTON"; then
      image_acpi_power_method="$CADI_DEFAULT_ACPI_BUTTON"
    elif [ -n "$CADI_SUPPORTED_ACPI_BUTTONS" ]; then
      image_acpi_power_method="$(first_entry_in_comma_list "$CADI_SUPPORTED_ACPI_BUTTONS")"
    else
      image_acpi_power_method="button"
    fi
  fi

  # Timezone
  #----------
  case $image_cloud_software in
    cloud-init | none )
      : "${image_timezone:=$CADI_GLOBAL_DEFAULT_TIMEZONE}" ;;
  esac

  default_boot_related_settings
  default_console_related_settings

  case $image_ntp_daemon in
    none )
      : ;;
    * )
      default_ntp_related_settings ;;
  esac

  # Calculate additional disk space required for optional packages
  image_sbom=${image_sbom:-false}
  if [ "$image_sbom" = "true" ]; then
    _sbom_packages_size="${CADI_SBOM_PACKAGE_SIZE:-0}"
    if [ "$_sbom_packages_size" = "0" ]; then
      error_message "SBOM package is not available!"
    fi
    image_additional_packages_size=$((image_additional_packages_size + _sbom_packages_size))
  fi

  partition_sizing_related
}


#
# Define list of packages in addition to base Alpine.
#
define_additional_packages() {
  local _initial_pkgs

  case $image_auth_control in
    doas )
      _initial_pkgs="doas" ;;
    sudo )
      _initial_pkgs="sudo" ;;
    both )
      _initial_pkgs="doas sudo" ;;
  esac

  # Busybox's cpio sometimes has problems with mkinitfs
  _initial_pkgs="$_initial_pkgs cpio"

  if [ -n "$image_barebones" ]; then
    # Barebone packages
    :
  else
    _initial_pkgs="$_initial_pkgs ca-certificates htop kbd-bkeymaps logrotate"
    _initial_pkgs="$_initial_pkgs musl-locales sshguard"
    if [ -n "$debug_enabled" ]; then
      _initial_pkgs="$_initial_pkgs hwinfo lshw"
    elif [ "$image_class" = "physical" ]; then
      _initial_pkgs="$_initial_pkgs hwinfo"
    fi

    # Acct
    case $image_alpine_release in
      v3.13 | v3.14 | v3.15 )
        # These releases do not have suitable acct package
        : ;;
      * )
        _initial_pkgs="$_initial_pkgs acct" ;;
    esac

    # busybox/shadow/util-linux for login
    case $image_login_package in
      busybox )
        : ;;
      shadow )
        _initial_pkgs="$_initial_pkgs shadow-login" ;;
      util-linux )
        _initial_pkgs="$_initial_pkgs util-linux-login" ;;
    esac

    # PAM support
    if [ -n "$image_enable_pam" ]; then
      _initial_pkgs="$_initial_pkgs linux-pam"
    fi

    # busybox or shadow for user/group management
    case $image_user_management in
      busybox )
        : ;;
      shadow )
        _initial_pkgs="$_initial_pkgs shadow" ;;
    esac

    # UTMP
    if [ "$image_enable_utmp" = "true" ]; then
      _initial_pkgs="$_initial_pkgs procps utmps"
    fi
  fi

  case $image_encryption_type in
    both )
      _initial_pkgs="$_initial_pkgs cryptsetup fscrypt"
      if [ -n "$image_experimental" ] && \
         [ -n "$luks_remote_unlock_enabled" ]; then
          _initial_pkgs="$_initial_pkgs dropbear-convert dropbear-unlockdisk"
      fi
      ;;
    fscrypt )
      _initial_pkgs="$_initial_pkgs fscrypt" ;;
    luks )
      _initial_pkgs="$_initial_pkgs cryptsetup"
      if [ -n "$image_experimental" ] && \
         [ -n "$luks_remote_unlock_enabled" ]; then
          _initial_pkgs="$_initial_pkgs dropbear-convert dropbear-unlockdisk"
      fi
      ;;
  esac

  if [ -n "$image_lvm_rootfs" ]; then
    _initial_pkgs="$_initial_pkgs lvm2"
  fi

  if [ "$image_encryption_type" = "both" ] || \
     [ "$image_encryption_type" = "luks" ] || \
     [ -n "$image_lvm_rootfs" ]; then
    _initial_pkgs="$_initial_pkgs device-mapper"
  fi

  if [ -z "$image_barebones" ]; then
    case $image_firewall in
      iptables )
        _initial_pkgs="$_initial_pkgs iptables"
        if [ -z "$image_disable_ipv6" ]; then
          case $image_alpine_release in
            v3.13 | v3.14 | v3.15 | v3.16 | v3.17 | v3.18 )
              _initial_pkgs="$_initial_pkgs ip6tables" ;;
            * )
              # There is no ip6tables sub-package anymore
              : ;;
          esac
        fi
        ;;
      nftables )
        _initial_pkgs="$_initial_pkgs nftables" ;;
    esac
  fi

  case $image_fs_type in
    btrfs )
      _initial_pkgs="$_initial_pkgs btrfs-progs btrfs-progs-extra" ;;
    ext4 )
      if [ -n "$image_barebones" ]; then
        _initial_pkgs="$_initial_pkgs e2fsprogs"
      else
        _initial_pkgs="$_initial_pkgs e2fsprogs-extra"
      fi
      ;;
    f2fs )
      _initial_pkgs="$_initial_pkgs f2fs-tools" ;;
    xfs )
      _initial_pkgs="$_initial_pkgs xfsprogs xfsprogs-extra" ;;
  esac

  # Cron
  case $image_cron_daemon in
    busybox )
      : ;;
  esac

  # DHCP client
  case $image_dhcp_client in
    dhclient )
      _initial_pkgs="$_initial_pkgs dhclient" ;;
    dhcpcd )
      _initial_pkgs="$_initial_pkgs dhcpcd" ;;
    generic )
      _initial_pkgs="$_initial_pkgs dhclient dhcpcd" ;;
    udhcpc )
      : ;;
  esac

  # NTP
  case $image_ntp_daemon in
    busybox | none )
      : ;;
    chrony )
      _initial_pkgs="$_initial_pkgs chrony" ;;
  esac

  # SSH
  case $image_ssh_server in
    dropbear )
      _initial_pkgs="$_initial_pkgs dropbear"
      if [ -z "$image_barebones" ]; then
        _initial_pkgs="$_initial_pkgs openssh-sftp-server"
      fi
      ;;
    openssh )
      if [ -n "$image_enable_pam" ]; then
        _initial_pkgs="$_initial_pkgs openssh-server-pam"
      else
        _initial_pkgs="$_initial_pkgs openssh-server"
      fi
      ;;
    tinyssh )
      _initial_pkgs="$_initial_pkgs tinyssh"
      if [ -z "$image_barebones" ]; then
        _initial_pkgs="$_initial_pkgs openssh-sftp-server"
      fi
      ;;
  esac

  # Syslog
  case $image_syslog_server in
    busybox )
      : ;;
    rsyslog )
      _initial_pkgs="$_initial_pkgs rsyslog" ;;
  esac

  if [ "$image_sbom" = "true" ]; then
    _initial_pkgs="${_initial_pkgs} syft"
  fi

  echo "$_initial_pkgs"
}


#
# Define list of packages related to machine characteristics.
#
define_machine_specific_packages() {
  local _machine_specific_packages

  # Packages always installed
  case $image_class in
    cloud )
      _machine_specific_packages="$(define_cloud_machine_packages)" ;;
    physical )
      _machine_specific_packages="$(define_physical_machine_packages)" ;;
    virtual )
      _machine_specific_packages="$(define_virtual_machine_packages)" ;;
  esac

  echo "$_machine_specific_packages"
}


#
# Define list of os-related configuration software packages.
#
define_os_config_software_packages() {
  local _os_config_software_pkgs

  # cloud-init / tiny-cloud / neither related packages
  case $image_cloud_software in
    cloud-init )
      _os_config_software_pkgs="$(define_cloud_init_packages)" ;;
    none )
      _os_config_software_pkgs="$(define_non_cloud_init_machine_packages)" ;;
    tiny-cloud )
      _os_config_software_pkgs="$(define_tiny_cloud_packages)" ;;
  esac

  # Decide whether to use mdev, mdevd, or eudev
  case $image_cloud_software in
    cloud-init | none )
      case $image_device_management_type in
        mdev )
          _os_config_software_pkgs="$_os_config_software_pkgs busybox" ;;
        mdevd )
          _os_config_software_pkgs="$_os_config_software_pkgs mdevd" ;;
        udev )
          _os_config_software_pkgs="$_os_config_software_pkgs eudev" ;;
      esac
      ;;
    tiny-cloud )
      # Tiny-Cloud defines its own mdev/mdevd/eudev dependancies accordingly
      : ;;
  esac

  echo "$_os_config_software_pkgs"
}


#
# Returns the full path to the initramfs file taking into account
# the initramfs generator tool in use.
#
get_initramfs_filename() {
  local _initramfs_filename _initramfs_prefix

  case $image_initramfs_tool in
    booster )
      _initramfs_prefix="booster" ;;
    dracut )
      _initramfs_prefix="initramfs" ;;
    mkinitfs )
      _initramfs_prefix="initramfs" ;;
  esac

  _initramfs_filename="${_initramfs_prefix}-$(get_kernel_type)"

  echo "$_initramfs_filename"
}


#
# Install base Alpine system.
#
install_alpine_base() {
  local _base_packages _bootloader_packages

  _base_packages="alpine-base"
  case $image_boot_type in
    secure-uefi | uefi )
      _base_packages="$_base_packages efivar"
      # Needed for fsck.vfat (for ESP partition)
      _base_packages="$_base_packages dosfstools"
  esac
  case $image_boot_type in
    secure-uefi )
      _base_packages="$_base_packages efi-mkkeys mokutil secureboot-hook" ;;
  esac

  # Add the appropriate package for ifup / ifdown utilities
  case $image_ifupdown_package in
    busybox )
      _base_packages="$_base_packages busybox-ifupdown" ;;
    ifupdown )
      _base_packages="$_base_packages ifupdown" ;;
    ifupdown-ng )
      _base_packages="$_base_packages ifupdown-ng" ;;
    * )
      _base_packages="$_base_packages ifupdown-ng" ;;
  esac

  # Add the appropriate package for managing initramfs
  case $image_initramfs_tool in
    booster )
      _base_packages="$_base_packages booster" ;;
    dracut )
      _base_packages="$_base_packages dracut" ;;
    mkinitfs )
      _base_packages="$_base_packages mkinitfs" ;;
  esac

  # Define bootloader-related packages
  case $image_bootloader in
    grub )
      _bootloader_packages="grub"
      case $image_boot_type in
        secure-uefi | uefi )
          _bootloader_packages="$_bootloader_packages grub-efi" ;;
        * )
          _bootloader_packages="$_bootloader_packages grub-bios" ;;
      esac
      ;;

    limine )
      case $image_boot_type in
        secure-uefi | uefi )
          case $image_arch in
            aarch64 )
              _bootloader_packages="limine-aarch64"
              case $image_alpine_release in
                3.17 )
                  : ;;
                * )
                  _bootloader_packages="$_bootloader_packages limine-efi-updater"
                  ;;
              esac
              ;;
            x86_64 )
              case $image_alpine_release in
                3.17 )
                  _bootloader_packages="limine-64" ;;
                * )
                  _bootloader_packages="limine-x86_64 limine-efi-updater" ;;
              esac
              ;;
          esac
          if [ "$image_boot_type" = "secure-uefi" ]; then
            _bootloader_packages="$_bootloader_packages limine-enroll-config"
          fi
          ;;
        * )
          case $image_alpine_release in
            3.17 | 3.18 )
              _bootloader_packages="limine-deploy limine-sys" ;;
            * )
              _bootloader_packages="limine-sys" ;;
          esac
          ;;
      esac
      ;;

    rpi )
      _bootloader_packages="dosfstools raspberrypi-bootloader-cutdown"
      case $image_alpine_release in
        v3.13 | v3.14 | v3.15 )
          # Prior to 3.16/Edge raspberrypi-common does not exist and so
          # raspberrypi-bootloader must also be installed.
          _bootloader_packages="$_bootloader_packages raspberrypi-bootloader" ;;
      esac
      ;;

    syslinux )
      _bootloader_packages="syslinux" ;;

    efistub | uki )
      _bootloader_packages="secureboot-hook"
      case $image_efi_bootstub in
        gummiboot )
          _bootloader_packages="$_bootloader_packages gummiboot" ;;
        stubby )
          _bootloader_packages="$_bootloader_packages stubbyboot-efistub" ;;
      esac
      ;;

    * )
      _bootloader_packages="none" ;;
  esac
  if [ "$_bootloader_packages" != "none" ]; then
    _base_packages="$_base_packages $_bootloader_packages"
  fi

  cat <<-EOF >> "$run_script"
	
	write_log "Bootloader packages to be installed are: $_bootloader_packages"
	EOF

  cat <<-EOF >> "$run_script"
	
	write_log \\
	  "Install base Alpine & bootloader packages for ${image_arch} arch inside chroot"
	{
	EOF

  case $image_script_host_os in
    all )
      cat <<-EOF >> "$run_script"
	  _host_os=\$(detect_host_os)
	  case \$_host_os in
	    alpine )
	      _apk_binary="apk" ;;
	    * )
	      _apk_binary="\$TMPDIR/apk.static" ;;
	  esac
	EOF
      ;;

    alpine )
      cat <<-EOF >> "$run_script"
	  _apk_binary="apk"
	EOF
      ;;

    * )
      cat <<-EOF >> "$run_script"
	  _apk_binary="\$TMPDIR/apk.static"
	EOF
      ;;
  esac

  cat <<-EOF >> "$run_script"
	
	  # shellcheck disable=SC2086
	  \$_apk_binary --arch "${image_arch}" --initdb --allow-untrusted \\
	    --root \$chroot_dir --update-cache \\
	    add ${_base_packages} \\
	    >> "\$logfile" 2>&1
	  _rc=\$?
	  if [ \$_rc -ne 0 ]; then
	    write_log "Failure while installing base Alpine, error code: \$_rc"
	    exit 1
	  fi
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  write_debug_log "Disk space usage for base Alpine:"
	  df -k $chroot_dir >> "$logfile"
	EOF
  fi

  case $image_script_host_os in
    alpine )
      : ;;

    * )
      cat <<-EOF >> "$run_script"
	
	  # Tidy-up after apk.static run
	  rm -f \$TMPDIR/apk.static
	  if [ "\$temp_ca_dir_created" = "true" ]; then
	    echo "deleting the temporary CA directory"
	    rm -Rf /etc/apk
	  elif [ "\$temp_ca_file_created" = "true" ]; then
	    echo "deleting the temporary CA file"
	    rm -f /etc/apk/ca.pem
	  fi
	EOF
      ;;
  esac

  cat <<-EOF >> "$run_script"
	}
	EOF
}


#
# Insert function get_kernel_package_version into created script.
#
insert_chroot_function_find_module_full_path() {
  cat <<-'EOF' >> "$run_script"
	
	find_module_full_path() {
	  local _module="\$1"
	
	  local _module_path
	
	  _module_path="\$(find /lib/modules/ -name "\$_module.ko*" | \
	    sed -e 's/^.*kernel/kernel/' -e 's/\.ko.*$//')"
	
	  if [ -z "\$_module_path" ]; then
	    _module="\$(echo "\$_module" | sed -e 's/-/_/g')"
	    _module_path="\$(find /lib/modules/ -name "\$_module.ko*" | \
	      sed -e 's/^.*kernel/kernel/' -e 's/\.ko.*$//')"
	  fi
	
	  if [ -n "\$_module_path" ]; then
	    _module_path="\${_module_path}.ko*"
	  fi
	
	  echo "\$_module_path"
	}
	EOF
}



#
# Insert function get_kernel_package_version into created script.
#
insert_chroot_function_get_kernel_package_version() {
  local _kernel_type

  _kernel_type=$(get_kernel_type)

  cat <<-EOF >> "$run_script"
	
	get_kernel_package_version() {
	  apk info linux-$_kernel_type | head -n 1 | sed -e "s/^linux-$_kernel_type-//" \\
	    -e 's/ .*//'
	}
	EOF
}


#
# Insert functions into created script.
#
insert_chroot_functions() {
  cat <<-'EOF' >> "$run_script"
	
	############################################################################
	##		Chroot Functions
	############################################################################
	EOF

  insert_chroot_function_add_fstab_entry
  case $image_encryption_type in
    both | luks )
      insert_chroot_function_define_cmdline_for_luks_encryption ;;
  esac
  insert_chroot_function_find_module_full_path
  insert_chroot_function_get_kernel_package_version
  insert_chroot_function_get_kernel_version
  insert_chroot_function_write_debug_log
  insert_chroot_function_write_log
}


#
# Install relevant firmware packages.
#
install_firmware() {
  local _firmware_pkgs

  if [ "$image_class" = "physical" ]; then
    cat <<-EOF >> "$run_script"
	write_log "Selecting firmware packages to install"
	{
	EOF

    case $image_physical_type in
      rpi* )
        # No firmware used for Raspberry Pis
        : ;;
      *)
        _firmware_pkgs="$(firmware_list_for_physical)" ;;
    esac

    if [ -n "$_firmware_pkgs" ]; then
      cat <<-EOF >> "$run_script"
	  write_log "Installing firmware" 2
	  apk add $_firmware_pkgs >> /chroot.log 2>&1
	EOF
    else
      cat <<-EOF >> "$run_script"
	  write_log "No additional firmware to install" 2
	EOF
    fi

    cat <<-EOF >> "$run_script"
	}
	EOF
  fi
}


#
# Install relevant kernel package.
#
install_kernel() {
  local _firmware_pkg _kernel_pkg _kernel_config_file

  _firmware_pkg="linux-firmware-none"

  _kernel_pkg="linux-$(get_kernel_type)"
  _kernel_config_file="config-$(get_kernel_type)"

  cat <<-EOF >> "$run_script"
	
	write_log "Installing kernel $_kernel_pkg"
	{
	  apk add $_kernel_pkg ${_firmware_pkg:-} >> /chroot.log 2>&1
	EOF

  cat <<-'EOF' >> "$run_script"
	
	  _kernel_version=\$(get_kernel_version)
	  _kernel_package_version=\$(get_kernel_package_version)
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-EOF >> "$run_script"
	
	  # Debug
	  write_debug_log "Disk space usage after kernel installed:"
	  df -k >> /chroot.log
	  write_debug_log "Kernel is: \\\$_kernel_version"
	  write_debug_log "Kernel package version is: \\\$_kernel_package_version"
	  cp /boot/$_kernel_config_file \\
	    /kernel-config_"\\\${_kernel_package_version}"_${image_arch}_${_kernel_config_file}
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Install CPU microcode packages.
#
install_microcode() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Selecting microcode packages to install"
	{
	EOF

  # only Physical machines use microcode
  install_microcode_for_physical

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Prepare the main section of the run script.
#
prep_runscript_main_section() {
  cat <<-EOF >> "$run_script"
	
	#############################################################################
	##   Main Section
	#############################################################################
	
	chroot_dir="${chroot_directory}"
	images_dir="${images_directory}"
	TMPDIR="/var/tmp"
	
	image_filename="${filename_for_image}"
	logfile="${logs_output_file}"
	
	EOF

  if [ -n "$image_console_user_password" ]; then
    cat <<-EOF >> "$run_script"
	console_user_password="${image_console_user_password}"
	EOF
  fi

  if [ -n "$image_default_user_password" ]; then
    cat <<-EOF >> "$run_script"
	default_user_password="${image_default_user_password}"
	EOF
  fi

  case $image_encryption_type in
    both | luks )
      cat <<-EOF >> "$run_script"
	luks_passphrase="${image_luks_passphrase}"
	EOF
      ;;
  esac

  if [ -n "$image_bootloader_password" ]; then
    cat <<-EOF >> "$run_script"
	
	bootloader_username="${image_bootloader_username}"
	# shellcheck disable=SC2169
	bootloader_hashed_password="\$(printf "%s\n%s" $image_bootloader_password $image_bootloader_password | LC_ALL=C grub-mkpasswd-pbkdf2 | awk '/hash of / {print \$NF}')"
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	
	# Create empty logfile
	:> $logfile
	
	EOF

  if [ -n "$use_ramdisk" ]; then
    cat <<-EOF >> "$run_script"
	ramdisk_dir="${ramdisk_directory}"
	image_full_filename="\$ramdisk_dir/\$image_filename"
	EOF
  else
    cat <<-'EOF' >> "$run_script"
	image_full_filename="$images_dir/$image_filename"
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	working_dir=""
	
	
	check_for_required_packages
	EOF

  if [ "$image_script_host_arch" = "all" ] || \
     [ "$image_script_host_arch" != "$image_arch" ]; then
    cat <<-'EOF' >> "$run_script"
	check_binfmt_packages
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	
	# Ensure if any errors occur that various cleanup operations happen
	trap error_cleanup EXIT
	
	mkdir -p $images_dir
	EOF
}


#
# Create Dropbear authorized_keys file.
#
setup_dropbear_authorized_keys() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Setup Dropbear authorized_keys file"
	{
	  echo $ssh_public_key \\
	    > /etc/dropbear/authorized_keys
	  chown root:root /etc/dropbear/authorized_keys
	  chmod 600 /etc/dropbear/authorized_keys
	}
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	# Debug
	write_debug_log "Dropbear authorized_keys contents:" 2
	cat /etc/dropbear/authorized_keys >> "$logfile"
	EOF
  fi
}


#
# Source additional definitions files.
#
source_additional_definitions_files() {
  local _source_script

  # source e.g. cloud/defines, physical/defines, virtual/defines
  _source_script="$script_dir/definitions/$image_class/defines"
  if [ ! -f "$_source_script" ]; then
    error_message \
      "Unable to source settings for $image_class (definitions/$image_class/defines)!"
  else
    . "$_source_script"
  fi

  # source e.g. cloud/aws/defines, physical/pc/defines, virtual/qemu/defines
  _source_script="$script_dir/definitions/$image_class/$image_class_subtype/defines"
  if [ ! -f "$_source_script" ]; then
    error_message \
      "Unable to source settings for $class_type_description (definitions/$image_class/$image_class_subtype/defines)!"
  else
    . "$_source_script"
  fi

  if [ -z "$image_arch" ]; then
    if [ -n "$CADI_DEFAULT_ARCH" ] && \
       is_in_comma_list "$CADI_SUPPORTED_ARCHS" "$CADI_DEFAULT_ARCH"; then
      image_arch="$CADI_DEFAULT_ARCH"
    elif [ -n "$CADI_SUPPORTED_ARCHS" ]; then
      image_arch="$(first_entry_in_comma_list "$CADI_SUPPORTED_ARCHS")"
    else
      error_message "No archs defined for $class_type_description!"
    fi
  fi

  # source e.g. packages/aarch64-packages-defines,
  # packages/armv7-packages-defines, packages/x86-packages-defines,
  # packages/x86_64-packages-defines
  _source_script="$script_dir/lib/packages/$image_arch-packages-defines"
  if [ ! -f "$_source_script" ]; then
    error_message "Unable to source settings from $_source_script!"
  else
    . "$_source_script"
  fi

  # source e.g. cloud/x86_64-defines, physical/x86_64-defines,
  # virtual/x86_64-defines
  _source_script="$script_dir/definitions/$image_class/$image_arch-defines"
  if [ ! -f "$_source_script" ]; then
    error_message \
      "Unable to source settings for $image_class using arch $image_arch ($_source_script)!"
  else
    . "$_source_script"
  fi

  # source e.g. cloud/x86_64-normal-defines, physical/x86_64-normal-defines,
  # virtual/x86_64-normal-defines
  _source_script="$script_dir/definitions/$image_class/$image_arch-$(if [ -n "$image_barebones" ]; then echo "barebones"; else echo "normal"; fi)-defines"
  if [ ! -f "$_source_script" ]; then
    error_message \
      "Unable to source settings for $image_class using arch $image_arch ($_source_script)!"
  else
    . "$_source_script"
  fi

  if is_in_comma_list "$CADI_SUPPORTED_ARCHS" "$image_arch"; then
    # source e.g. cloud/aws/x86_64-defines, physical/pc/x86_64-defines,
    # virtual/qemu/x86_64-defines
    _source_script="$script_dir/definitions/$image_class/$image_class_subtype/$image_arch-defines"
    if [ ! -f "$_source_script" ]; then
      error_message \
        "Unable to source settings for $class_type_description for arch $image_arch ($_source_script)!"
    else
      . "$_source_script"
    fi
  else
    error_message \
      "Arch $image_arch is not supported for $class_type_description"
  fi
}
