#!/bin/sh -u
# shellcheck disable=SC2039

#############################################################################
##
##  cli-functions
##
##  Copyright 2021-2022 Dermot Bradley <dermot_bradley@yahoo.com>
##
##  Licensed via GPL version 2.0
##
#############################################################################


#
# Parse options given on the command line
#
parse_cli_options() {
  local _cli

  if ! _cli=$(getopt -s sh \
    -o h \
    -l \
add-directory-contents:,\
add-packages:,\
apk-static-url:,\
apk-static-version:,\
arch:,\
auth-control:,\
boot-by-label,\
bootchart,\
bootloader:,\
bootloader-password:,\
boottype:,\
chroot-directory:,\
cloud:,\
cloud-seed-url:,\
console-type:,\
cpu-vendor:,\
create-boot-partition,\
cron:,\
debug,\
dhcp-client:,\
disk-resize-free-percent:,\
enable-utmp,\
encrypt,\
encrypt-cipher:,\
encrypt-passphrase:,\
encrypt-remote-unlock,\
esp-part-size:,\
esp-part-type:,\
ethernet-module:,\
experimental,\
extra-cmdline-options:,\
firewall:,\
fs-type:,\
full-hostname:,\
graphics-vendor:,\
graphics-vendor-driver:,\
harden,\
help,\
hwrng,\
image-filename:,\
images-directory:,\
insecure,\
ipv4only,\
ipv6only,\
ipv6-type,\
kernel-type:,\
keyboard-type:,\
keymap:,\
local-repo:,\
local-repo-sig-file:,\
locale:,\
lvm,\
mdev,\
mirror:,\
no-grub-encryption,\
ntp-servers:,\
ntp-use-host,\
os-device-media:,\
os-device-type:,\
pam,\
password:,\
optimise,\
physical:,\
ramdisk-directory:,\
release:,\
remote-unlock-network-module:,\
remote-unlock-ssh-port:,\
remote-unlock-static-gateway:,\
remote-unlock-static-interface:,\
remote-unlock-static-ip:,\
remote-unlock-static-netmask:,\
root-part-size:,\
rpi-poe-hat,\
rpi-rtc,\
script-filename:,\
short-hostname:,\
ssh-key-types:,\
ssh-public-key:,\
ssh-server:,\
syslogd:,\
timezone:,\
udev,\
use-ramdisk,\
username:,\
virtual:,\
without-cloud-init \
    -n "$0" -- "$@"); then
    error_message "Terminating..."
  fi

  eval set -- "$_cli"

  while true; do
    case "$1" in
      --add-directory-contents )
        extra_files_directory="$2"
        shift 2
        ;;
      --add-packages )
        extra_packages_list="$(echo "$2" | sed -e 's|,| |g')"
        shift 2
        ;;
      --apk-static-url )
        apk_static_url="$2"
        shift 2
        ;;
      --apk-static-version )
        apk_static_version="$2"
        shift 2
        ;;
      --arch )
        case $2 in
          aarch64 | armv7 | x86 | x86_64 )
            image_arch=$2 ;;
          * )
            cli_option_unknown_value "arch '$2'" ;;
        esac
        shift 2
        ;;
      --auth-control )
        case $2 in
          doas | sudo | both )
            image_auth_control=$2 ;;
          * )
            cli_option_unknown_value "auth control mechanism '$2'" ;;
        esac
        shift 2
        ;;
      --boot-by-label )
        image_boot_reference="label"
        shift
        ;;
      --bootchart )
        if [ "$script_type" = "creator" ]; then
          image_bootchart="true"
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --bootloader )
        if [ "$script_type" = "creator" ]; then
          case $2 in
            grub | rpi | syslinux )
              image_bootloader=$2 ;;
            * )
              cli_option_unknown_value "bootloader '$2', valid values are 'grub', 'rpi', and 'syslinux'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --bootloader-password )
        if [ "$script_type" = "creator" ]; then
          image_bootloader_password="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --boottype )
        if [ "$script_type" = "creator" ]; then
          case $2 in
            bios | rpi | uefi )
              image_boot_type=$2 ;;
            * )
              cli_option_unknown_value "boot type '$2', valid values are 'bios', 'rpi', and 'uefi'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --chroot-directory )
        chroot_directory="$2"
        shift 2
        ;;
      --cloud )
        if [ "$script_type" = "creator" ]; then
          image_class="cloud"
          case $2 in
            aliyun | aws | azure | bigstep | brightbox | digitalocean | e24 | exoscale | generic | gce | hetzner | hyperone | ibmcloud | oracle | rootbox | scaleway | tencent | upcloud | vultr )
              image_cloud_type=$2 ;;
            * )
              cli_option_unknown_value "cloud type '$2'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --cloud-seed-url )
        if [ "$script_type" = "creator" ]; then
          cloud_seed_url="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --console-type )
        if [ "$script_type" = "creator" ]; then
          case $2 in
            hypervisor | normal | serial )
              image_console_type="$2" ;;
            * )
              cli_option_unknown_value "console type '$2'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --cpu-vendor )
        if [ "$script_type" = "creator" ]; then
          image_cpu_vendor="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --create-boot-partition )
        if [ "$script_type" = "creator" ]; then
          create_boot_partition=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --cron )
        if [ "$script_type" = "creator" ]; then
          case $2 in
            busybox )
              image_cron_daemon=$2 ;;
            * )
              cli_option_unknown_value "Cron '$2', must be one of 'busybox', or '???'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --debug )
        debug_enabled=true
        shift
        ;;
      --dhcp-client )
        if [ "$script_type" = "creator" ]; then
          image_dhcp_client="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --disk-resize-free-percent )
        if [ "$script_type" = "creator" ]; then
          image_resize_free_percent=$2
          if [ "$image_resize_free_percent" -gt 0 ] 2>/dev/null && \
             [ "$image_resize_free_percent" -lt 100 ] 2>/dev/null; then
            :
          else
            cli_option_unknown_value "Invalid percentage value '$2', it must be within the range 1-99"
          fi
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --enable-utmp )
        if [ "$script_type" = "creator" ]; then
          image_enable_utmp="true"
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --encrypt )
        if [ "$script_type" = "creator" ]; then
          image_encrypted=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --encrypt-cipher )
        if [ "$script_type" = "creator" ]; then
          case $2 in
            adiantum | typical )
              image_encryption_cipher=$2 ;;
            * )
              cli_option_unknown_value "or unsupported LUKS cipher type '$2'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --encrypt-passphrase )
        if [ "$script_type" = "creator" ]; then
          image_encryption_passphrase="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --encrypt-remote-unlock )
        if [ "$script_type" = "creator" ]; then
          image_encrypted=true
          remote_unlock_enabled=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --esp-part-size )
        if [ "$script_type" = "creator" ]; then
          esp_part_size=$2
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --esp-part-type )
        if [ "$script_type" = "creator" ]; then
          case $2 in
            fat12 | fat16 | fat32 )
              esp_type=$2 ;;
            * )
              cli_option_unknown_value "or unsupported ESP partition FAT type '$2'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --ethernet-module )
        if [ "$script_type" = "creator" ]; then
          image_ethernet_module="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --experimental )
        if [ "$script_type" = "creator" ]; then
          image_experimental=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --extra-cmdline-options )
        image_extra_cmdline_options="$2"
        shift 2
        ;;
      --firewall )
        if [ "$script_type" = "creator" ]; then
          case $2 in
            awall | iptables | nftables )
              image_firewall=$2 ;;
            * )
              cli_option_unknown_value "or unsupported firewall '$2'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --fs-type )
        if [ "$script_type" = "creator" ]; then
          case $2 in
            btrfs | ext4 | f2fs | xfs )
              image_fs_type="$2" ;;
            * )
              cli_option_unknown_value "or unsupported filesystem type '$2'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --full-hostname )
        if [ "$script_type" = "creator" ]; then
          image_full_hostname="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --graphics-vendor )
        if [ "$script_type" = "creator" ]; then
          image_graphics_vendor="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --graphics-vendor-driver )
        if [ "$script_type" = "creator" ]; then
          image_graphics_vendor_driver="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      -h | --help )
        usage
        exit 0
        ;;
      --harden )
        if [ "$script_type" = "creator" ]; then
          image_harden=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --hwrng )
        image_hwrng=true
        shift
        ;;
      --image-filename )
        filename_for_image="$2"
        shift 2
        ;;
      --images-directory )
        images_directory="$2"
        shift 2
        ;;
      --insecure )
        if [ "$script_type" = "creator" ]; then
          image_insecure=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --ipv4only )
        if [ "$script_type" = "creator" ]; then
          image_disable_ipv6=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --ipv6only )
        if [ "$script_type" = "creator" ]; then
          image_disable_ipv4=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --ipv6-type )
        case $2 in
          dhcp | slaac | static )
            image_ipv6_type=$2 ;;
          * )
            cli_option_unknown_value "kernel type '$2', can only be 'dhcp', 'slaac', or 'static'" ;;
        esac
        shift 2
        ;;
      --kernel-type )
        case $2 in
          normal | edge )
            image_kernel_type=$2 ;;
          * )
            cli_option_unknown_value "kernel type '$2', can only be 'edge' or 'normal'" ;;
        esac
        shift 2
        ;;
      --keyboard-type )
        image_keyboard_type="$2"
        shift 2
        ;;
      --keymap )
        image_keymap="$2"
        shift 2
        ;;
      --local-repo )
        local_alpine_repository="$2"
        shift 2
        ;;
      --local-repo-sig-file )
        local_repo_signature_file="$2"
        shift 2
        ;;
      --locale )
        image_locale="$2"
        shift 2
        ;;
      --lvm )
        if [ "$script_type" = "creator" ]; then
          image_lvm_rootfs=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --mdev )
        if [ "$script_type" = "creator" ]; then
          image_mdev=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --mirror )
        alpine_mirror_site="$2"
        shift 2
        ;;
      --no-grub-encryption )
        if [ "$script_type" = "creator" ]; then
          image_no_grub_encryption=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --ntp-servers )
        image_ntp_servers="$2"
        image_ntp_use_host=false
        shift 2
        ;;
      --ntp-use-host )
        image_ntp_use_host=true
        shift
        ;;
      --optimise )
        if [ "$script_type" = "creator" ]; then
         image_optimise=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --os-device-media )
        case $2 in
          disk | flash | sd | ssd )
            image_os_device_media=$2 ;;
          * )
            cli_option_unknown_value "os device media '$2'" ;;
        esac
        shift 2
        ;;
      --os-device-type )
        case $2 in
          nvme | sata | scsi | sd | usb )
            image_os_device_type=$2 ;;
          * )
            cli_option_unknown_value "os device type '$2'" ;;
        esac
        shift 2
        ;;
      --pam )
        image_pam_enabled=true
        shift
        ;;
      --password )
        image_default_user_password="$2"
        shift 2
        ;;
      --physical )
        if [ "$script_type" = "creator" ]; then
          image_class="physical"
          case $2 in
            pc | rpi2 | rpi3 | rpi4 )
              image_physical_type=$2 ;;
            * )
              cli_option_unknown_value "physical machine type '$2'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --ramdisk-directory )
        ramdisk_directory="$2"
        shift 2
        ;;
      --release )
        if [ "$script_type" = "creator" ]; then
          case $2 in
            3.13 | 3.14 | 3.15 )
              image_alpine_release=v$2 ;;
            edge )
              image_alpine_release=$2 ;;
            * )
              cli_option_unknown_value "or unsupported Alpine release '$2'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --remote-unlock-network-module )
        if [ "$script_type" = "creator" ]; then
          remote_unlock_network_module="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --remote-unlock-ssh-port )
        if [ "$script_type" = "creator" ]; then
          remote_unlock_ssh_port="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --remote-unlock-static-gateway )
        if [ "$script_type" = "creator" ]; then
          remote_unlock_static_gateway="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --remote-unlock-static-interface )
        if [ "$script_type" = "creator" ]; then
          remote_unlock_static_interface="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --remote-unlock-static-ip )
        if [ "$script_type" = "creator" ]; then
          remote_unlock_static_ip="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --remote-unlock-static-netmask )
        if [ "$script_type" = "creator" ]; then
          remote_unlock_static_netmask="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --root-part-size )
        override_root_part_size="$2"
        shift 2
        ;;
      --rpi-poe-hat )
        if [ "$script_type" = "creator" ]; then
          rpi_use_poe_hat=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --rpi-rtc )
        if [ "$script_type" = "creator" ]; then
          rpi_use_rtc=true
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --script-filename )
        generated_script_filename="$2"
        shift 2
        ;;
      --short-hostname )
        if [ "$script_type" = "creator" ]; then
          image_short_hostname="$2"
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --ssh-key-types )
        if [ "$script_type" = "creator" ]; then
          case $2 in
            'ed25519' | 'ed25519+rsa' )
              IMAGE_SSH_KEYTYPES="$2" ;;
            * )
              cli_option_unknown_value "SSH host key type '$2', must be either 'ed25519' or 'ed25519+rsa'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --ssh-public-key )
        if [ "$script_type" = "creator" ]; then
          if [ -f "$2" ]; then
            ssh_public_key=$(cat "$2")
          else
            error_message "SSH keyfile '$2' not found"
          fi
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --ssh-server )
        if [ "$script_type" = "creator" ]; then
          case $2 in
            dropbear | openssh | tinyssh )
              image_ssh_server=$2 ;;
            * )
              cli_option_unknown_value "SSH server software '$2', must be one of 'dropbear', 'openssh', or 'tinyssh'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --syslogd )
        if [ "$script_type" = "creator" ]; then
          case $2 in
            busybox | rsyslog )
              image_syslog_server=$2 ;;
            * )
              cli_option_unknown_value "Syslog server software '$2', must be one of 'busybox', or 'rsyslog'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --timezone )
        image_timezone=$2
        shift 2
        ;;
      --udev )
        if [ "$script_type" = "creator" ]; then
          image_mdev=false
        else
          cli_option_not_handled
        fi
        shift
        ;;
      --use-ramdisk )
        use_ramdisk=true
        shift
        ;;
      --username )
        if [ "$script_type" = "creator" ]; then
          image_admin_username=$2
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --virtual )
        if [ "$script_type" = "creator" ]; then
          image_class="virtual"
          case $2 in
            generic | hyperv | libvirtd | lxd | proxmox | qemu | virtualbox | vmware )
              image_vm_type=$2 ;;
            * )
              echo
              cli_option_unknown_value "virtual machine type '$2'" ;;
          esac
        else
          cli_option_not_handled
        fi
        shift 2
        ;;
      --without-cloud-init )
        image_without_cloud_init=true
        shift
        ;;
      -- )
        shift
        break
        ;;
    esac
  done
}


#
# Help text
#
usage() {
  echo "Usage: $0 [ options ]"
  echo
  echo "When called with no options is equivalent to"
  echo "'--arch x86_64 --release edge --bootloader syslinux --virtual qemu'."
  echo
  echo "Options:"
  echo
  option_help "--add-directory-contents < directory-path >" "Base url to download statically compiled APK tool from."
  option_help "--add-packages '< packages list >'" "A space or comma seperated list of packages to install."
  option_help "--apk-static-url < url >" "Base url to download statically compiled APK tool from."
  option_help "--apk-static-version < version >" "Version of the statically compiled APK tool to download/use."
  option_help "--arch < aarch64 | armv7 | x86 | x86_64 >" "Defaults to x86_86, except if physical rpi2/rpi3/rpi4 specified when it defaults to aarch64."
  option_help "--auth-control < doas | sudo | both >" "The method used by normal users to run privileged commands."
  if [ -n "${image_experimental+x}" ]; then
    option_help "--boot-by-label" "Use Labels rather than UUIDs in /etc/fstab and bootloader to refer to filesystems."
  fi
  option_help "--bootchart" "Enables bootchart creation during boot."
  option_help "--bootloader < grub | syslinux >" "Defaults to Syslinux. Not relevant for RPI physical machines."
  option_help "--bootloader-password < password >" "Specify password to lock GRUB or Syslinux menu with. Not relevant for RPI physical machines."
  option_help "--boottype < bios | uefi >" "Defaults to UEFI. Not relevant for RPI physical machines."
  option_help "--chroot-directory < directory >" "Temporary directory to use for building the Alpine image. Defaults to './chroot'."
  if [ -z "${image_class+x}" ] || [ "$image_class" = "cloud" ]; then
    option_help "--cloud <cloud type>" "Valid values are: generic aliyun aws azure bigstep brightbox digitalocean e24 exoscale gce hetzner hyperone ibmcloud oracle rootbox scaleway tencent upcloud vultr"
  fi
  if [ -z "${image_class+x}" ] || [ "$image_class" = "cloud" ]; then
    option_help "--cloud-seed-url < url >" "Base url for cloud-init NoCloud DataSource to download configuration from."
  fi
  option_help "--console-type < hypervisor | normal | serial >" "The type of device the console is on."
  option_help "--cpu_vendor < amd | intel >" "Used to decide if only AMD or Intel relevant microcode is installed and whether vendor-specific kernel modules are included in the initramfs."
  option_help "--create-boot-partition" "Create a separate /boot partition, even if not required."
  if [ -n "${image_experimental+x}" ]; then
    option_help "--cron < busybox | ??? >" "Cron daemon software to use."
  fi
  option_help "--debug" "Enable debug-specific logging."
  if [ -n "${image_experimental+x}" ]; then
    option_help "--dhcp-client < dhclient | dhcpcd | udhcpc >" "Specify the DHCP Client software to use. Defaults to 'udhcpc'."
  fi
  if [ -n "${image_experimental+x}" ]; then
    option_help "--disk-resize-free-percent < percent >" "For Flash/SSDs/SDcard devices the percent of disk to leave unallocated when root is resized."
  fi
  if [ -n "${image_experimental+x}" ]; then
    option_help "--ethernet-module < module-name >" "When remote unlocking of encrypted filesystem is enabled this parameter is also required to specific the relevant kernel module for the ethernet device as the driver must be included in the initramfs as (obviously) it cannot be loaded from the (still encrypted at that point) rootfs."
  fi
  option_help "--encrypt" "Enable LUKS encryption of the rootfs."
  option_help "--encrypt-passphrase < passphrase >" "The passphrase to use for the encrypted filesystem. Defaults to 'InsecureDefault' if not specified."
  if [ -n "${image_experimental+x}" ]; then
    option_help "--encrypt-remote-unlock" "Enable functionality for the remote-unlocking of encrypted root filesystem at boot time via SSH."
  fi
  option_help "--experimental" "Enable experimental options."
  option_help "--extra-cmdline-options < options >" "Extra entries to add to the /proc/cmdline passed by bootloader to the initramfs and kernel."
  if [ -z "${image_class+x}" ] || [ "$image_class" = "physical" ]; then
    option_help "--full-hostname < hostname >" "Only for physical machines. The hostname, including domain, to place in the generated cloud-init user-data YAML file."
  fi
  option_help "--graphics-vendor < amd | intel | nvidia >" "Indicate the vendor of server's graphics card so that the initramfs can be generated containing only that vendor's drivers and firmware."
  option_help "--harden" "Disables kernel module loading, delete unnecessary users & groups, and also disable unnecessary kernel modules."
  option_help "--hwrng" "Machine has a hardware RNG."
  option_help "--image-filename < filename >" "Filename to use for the created Alpine disk image."
  option_help "--images-directory < directory >" "The directory where to store the created disk image."
  option_help "--insecure" "Permit password-based access via SSH."
  option_help "--ipv4only" "Do not enable IPv6 in the created disk image."
  option_help "--ipv6only" "Do not enable IPv4 in the created disk image."
  if [ -n "${image_experimental+x}" ]; then
    option_help "--ipv6-type '< dhcp | slaac | static >'" "Indicates how an IPv6 address should be obtained. Defaults to 'dhcp'."
  fi
  option_help "--keyboard-type '< ps2 | usb >'" "Indicate the type of physical console keyboard. Defaults to 'ps2' for x86/x86_64 machines in many cases, however for aarch64 machines defaults to 'usb'."
  option_help "--keymap '< keymap >'" "Defaults to 'us us'."
  option_help "--local-repo < url >" "Local Alpine repository for *additional* packages."
  option_help "--local-repo-sig-file < filename >" "Signature file used to sign packages in local Alpine repository."
  option_help "--locale < locale >" "Defaults to 'en_US'."
  option_help "--lvm" "Use LVM for root filesystem. If '--encrypt' is also specified then create LVM-on-LUKS filesystem."
  if [ -n "${image_experimental+x}" ]; then
    option_help "--mdev" "Use mdev rather than udev."
  fi
  option_help "--mirror < mirror url >" "URL of Alpine mirror site to use."
  option_help "--no-grub-encryption" "Do not enable GRUB's own LUKS handling (distinct from whether LUKS is in use in general)."
  option_help "--ntp-servers < comma separated list of NTP servers >" "Synch with these NTP servers."
  if [ -n "${image_experimental+x}" ]; then
    option_help "--ntp-use-host" "For VMs and Cloud servers sync NTP time from hypervisor host."
  fi
  option_help "--optimise" "Optimise the image setup such as only enabling kernel modules required."
  option_help "--os-device-media < disk | flash | sd | ssd >" "The storage media of the device that disk image will be installed on."
  option_help "--os-device-type < nvme | sata | scsi | sd | usb >" "The interface type of the device that disk image will be installed on."
  if [ -n "${image_experimental+x}" ]; then
    option_help "--pam" "Enable PAM support."
  fi
  option_help "--password < password >" "Password for default user created upon 1st boot. If this option is not specified then the account password is locked (but SSH access via SSH key, if configured using '--ssh-public-key', is still possible)."
  if [ -z "${image_class+x}" ] || [ "$image_class" = "physical" ]; then
    option_help "--physical < pc | rpi2 | rpi3 | rpi4 >" "The type of physical machine to be created."
  fi
  option_help "--ramdisk-directory < directory >" "When '--use-ramdisk' is also specified this value indicates the directory in which to store the ramdisk file."
  option_help "--release < 3.13 | 3.14 | edge >" "Which Alpine Release to use for the disk image. If not specified then defaults to 'edge'."
  if [ -n "${image_experimental+x}" ]; then
    option_help "--remote-unlock-network-module < kernel module name >" "Specifies the name of the network device kernel module to be loaded."
    option_help "--remote-unlock-ssh-port < port number >" "Specifies the TCP port that the temporary SSH daemon should listen on. If not specified then defaults to '22'."
    option_help "--remote-unlock-static-gateway < IP address >" "Specifies the IP address of the local router. Only applicable when '--remote-unlock-static-ip' has also been specified."
    option_help "--remote-unlock-static-interface < interface name >" "Specifies the network interface name. Only applicable when '--remote-unlock-static-ip' has also been specified."
    option_help "--remote-unlock-static-ip < IP address >" "Specifies the (temporary) IP address for the machine to use for remote unlock functionality. If not specified then DHCP is used instead."
    option_help "--remote-unlock-static-netmask < netmask >" "Specifies the network netmask to use. Only applicable when '--remote-unlock-static-ip' has also been specified."
  fi
  option_help "--root-part-size < size in MiB>" "Specify the size of the root partition. Useful in conjunction with --add-packages where more space is needed."
    if [ -z "${image_class+x}" ] || [ "$image_class" = "physical" ]; then
    option_help "--rpi-poe-hat" "When creating an image for a Raspberry Pi (i.e. '--physical rpi2') indicates that the RPI has a Raspberry Pi official PoE HAT fitted."
  fi
	if [ -z "${image_class+x}" ] || [ "$image_class" = "physical" ]; then
    option_help "--rpi-rtc" "When creating an image for a Raspberry Pi (i.e. '--physical rpi2') indicates that the RPI has a hardware RTC fitted."
  fi
  option_help "--script-filename < filename >" "The filename of the script to be created."
  if [ -z "${image_class+x}" ] || [ "$image_class" = "physical" ]; then
    option_help "--short-hostname < hostname >" "Only for physical machines. The hostname, without domain, to place in the generated cloud-init user-data YAML file."
  fi
  option_help "--ssh-key-types < key types >" "SSH host key types to be used. Valid values are: 'ed25519' or 'ed25519+rsa'."
  option_help "--ssh-public-key < filename >" "File containing the SSH public key that is permitted to log in as the default user and also, when remote encryption unlocking is enabled, to connect to the temporary SSH server used for unlocking of disk encryption."
  if [ -n "${image_experimental+x}" ]; then
    option_help "--ssh-server < dropbear | openssh | tinyssh >" "SSH server software to use."
  fi
  option_help "--syslogd < busybox | rsyslog >" "Syslog server software to use."
  if [ -z "${image_class+x}" ] || [ "$image_class" = "physical" ]; then
  option_help "--timezone < zonename >" "Only for physical machines. Timezone to place in the generated cloud-init user-data YAML file. Example value: 'Europe/London'."
  fi
  if [ -n "${image_experimental+x}" ]; then
    option_help "--udev" "Use udev rather than mdev."
  fi
  option_help "--use-ramdisk" "Indicates to use a (temporary) ramdisk when creating the disk image to speed up creation and/or to reduce disk writes (i.e. on SSD)."
  option_help "--username <username>" "Name of the default account to create upon 1st boot. Defaults to 'alpine'."
  if [ -z "${image_class+x}" ] || [ "$image_class" = "virtual" ]; then
    option_help "--virtual <vm type>" "Valid values are:  < generic | hyperv | libvirtd | lxd | openstack | proxmox | qemu | virtualbox | vmware >"
  fi
  if [ -n "${image_experimental+x}" ]; then
    option_help "--without-cloud-init" "Indicates that cloud-init should not be installed/configured."
  fi
}


#
# Check that the combination of CLI options make sense
#
validate_cli_options() {
  local _image_base_filename

  if [ -z "${generated_script_filename+x}" ]; then
    error_message "You must specify a filename for the script to be created!"
  fi

  # Fallbacks for settings not being specified
  #--------------------------------------------

  # If arch not specified then assume default
  if [ -z ${image_arch+x} ]; then
    image_arch=$CONSTANT_DEFAULT_ARCH
  fi

  # If Alpine release not specified then assume default
  if [ -z ${image_alpine_release+x} ]; then
    image_alpine_release=$CONSTANT_DEFAULT_ALPINE_RELEASE
  fi

  # If neither Cloud / VM / Physical specified then assume QEMU VM
  if [ -z ${image_class+x} ]; then
    image_class="virtual"
    image_vm_type="qemu"
  fi

  if [ -z "${filename_for_image+x}" ]; then
    _image_base_filename="alpine-$image_alpine_release-$image_arch-$image_class"
    case $image_class in
      cloud )
        filename_for_image="$_image_base_filename-$image_cloud_type.img"
        ;;
      physical )
        filename_for_image="$_image_base_filename-$image_physical_type.img"
        ;;
      virtual )
        filename_for_image="$_image_base_filename-$image_vm_type.img"
        ;;
    esac
  fi

  if [ -z ${image_kernel_type+x} ]; then
    image_kernel_type="normal"
  fi

  # If Filesystem type not specified, use default.
  if [ -z ${image_fs_type+x} ]; then
    image_fs_type=$CONSTANT_DEFAULT_FS_TYPE
  fi

  # If console type not specified then assume default
  if [ -z ${image_console_type+x} ]; then
    image_console_type="normal"
  fi

  # If console name not specified then assume default
  if [ -z ${image_console_name+x} ]; then
    case $image_console_type in
      hypervisor )
        image_console_name="hvc0" ;;
      normal )
        image_console_name="tty0" ;;
      serial )
        image_console_name="ttyS0" ;;
    esac
  fi

  # If keyboard type not specified then assume default
  if [ -z ${image_keyboard_type+x} ]; then
    if [ "$image_arch" = "aarch64" ] || \
       { [ "$image_class" = "physical" ] && \
         [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; }; then
      # aarch64 VMs and all RPIs have USB keyboard
      image_keyboard_type="usb"
    else
      image_keyboard_type="both"
    fi
  fi

  # Log filename is based on image filename
  logs_output_file=$(echo "$filename_for_image" | sed -e 's|\.img$|\.log|')

  # If version of APK-static is not specified then assume default
  if [ -z ${apk_static_version+x} ]; then
    apk_static_version=$CONSTANT_APK_STATIC_VERSION
  fi

  # If URL to download APK-static is not specified then assume default
  if [ -z ${apk_static_url+x} ]; then
    apk_static_url=$CONSTANT_APK_STATIC_URL
  fi

  # If chroot directory not specified then assume default
  if [ -z ${chroot_directory+x} ]; then
    chroot_directory=$CONSTANT_DEFAULT_CHROOT_DIRECTORY
  fi

  # If images directory not specified then assume default
  if [ -z ${images_directory+x} ]; then
    images_directory=$CONSTANT_DEFAULT_IMAGES_DIRECTORY
  fi

  # If use_ramdisk specified then assume disabled
  if [ -n "${use_ramdisk+x}" ]; then
    if [ -z "${ramdisk_directory+x}" ]; then
      # If ramdisk directory not specified then assume default
      ramdisk_directory=$CONSTANT_DEFAULT_RAMDISK_DIRECTORY
    fi
  fi

  # If Alpine repo mirror site not specified then assume default
  if [ -z ${alpine_mirror_site+x} ]; then
    alpine_mirror_site=$CONSTANT_DEFAULT_MIRROR_SITE
  fi

  # If boot_by_label not specified then assume default
  if [ -z ${image_boot_reference+x} ]; then
    image_boot_reference=$CONSTANT_DEFAULT_BOOT_REFERENCE
  fi

  if [ -z ${image_admin_username+x} ]; then
    image_admin_username=$CONSTANT_DEFAULT_ADMIN_USERNAME
  fi

  if [ -z ${image_dhcp_client+x} ]; then
    image_dhcp_client=$CONSTANT_DEFAULT_DHCP_CLIENT
  fi

  if [ -z ${image_resize_free_percent+x} ]; then
    image_resize_free_percent=$CONSTANT_DEFAULT_DISK_RESIZE_FREE_PERCENT
  fi

  if [ -z ${ipv6_type+x} ]; then
    image_ipv6_type=$CONSTANT_DEFAULT_IPV6_TYPE
  fi

  if [ -z ${esp_type+x} ]; then
    case $image_class in
      cloud )
        esp_type=$CONSTANT_CLOUD_ESP_TYPE
        ;;
      physical )
        esp_type=$CONSTANT_PHYSICAL_ESP_TYPE
        ;;
      virtual )
        esp_type=$CONSTANT_VIRTUAL_ESP_TYPE
        ;;
    esac
  fi

  if [ -z ${image_firewall+x} ]; then
    image_firewall=$CONSTANT_DEFAULT_FIREWALL
  fi

  if [ -z ${image_keymap+x} ]; then
    image_keymap=$CONSTANT_DEFAULT_KEYMAP
  fi

  if [ -z ${image_locale+x} ]; then
    image_locale=$CONSTANT_DEFAULT_LOCALE
  fi

  # If mdev/udev not specified, use default.
  if [ -z ${image_mdev+x} ]; then
    image_mdev=$CONSTANT_DEFAULT_MDEV
  fi

  # If SSH host key types not specified then assume default
  if [ -z ${image_ssh_keytypes+x} ]; then
    image_ssh_keytypes=$CONSTANT_DEFAULT_SSH_KEYTYPES
  fi

  # If Cron daemon software not specified then assume default
  if [ -z ${image_cron_daemon+x} ]; then
    image_cron_daemon=$CONSTANT_DEFAULT_CRON_DAEMON
  fi

  # If SSH server software not specified then assume default
  if [ -z ${image_ssh_server+x} ]; then
    image_ssh_server=$CONSTANT_DEFAULT_SSH_SERVER
  fi

  # If Syslog server software not specified then assume default
  if [ -z ${image_syslog_server+x} ]; then
    image_syslog_server=$CONSTANT_DEFAULT_SYSLOG_SERVER
  fi

  if [ -z ${image_timezone+x} ] && \
     [ "$image_class" = "physical" ]; then
    image_timezone=$CONSTANT_DEFAULT_TIMEZONE
  fi

  # Encryption
  if [ -n "${image_encrypted+x}" ]; then
    if [ -z ${image_encryption_cipher+x} ]; then
      if [ "$image_class" = "physical" ] && \
         [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
        # For Raspberry Pis use Adiantum
        image_encryption_cipher="adiantum"
      else
        image_encryption_cipher=$CONSTANT_DEFAULT_LUKS_CIPHER
      fi
    fi
    if [ -z "${image_encryption_passphrase+x}" ]; then
      image_encryption_passphrase="$CONSTANT_DEFAULT_LUKS_PASSPHRASE"
    fi
  fi


  # Sanity checks
  #---------------

  # Doas
  if [ -z ${image_auth_control+x} ]; then
    if [ "$image_alpine_release" = "v3.13" ] || \
       [ "$image_alpine_release" = "v3.14" ]; then
      image_auth_control="sudo"
    else
      image_auth_control=$CONSTANT_DEFAULT_AUTH_CONTROL
    fi
  elif { [ "$image_alpine_release" = "v3.13" ] || \
         [ "$image_alpine_release" = "v3.14" ]; } && \
       { [ "$image_auth_control" = "doas" ] || \
         [ "$image_auth_control" = "both" ]; } then
    error_message "Alpine v3.13 and v3.14 do not work correctly with doas and cloud-init. Please use sudo only."
  fi

  # NTP
  if [ "$image_class" = "physical" ]; then
    if [ "${image_ntp_use_host+x}" = "true" ]; then
      error_message "PTP/NTP host sync can not be specified for physical servers!"
    fi
  else
    if [ -z "${image_experimental+x}" ] && \
       [ "${image_ntp_use_host+x}" = "true" ]; then
      error_message "PTP/NTP host sync is currently experimental! Full support is not present in released Alpine packages."
    fi
    if [ -n "${image_ntp_servers+x}" ]; then
      error_message "NTP servers can only be specified for physical servers, other servers obtain this information from user-data!"
    fi
  fi

  # AWS Encryption
  if [ -n "${image_encrypted+x}" ] && \
     [ "$image_class" = "cloud" ] && \
     [ "$image_cloud_type" = "aws" ]; then
    error_message "For AWS you should use an encrypted EBS device!"
  fi

  # Remove encryption unlock
  if [ -n "${remote_unlock_enabled+x}" ] && \
     [ "$image_class" = "cloud" ]; then
    error_message "Remote unlocking of encrypted rootfs is not supported in cloud!"
  fi

  # Boot device type
  if [ -z "${image_os_device_type+x}" ]; then
    if [ "$image_class" = "physical" ] && \
       [ "$(expr "$image_physical_type" : '.*rpi.*')" -ne 0  ]; then
      image_os_device_type="sd"
    else
      image_os_device_type=$CONSTANT_DEFAULT_BOOT_DEVICE_TYPE
    fi
  fi

  # Boot device media
  if [ -z ${image_os_device_media+x} ]; then
    case $image_os_device_type in
      nvme )
        image_os_device_media="ssd" ;;
      sd )
        image_os_device_media="sd" ;;
      usb )
        image_os_device_media="flash" ;;
      * )
        image_os_device_media="disk" ;;
    esac
  fi

  # Cloud / Physical / Virtual specific settings
  if [ "$image_class" = "cloud" ]; then
    # Check for cloud machines that other specified settings make sense
    case $image_arch in
      aarch64 )
        if [ -n "${image_bootloader+x}" ]; then
          if [ "$image_bootloader" = "syslinux" ]; then
            error_message "aarch64 cloud machine can only use Grub bootloader!"
          fi
        else
          image_bootloader="grub"
        fi
        case $image_cloud_type in
          aws )
            :
            ;;
          azure )
            image_ntp_use_host=true ;;
          oracle )
            :
            ;;
          generic )
            :
            ;;
          * )
            error_message "aarch64 cloud images cannot be created for this cloud provider!" ;;
        esac
        # aarch64 VMs always use UEFI
        image_boot_type="uefi"
        if [ -z "${keyboard_type+x}" ]; then
          # aarch64 VMs normally use USB keyboard
          keyboard_type="usb"
        fi
        ;;

      x86_64 )
        case $image_cloud_type in
          azure )
            image_boot_type="bios"
            image_bootloader="grub"
            keyboard_type="serial"
            ;;
          oracle )
            image_boot_type="bios"
            image_bootloader="syslinux"
            ;;
          vultr )
            image_boot_type="bios"
            image_bootloader="syslinux"
            ;;
          * )
            image_boot_type="bios"
            image_bootloader="grub"
            ;;
        esac
        if [ -z "${keyboard_type+x}" ]; then
          keyboard_type="ps2"
        fi
        ;;
    esac

    if [ -z "${image_ntp_use_host+x}" ]; then
      # By default the majority of Cloud providers do not support
      # hypervisor PTP/NTP host time sync
      image_ntp_use_host=false
    fi
  elif [ "$image_class" = "physical" ]; then
    # Check for physical machines that other specified settings make sense
    if [ "$image_physical_type" = "pc" ]; then
      # Unless overridden then support both PS/2 & USB keyboards
      keyboard_type="${image_keyboard_type:-both}"

      if [ "$image_arch" = "x86" ]; then
        # x86
        if [ -z "${image_bootloader+x}" ]; then
          image_bootloader="syslinux"
        fi
        if [ -n "${image_boot_type+x}" ]; then
          image_boot_type="bios"
        elif [ "$image_boot_type" = "uefi" ]; then
          error_message "UEFI is not supported for x86!"
        fi
      else
        # x86_64
        if [ -z "${image_boot_type+x}" ]; then
          image_boot_type="uefi"
          if [ -z "${image_bootloader+x}" ]; then
            image_bootloader="grub"
          fi
        fi
        if [ -z "${image_bootloader+x}" ]; then
          image_bootloader="syslinux"
        fi
      fi
    elif [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
      # Raspberry Pi
      if [ -n "${image_keyboard_type+x}" ] && \
         [ "$image_keyboard_type" != "usb" ]; then
        error_message "RPI keyboard is always USB!"
      else
        keyboard_type="usb"
      fi

      if [ -z "${image_bootloader+x}" ]; then
        image_bootloader="rpi"

        if [ -z ${image_boot_type+x} ]; then
          image_boot_type="rpi"
        elif [ "$image_boot_type" != "rpi" ]; then
          error_message "An invalid boot type was specified! For an RPI only 'rpi' is valid"
        fi
      elif [ "${image_bootloader}" != "rpi" ]; then
        error_message "An invalid bootloader was specified!"
      fi
    fi

    # For physical machines obviously there is no hypervisor host
    # to time sync with.
    image_ntp_use_host=false

  elif [ "$image_class" = "virtual" ]; then
    # Check for Virtual Machines that other specified settings make sense

    case $image_arch in
      armv7 )
        error_message "armv7 virtual machines are not supported!" ;;
      aarch64 )
        if [ -n "${image_bootloader+x}" ]; then
          if [ "$image_bootloader" = "syslinux" ]; then
            error_message "aarch64 virtual machine can only use Grub bootloader!"
          fi
        else
          image_bootloader="grub"
        fi

        if [ "$image_vm_type" = "virtualbox" ]; then
          error_message "aarch64 Virtualbox images cannont be created!"
        fi

        # aarch64 VMs always use UEFI
        image_boot_type="uefi"

        if [ -z "${keyboard_type+x}" ]; then
          # aarch64 VMs normally use USB keyboards
          keyboard_type="usb"
        fi
        ;;
      x86 )
        if [ -z "${image_bootloader+x}" ]; then
          image_bootloader="syslinux"
        fi

        if [ -n "${image_boot_type+x}" ]; then
          image_boot_type="bios"
        elif [ "$image_boot_type" = "uefi" ]; then
          error_message "UEFI is not supported for x86!"
        fi

        case $image_vm_type in
          virtualbox )
            # Only supports PS/2 keyboards
            keyboard_type="ps2" ;;
          * )
            keyboard_type="${image_keyboard_type:-both}" ;;
        esac
        ;;
      x86_64 )
        if [ -z ${image_bootloader+x} ]; then
          if [ -z ${image_boot_type+x} ]; then
            image_bootloader="syslinux"
            image_boot_type="bios"
          elif [ "$image_boot_type" = "bios" ]; then
            image_bootloader="syslinux"
          else
            image_bootloader="grub"
          fi
        elif [ "$image_bootloader" = "syslinux" ]; then
          if [ -z ${image_boot_type+x} ]; then
            image_boot_type="bios"
          fi
        else
          if [ -z ${image_boot_type+x} ]; then
            image_boot_type="uefi"
          fi
        fi

        case $image_vm_type in
          virtualbox )
            # Only supports PS/2 keyboards
            keyboard_type="ps2" ;;
          * )
            keyboard_type="${image_keyboard_type:-both}" ;;
        esac
        ;;
    esac

    if [ -z "${image_ntp_use_host+x}" ]; then
      # The majority of VM hypervisors do not support PTP/NTP host time sync.
      image_ntp_use_host=false
    fi
  fi

  # Experimental options
  if [ -z "${image_experimental+x}" ]; then
    if [ -n "${image_bootchart+x}" ]; then
      error_message "Bootchart support is an experimental option!"
    fi
	
    if [ "$image_bootloader" = "syslinux" ] && \
       [ "$image_boot_type" = "uefi" ]; then
      error_message "Syslinux UEFI support is an experimental option!"
    fi
  fi

  if [ -n "${create_boot_partition+x}" ] && \
     [ "$image_bootloader" = "grub" ]; then
    # By creating a separate boot partition this means that
    # GRUB should also not enable its own encryption support.
    image_no_grub_encryption=true
  fi

  if { [ "$image_class" = "physical" ] && \
       [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; } || \
     { [ "$image_bootloader" = "syslinux" ]  && \
       [ "$image_boot_type" = "bios" ] && \
       { [ -n "${image_encrypted+x}" ] || \
         [ -n "${image_lvm_rootfs+x}" ]; } } || \
     { [ "$image_bootloader" = "grub" ] && \
       [ -n "${image_encrypted+x}" ] && \
       [ -n "${image_experimental+x}" ] && \
       [ -n "${remote_unlock_enabled+x}" ]; } || \
     { [ "$image_bootloader" = "grub" ] && \
       [ -n "${image_encrypted+x}" ] && \
       [ -n "${image_no_grub_encryption+x}" ]; } || \
     { [ "$image_bootloader" = "grub" ] && \
       [ -n "${image_encrypted+x}" ] && \
       [ "$image_encryption_cipher" = "adiantum" ]; } || \
     [ -n "${create_boot_partition+x}" ]; then
    # A separate boot partition is required in the following situations:
    # (a) its a Raspberry Pi
    # (b) Syslinux is used as bootloader for BIOS with encrypted rootfs or LVM rootfs
    # (c) GRUB is used as bootloader with remote unlock of encrypted rootfs
    # (d) GRUB is used as bootloader with encrypted rootfs but unencrypted boot partition
    # (e) Adiantum encryption is being used - GRUB's LUKS module does not support this
    # (f) a separate boot partition is explicitly requested
    needs_boot_partition=true
  fi

  # Sort out partition sizing
  #---------------------------

  if [ -n "${override_root_part_size+x}" ]; then
    general_root_part_size=$override_root_part_size
  fi

  case $image_class in
    cloud )
      case $image_arch in
        aarch64 )
          general_boot_part_size=$CONSTANT_CLOUD_AARCH64_BOOT_PART_SIZE ;;
        x86 )
          general_boot_part_size=$CONSTANT_CLOUD_X86_BOOT_PART_SIZE ;;
        x86_64 )
          general_boot_part_size=$CONSTANT_CLOUD_X86_64_BOOT_PART_SIZE ;;
      esac
      if [ -z "${general_root_part_size+x}" ]; then
        general_root_part_size=$CONSTANT_CLOUD_ROOT_PART_SIZE
      fi
      if [ -z "${esp_part_size+x}" ]; then
        general_uefi_part_size=$CONSTANT_DEFAULT_CLOUD_ESP_PART_SIZE
      else
        general_uefi_part_size=$esp_part_size
      fi
      ;;
    physical )
      if [ "$image_physical_type" = "pc" ]; then
        # PC
        general_boot_part_size=$CONSTANT_PHYSICAL_BOOT_PART_SIZE
        if [ -z "${general_root_part_size+x}" ]; then
          general_root_part_size=$CONSTANT_PHYSICAL_ROOT_PART_SIZE
        fi
        if [ -z "${esp_part_size+x}" ]; then
          general_uefi_part_size=$CONSTANT_DEFAULT_PHYSICAL_ESP_PART_SIZE
        else
          general_uefi_part_size=$esp_part_size
        fi
      else
        # Raspberry Pi
        case $image_arch in
          aarch64 )
            general_boot_part_size=$CONSTANT_RPI_AARCH64_BOOT_PART_SIZE
            if [ -z "${general_root_part_size+x}" ]; then
              general_root_part_size=$CONSTANT_RPI_AARCH64_ROOT_PART_SIZE
            fi
            ;;
          armv7 )
            general_boot_part_size=$CONSTANT_RPI_ARMV7_BOOT_PART_SIZE
            if [ -z "${general_root_part_size+x}" ]; then
              general_root_part_size=$CONSTANT_RPI_ARMV7_ROOT_PART_SIZE
            fi
            ;;
        esac
      fi
      ;;
    virtual )
      case $image_arch in
        aarch64 )
          general_boot_part_size=$CONSTANT_VIRTUAL_AARCH64_BOOT_PART_SIZE ;;
        x86 )
          general_boot_part_size=$CONSTANT_VIRTUAL_X86_BOOT_PART_SIZE ;;
        x86_64 )
          general_boot_part_size=$CONSTANT_VIRTUAL_X86_64_BOOT_PART_SIZE ;;
      esac
      if [ -z "${general_root_part_size+x}" ]; then
        general_root_part_size=$CONSTANT_VIRTUAL_ROOT_PART_SIZE
      fi
      if [ -z "${esp_part_size+x}" ]; then
        general_uefi_part_size=$CONSTANT_DEFAULT_VIRTUAL_ESP_PART_SIZE
      else
        general_uefi_part_size=$esp_part_size
      fi
      ;;
  esac

  if [ -n "${image_encrypted+x}" ]; then
    image_luks_part_size=$(calculate_luks_part_size)
  elif [ -n "${image_lvm_rootfs+x}" ]; then
    image_lvm_part_size=$(calculate_lvm_vg_size)
  else
    image_root_part_size=$(calculate_root_part_size)
  fi

  image_boot_part_size=$(calculate_boot_part_size)

  if [ "$image_boot_type" = "uefi" ]; then
    image_uefi_part_size=$(calculate_uefi_part_size)
  fi
}
