#!/bin/sh -u
# shellcheck disable=SC1117,SC2039

#############################################################################
##
##  image-functions
##
##  Copyright 2021-2022 Dermot Bradley <dermot_bradley@yahoo.com>
##
##  Licensed via GPL version 2.0
##
#############################################################################


#
# Additional OS configuration
#
additional_os_configuration() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Doing additional OS configuration"
	{
	  # FIXUP: stop update-ca-certificates displaying a warning
	  sed -i \
	    -e 's|/etc/ssl/certs|/etc/ssl/certs 2>/dev/null|' \
	    /etc/ca-certificates/update.d/certhash
	EOF

  case $image_auth_control in
    doas | both )
      cat <<'EOF' >> "$run_script"

  write_log "Adding doas configuration for wheel group" 2
  cat <<-_SCRIPT_ > /etc/doas.d/00-configure-wheel-group.conf
	#
	# Allow members of group wheel to become root
	#
	permit persist :wheel
	_SCRIPT_
EOF
      ;;
  esac

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Basic OS configuration
#
basic_os_configuration() {
  local _color_prompt_file _login_banner

  cat <<-'EOF' >> "$run_script"
	
	write_log "Doing basic OS configuration"
	{
	  write_log "Setting the login message to be 'vague'" 2
	  {
	    printf '\nWelcome\n\n' > /etc/issue
	EOF

  case $image_class in
    cloud )
      _login_banner="Alpine $image_arch $image_cloud_type Cloud server"
      ;;
    physical )
      if [ "$image_physical_type" = "pc" ]; then
        _login_banner="Alpine $image_arch PC server"
      elif [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
        _login_banner="Alpine $image_arch Raspberry Pi server"
      fi
      ;;
    virtual )
      _login_banner="Alpine $image_arch $image_vm_type VM server"
      ;;
  esac

  cat <<-EOF >> "$run_script"
	    printf '\n\n$_login_banner\n\n' > /etc/motd
	  }
	EOF

  cat <<-'EOF' >> "$run_script"
	
	  write_log "Setting the keymap to '\$keymap'" 2
	  setup-keymap \$keymap >> "/chroot.log" 2>&1
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    cp /etc/profile.d/locale.sh /etc/profile.d/locale.sh-orig
	  }
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	
	  write_log "Setting locale to \$locale.UTF-8" 2
	  sed -i -E -e "s/^(export LANG=)C.UTF-8/\1\$locale.UTF-8/" \
	    /etc/profile.d/locale.sh
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    diff /etc/profile.d/locale.sh-orig /etc/profile.d/locale.sh \
	      >> /chroot.log || true
	    rm /etc/profile.d/locale.sh-orig
	
	    cp /etc/rc.conf /etc/rc.conf-orig
	  }
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	
	  write_log "Set OpenRC to log init.d start/stop sequences" 2
	  sed -i -e 's|[#]rc_logger=.*|rc_logger="YES"|g' /etc/rc.conf
	
	  write_log "Configure /etc/init.d/bootmisc to keep previous copy of dmesg logfile" 2
	  sed -i -e 's|[#]previous_dmesg=.*|previous_dmesg=yes|g' /etc/conf.d/bootmisc
	EOF

  case $image_alpine_release in
    v3.13 | v3.14 | v3.15 )
      cat <<-'EOF' >> "$run_script"
	
	  write_log "Create dummy dmesg logfile to workaround openrc bug" 2
	  touch /var/log/dmesg
	EOF
      ;;
  esac

  cat <<-'EOF' >> "$run_script"
	
	  write_log "Fixup rc.conf so that keyboards and screens use Unicode" 2
	  sed -i -e 's/^#unicode="NO"/unicode="YES"/' /etc/rc.conf
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    diff /etc/rc.conf-orig /etc/rc.conf >> /chroot.log || true
	    rm /etc/rc.conf-orig
	  }
	EOF
  fi

  case $image_alpine_release in
    v3.13 )
      _color_prompt_file="color_prompt" ;;
    * )
      _color_prompt_file="color_prompt.sh.disabled" ;;
  esac

  cat <<-EOF >> "$run_script"
	
	  write_log "Enable colour shell prompt" 2
	  cp /etc/profile.d/${_color_prompt_file} /etc/profile.d/color_prompt.sh
	EOF

  if [ "$image_class" != "virtual" ] || [ "$image_vm_type" != "vmware" ]; then
    cat <<-EOF >> "$run_script"
	
	  rmdir /media/floppy
	EOF
  fi

  cat <<-EOF >> "$run_script"
	}
	EOF
}


#
# Disable a set of specified kernel modules
#
blacklist_list_of_kernel_modules() {
  local _modules_section=$1
  local _modules_blacklist="$2"

  cat <<-EOF >> "$run_script"
	
	write_log "Blacklisting ${_modules_section} kernel modules" 2
	{
	  cat <<-_SCRIPT_ > /etc/modprobe.d/blacklist-${_modules_section}-modules.conf
	EOF

  for MODULE_NAME in $_modules_blacklist; do
    cat <<EOF >> "$run_script"
	blacklist ${MODULE_NAME}
EOF
  done

  cat <<'EOF' >> "$run_script"
	_SCRIPT_
EOF

  cat <<-EOF >> "$run_script"
	
	  sort -u -o /etc/modprobe.d/blacklist-${_modules_section}-modules.conf \\
	    /etc/modprobe.d/blacklist-${_modules_section}-modules.conf
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-EOF >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "Contents of blacklist-${_modules_section}-modules.conf:" 4
	    cat /etc/modprobe.d/blacklist-${_modules_section}-modules.conf >> /chroot.log
	  }
	EOF
  fi

  cat <<-EOF >> "$run_script"
	}
	EOF
}


#
# Calculate size of the boot partition if it is required.
#
calculate_boot_part_size() {
  local _fs_total_size _size

  local _reserved_percent=0

  if [ -n "${needs_boot_partition+x}" ]; then
    _fs_total_size=$((general_boot_part_size))
    case $image_fs_type in
      ext4 )
        _reserved_percent=$CONSTANT_EXT4_RESERVED_PERCENT ;;
      f2fs )
        _reserved_percent=$CONSTANT_F2FS_RESERVED_PERCENT ;;
      xfs )
        _reserved_percent=$CONSTANT_XFS_RESERVED_PERCENT ;;
    esac

    if [ $_reserved_percent -gt 0 ]; then
      _size=$((_fs_total_size + (_fs_total_size * _reserved_percent / 100)))
    else
      _size=$_fs_total_size
    fi
  fi

  echo "${_size:-0}"
}


#
# Calculate size of the resultant disk image taking into account
# whether bootloader, boot and cloud-init partitions are needed.
#
calculate_image_size() {
  local _image_total_size

  if [ -n "${debug_enabled+x}" ]; then
    # Initialise disk sizing debug file
    :> debug
  fi

  if [ -n "${image_encrypted+x}" ]; then
    # LUKS (including LVM-on-LUKS)
    _image_total_size=$(($(calculate_luks_part_size)))
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_image_size, initial image size for LUKS is $_image_total_size MiB" >> debug
    fi
  elif [ -n "${image_lvm_rootfs+x}" ]; then
    # LVM
    _image_total_size=$(($(calculate_lvm_vg_size) + 4))
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_image_size, initial image size for LVM (including 4MiB rounding) is $_image_total_size MiB" >> debug
    fi
  else
    _image_total_size=$(calculate_root_part_size)
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_image_size, initial image size is $_image_total_size MiB" >> debug
    fi
  fi

  if [ "$image_class" = "physical" ] && \
     [ "$image_cloud_software" = "cloud-init" ]; then
    _image_total_size="$((_image_total_size + CONSTANT_CIDATA_PART_SIZE))"
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_image_size, adding on CIDATA partition, giving $_image_total_size MiB" >> debug
    fi
  fi

  if [ -n "${needs_boot_partition+x}" ]; then
    _image_total_size="$((_image_total_size + $(calculate_boot_part_size)))"
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_image_size, adding on Boot partition, giving $_image_total_size MiB" >> debug
    fi
  fi

  case $image_boot_type in
    bios )
      # Allow for 2MiB boot sector
      _image_total_size="$((_image_total_size + 2))"
      if [ -n "${debug_enabled+x}" ]; then
        echo "calculate_image_size, added on 1MiB for boot sector, giving $_image_total_size MiB" >> debug
      fi
      ;;
    uefi )
      _image_total_size="$((_image_total_size + $(calculate_uefi_part_size)))"
      if [ -n "${debug_enabled+x}" ]; then
        echo "calculate_image_size, adding on ESP partition, giving $_image_total_size MiB" >> debug
      fi
      ;;
  esac

  echo "$_image_total_size"
}


#
# Calculate size of the LUKS partition taking into account whether
# separate boot partition is not needed (so boot files add to size).
#
calculate_luks_part_size() {
  local _luks_total_size _size

  local _reserved_percent=0

  _luks_total_size=$general_root_part_size
  if [ -n "${debug_enabled+x}" ]; then
    echo "calculate_luks_part_size, initial LUKS partition is $_luks_total_size MiB" >> debug
  fi

  if [ -z "${needs_boot_partition+x}" ]; then
    _luks_total_size=$((_luks_total_size + general_boot_part_size))
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_luks_part_size, no boot partition so adding boot files, size is $_luks_total_size MiB" >> debug
    fi
  fi

  case $image_fs_type in
    ext4 )
      _reserved_percent=$CONSTANT_EXT4_RESERVED_PERCENT ;;
    f2fs )
      _reserved_percent=$CONSTANT_F2FS_RESERVED_PERCENT ;;
    xfs )
      _reserved_percent=$CONSTANT_XFS_RESERVED_PERCENT ;;
  esac

  if [ $_reserved_percent -gt 0 ]; then
    _size=$((_luks_total_size + (_luks_total_size * _reserved_percent / 100)))
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_luks_part_size, allowing for $_reserved_percent% reserved space, size is $_size MiB" >> debug
    fi
  else
    _size=$_luks_total_size
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_luks_part_size, size is $_size MiB" >> debug
    fi
  fi


  if [ -n "${image_lvm_rootfs+x}" ]; then
    # LVM-on-LUKS
    _size=$((_size + (_size * CONSTANT_LVM_OVERHEAD_PERCENT / 100) + 4))
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_luks_part_size, allowing for LVM overhead, size is $_size MiB" >> debug
    fi
  fi

  # add LUKS overhead, rounding up to nearest 4MiB
  _size=$((_size + (_size * CONSTANT_LUKS_OVERHEAD_PERCENT / 100)))
  _size=$(lvm_round_extents $_size)
  if [ -n "${debug_enabled+x}" ]; then
    echo "calculate_luks_part_size, allowing for LUKS overhead, size is $_size MiB" >> debug
  fi

  echo "$_size"
}


#
# Calculate size of the LVM boot LV.
#
calculate_lvm_boot_lv_size() {
  local _boot_total_size _lv_total_size

  local _reserved_percent=0

  _boot_total_size=$general_boot_part_size
  if [ -n "${debug_enabled+x}" ]; then
    echo "calculate_lvm_boot_lv_size, initial Boot LV size is $_boot_total_size MiB" >> debug
  fi

  case $image_fs_type in
    ext4 )
      _reserved_percent=$CONSTANT_EXT4_RESERVED_PERCENT ;;
    f2fs )
      _reserved_percent=$CONSTANT_F2FS_RESERVED_PERCENT ;;
    xfs )
      _reserved_percent=$CONSTANT_XFS_RESERVED_PERCENT ;;
  esac

  if [ $_reserved_percent -gt 0 ]; then
    _boot_total_size=$((_boot_total_size + (_boot_total_size * $_reserved_percent / 100)))
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_lvm_boot_lv_size, allowing for $_reserved_percent% reserved space, size is $_boot_total_size MiB" >> debug
    fi
  fi

  # Round up to next extent
  _lv_total_size=$(lvm_round_extents $_boot_total_size)
  if [ -n "${debug_enabled+x}" ]; then
    echo "calculate_lvm_boot_lv_size, rounding up to next extent, size is $_lv_total_size MiB" >> debug
  fi
  echo "$_lv_total_size"
}


#
# Calculate size of the LVM logs LV.
#
calculate_lvm_logs_lv_size() {
  local _logs_total_size _lv_total_size

  local _reserved_percent=0

  _logs_total_size=$CONSTANT_LVM_LOGS_LV_SIZE
  if [ -n "${debug_enabled+x}" ]; then
    echo "calculate_lvm_logs_lv_size, initial Logs LV size is $_logs_total_size MiB" >> debug
  fi

  case $image_fs_type in
    ext4 )
      _reserved_percent=$CONSTANT_EXT4_RESERVED_PERCENT ;;
    f2fs )
      _reserved_percent=$CONSTANT_F2FS_RESERVED_PERCENT ;;
    xfs )
      _reserved_percent=$CONSTANT_XFS_RESERVED_PERCENT ;;
  esac

  if [ $_reserved_percent -gt 0 ]; then
    _logs_total_size=$((_logs_total_size + (_logs_total_size * _reserved_percent / 100)))
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_lvm_logs_lv_size, allowing for $_reserved_percent% reserved space, size is $_logs_total_size MiB" >> debug
    fi
  fi

  # Round up to next extent
  _lv_total_size=$(lvm_round_extents $_logs_total_size)
  if [ -n "${debug_enabled+x}" ]; then
    echo "calculate_lvm_logs_lv_size, rounding up to next extent, size is $_lv_total_size MiB" >> debug
  fi
  echo "$_lv_total_size"
}


#
# Calculate size of the LVM root LV.
#
calculate_lvm_root_lv_size() {
  local _root_total_size _lv_total_size

  local _reserved_percent=0

  _root_total_size=$general_root_part_size
  if [ -n "${debug_enabled+x}" ]; then
    echo "calculate_lvm_root_lv_size, initial Root LV size is $_root_total_size MiB" >> debug
  fi

  case $image_fs_type in
    ext4 )
      _reserved_percent=$CONSTANT_EXT4_RESERVED_PERCENT ;;
    f2fs )
      _reserved_percent=$CONSTANT_F2FS_RESERVED_PERCENT ;;
    xfs )
      _reserved_percent=$CONSTANT_XFS_RESERVED_PERCENT ;;
  esac

  if [ $_reserved_percent -gt 0 ]; then
    _root_total_size=$((_root_total_size + (_root_total_size * _reserved_percent / 100)))
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_lvm_root_lv_size, allowing for $_reserved_percent% reserved space, size is $_root_total_size MiB" >> debug
    fi
  fi

  # Round up to next extent
  _lv_total_size=$(lvm_round_extents $_root_total_size)
  if [ -n "${debug_enabled+x}" ]; then
    echo "calculate_lvm_root_lv_size, rounding up to next extend, size is $_lv_total_size MiB" >> debug
  fi
  echo "$_lv_total_size"
}


#
# Calculate size of the LVM partition taking into account whether
# separate boot partition is not needed (so boot files add to size).
#
calculate_lvm_vg_size() {
  local _boot_total_size _root_total_size _logs_total_size _vg_total_size

  if [ -z "${needs_boot_partition+x}" ]; then
    _boot_total_size=$(calculate_lvm_boot_lv_size)
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_lvm_vg_size, Boot LV size is $_boot_total_size MiB" >> debug
    fi
  fi
  _root_total_size=$(calculate_lvm_root_lv_size)
  _logs_total_size=$(calculate_lvm_logs_lv_size)
  if [ -n "${debug_enabled+x}" ]; then
    echo "calculate_lvm_vg_size, Root LV size is $_root_total_size MiB" >> debug
    echo "calculate_lvm_vg_size, Logs LV size is $_logs_total_size MiB" >> debug
  fi

  if [ -n "${needs_boot_partition+x}" ]; then
    _vg_total_size=$((_root_total_size + _logs_total_size))
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_lvm_vg_size, adding Root+Logs LVs gives VG total size of $_vg_total_size MiB" >> debug
    fi
  else
    _vg_total_size=$((_boot_total_size + _root_total_size + _logs_total_size))
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_lvm_vg_size, adding Boot+Root+Logs LVs gives VG total size of $_vg_total_size MiB" >> debug
    fi
  fi
  echo "$_vg_total_size"
}


#
# Calculate size of the root partition taking into account whether
# separate boot partition is not needed (so boot files add to size of root).
#
calculate_root_part_size() {
  local _fs_total_size

  local _reserved_percent=0

  _fs_total_size=$general_root_part_size
  if [ -z "${needs_boot_partition+x}" ]; then
    _fs_total_size=$((_fs_total_size + general_boot_part_size))
  fi

  case $image_fs_type in
    ext4 )
      _reserved_percent=$CONSTANT_EXT4_RESERVED_PERCENT ;;
    f2fs )
      _reserved_percent=$CONSTANT_F2FS_RESERVED_PERCENT ;;
    xfs )
      _reserved_percent=$CONSTANT_XFS_RESERVED_PERCENT ;;
  esac

  if [ $_reserved_percent -gt 0 ]; then
    _fs_total_size=$((_fs_total_size + (_fs_total_size * _reserved_percent / 100 + 1)))
  fi

  echo "$_fs_total_size"
}


#
# Calculate size of the UEFI ESP partition taking into account if it will
# also contain boot files.
#
calculate_uefi_part_size() {
  local _fs_total_size

  _fs_total_size=$((general_uefi_part_size))

  if [ "$image_bootloader" = "syslinux" ]; then
    # There is size of boot files to account for when
    # using Syslinux as then EFI partition is also /boot.
    _fs_total_size="$((_fs_total_size + general_boot_part_size))"
  fi

  echo "$_fs_total_size"
}


#
# Place entries in /etc/fstab for various filesystems
#
configure_fstab() {
  local _boot_mount_options _logs_mount_options _mountpoint
  local _root_mount_options

  cat <<-'EOF' >> "$run_script"
	
	write_log "Add /etc/fstab entries"
	{
	EOF

  if [ "$image_tmp_on_tmpfs" = true ]; then
    # Set /tmp to be a tmpfs mount
    cat <<-'EOF' >> "$run_script"
	  add_fstab_entry DEVICE "tmpfs" "/tmp" "tmpfs" "nosuid,nodev" "/tmp on tmpfs"
	EOF
  fi

  # Root filesystem
  _root_mount_options="rw,relatime"
  case $image_fs_type in
    btrfs )
      case $image_os_device_media in
        flash | sd | ssd )
          # Sync every 5 minutes, rather than the default of every 5 seconds,
          # to reduce writes to flash/SSD storage.
          _root_mount_options="$_root_mount_options,commit=300" ;;
      esac
      ;;
    ext4 )
      case $image_os_device_media in
        flash | sd | ssd )
          # Sync every 5 minutes, rather than the default of every 5 seconds,
          # to reduce writes to flash/SSD storage.
          _root_mount_options="$_root_mount_options,commit=300" ;;
      esac
      ;;
  esac
  if [ -n "${image_encrypted+x}" ]; then
    if [ -n "${image_lvm_rootfs+x}" ]; then
      cat <<-EOF >> "$run_script"
	  add_fstab_entry DEVICE "/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_ROOT_LV_NAME}" "/" "$image_fs_type" "$_root_mount_options" "rootfs"
	EOF
    else
      cat <<-EOF >> "$run_script"
	  add_fstab_entry DEVICE "/dev/mapper/${CONSTANT_LUKS_DEVICE_NAME}" "/" "$image_fs_type" "$_root_mount_options" "rootfs"
	EOF
    fi
  elif [ -n "${image_lvm_rootfs+x}" ]; then
    cat <<-EOF >> "$run_script"
	  add_fstab_entry DEVICE "/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_ROOT_LV_NAME}" "/" "$image_fs_type" "$_root_mount_options" "rootfs"
	EOF
  else
    if [ "$image_class" = "physical" ] && \
       [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
      # RPI
      cat <<-EOF >> "$run_script"
	  add_fstab_entry LABEL "$CONSTANT_ROOTFS_LABEL" "/" "$image_fs_type" "$_root_mount_options" "rootfs"
	EOF
    else
      # Non-RPI
      case $image_boot_reference in
        label )
          cat <<-EOF >> "$run_script"
	  add_fstab_entry LABEL "$CONSTANT_ROOTFS_LABEL" "/" "$image_fs_type" "$_root_mount_options" "rootfs"
	EOF
          ;;
        * )
          cat <<-EOF >> "$run_script"
	  add_fstab_entry UUID "\$root_fs_uuid" "/" "$image_fs_type" "$_root_mount_options" "rootfs"
	EOF
          ;;
      esac
    fi
  fi

  # UEFI ESP
  case $image_boot_type in
    uefi )
      _mountpoint="/efi"

      case $image_boot_reference in
        label )
          cat <<-EOF >> "$run_script"
	  add_fstab_entry LABEL "$CONSTANT_ESP_FS_LABEL" "${_mountpoint}" "vfat" "rw" "ESP filesystem"
	EOF
          ;;
        * )
          cat <<-EOF >> "$run_script"
	  add_fstab_entry UUID "\$esp_fs_uuid" "${_mountpoint}" "vfat" "rw" "ESP filesystem"
	EOF
          ;;
      esac

      if [ "$image_bootloader" = "syslinux" ]; then
        cat <<-'EOF' >> "$run_script"
	  add_fstab_entry BIND "/efi/EFI/BOOT" "/boot" "none" "rw,relatime" "/boot ESP bind-mount"
	EOF
      fi
      ;;
  esac

  # /boot
  if [ -n "${needs_boot_partition+x}" ]; then
    _boot_mount_options="rw,relatime"

    if [ "$image_class" = "physical" ] && \
       [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
      # RPI 2, 3, or 4
      add_rpi_boot_fstab_entries "$_boot_mount_options"
    else
      # Not RPI 2, 3, or 4
      case $image_fs_type in
        btrfs )
          case $image_os_device_media in
            flash | sd | ssd )
              # Sync every 5 minutes, rather than the default of every 5 seconds,
              # to reduce writes to flash storage.
              _boot_mount_options="$_boot_mount_options,commit=300"
          esac
          ;;
        ext4 )
          case $image_os_device_media in
            flash | sd | ssd )
              # Sync every 5 minutes, rather than the default of every 5 seconds,
              # to reduce writes to flash storage.
              _boot_mount_options="$_boot_mount_options,commit=300"
          esac
          ;;
      esac
      if [ "$image_boot_reference" = "label" ]; then
        cat <<-EOF >> "$run_script"
	  add_fstab_entry LABEL "$CONSTANT_BOOTFS_LABEL" "/boot" "$image_fs_type" "$_boot_mount_options" "boot"
	EOF
      else
        cat <<-EOF >> "$run_script"
	  add_fstab_entry UUID "\$boot_fs_uuid" "/boot" "$image_fs_type" "$_boot_mount_options" "boot"
	EOF
      fi
    fi

  elif [ -n "${image_lvm_rootfs+x}" ] && [ -z "${needs_boot_partition+x}" ]; then
    _boot_mount_options="rw,relatime"

    if [ "$image_fs_type" = "ext4" ]; then
      case $image_os_device_media in
        flash | sd | ssd )
          # Sync every 5 minutes, rather than the default of every 5 seconds,
          # to reduce writes to flash storage.
          _boot_mount_options="$_boot_mount_options,commit=300" ;;
      esac
    fi

    cat <<-EOF >> "$run_script"
	  add_fstab_entry DEVICE "/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_BOOT_LV_NAME}" "/boot" "$image_fs_type" "$_boot_mount_options" "boot"
	EOF
  fi

  # logs filesystem
  if [ -n "${image_lvm_rootfs+x}" ]; then
    _logs_mount_options="rw,relatime"
    if [ "$image_fs_type" = "ext4" ]; then
      case $image_os_device_media in
        flash | sd | ssd )
          # Sync every 5 minutes, rather than the default of every 5
          # seconds to reduce writes to flash storage.
          _logs_mount_options="$_logs_mount_options,commit=300" ;;
      esac
    fi

    cat <<-EOF >> "$run_script"
	  add_fstab_entry DEVICE "/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_LOGS_LV_NAME}" "/var/log" "$image_fs_type" "$_logs_mount_options" "logsfs"
	EOF
  fi

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "Resultant /etc/fstab contents:" 2
	    cat /etc/fstab >> "/chroot.log"
	  }
	EOF
  fi

  cat <<-EOF >> "$run_script"
	}
	EOF
}


#
# Copy LUKS keyfile into place
#
copy_luks_keyfile_into_place() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Moving LUKS keyfile into chroot directory" 2
	{
	  mv crypto_keyfile.bin "$chroot_dir"/
	  chmod 400 "$chroot_dir"/crypto_keyfile.bin
	}
	EOF
}


#
# Create /etc/filesystems for Busybox mount
#
create_etc_filesystems() {
  local _config_fs_type=$1

  # Busybox mount command requires the following config

  cat <<-EOF >> "$run_script"
	
	  write_log "Setting up /etc/filesystems for $_config_fs_type mount" 2
	  {
	EOF

  cat <<EOF >> "$run_script"
    cat <<-_SCRIPT_ > /etc/filesystems
	#
	# /etc/filesystems
	#
	
	# Needed for cloud-init cidata $_config_fs_type
EOF

  if [ "$_config_fs_type" = "ISO" ]; then
    cat <<'EOF' >> "$run_script"
	iso9660
	_SCRIPT_
EOF
  else
    cat <<'EOF' >> "$run_script"
	vfat
	_SCRIPT_
EOF
  fi

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "/etc/filesystems content:" 4
	      cat /etc/filesystems >> /chroot.log
	    }
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create an init.d script for preventing the loading of kernel modules
#
create_module_blocking_initd() {
  cat <<'EOF' >> "$run_script"

write_log "Creating init.d script for disabling kernel module loading" 2
{
  cat <<-_SCRIPT_ > /etc/init.d/block-modules-loading
	#!/sbin/openrc-run
	
	description="Disable loading of kernel modules"
	
	depend() {
		after *
		keyword -openvz -prefix -uml -vserver -xenu -lxc
	}
	
	start() {
		ebegin "Disabling loading of kernel modules"
		sysctl -q -w kernel.modules_disabled=1
		eend $?
	}
	_SCRIPT_
  chmod a+x /etc/init.d/block-modules-loading

  {
EOF

  add_init_d_service "block-modules-loading" "default" 4

  cat <<-'EOF' >> "$run_script"
	  } >> /chroot.log 2>&1
	EOF

  if [ "$image_class" = "virtual" ] && [ "$image_vm_type" = "virtualbox" ]; then

    if [ -n "${debug_enabled+x}" ]; then
      cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    cp /etc/init.d/virtualbox-guest-additions \
	      /etc/init.d/virtualbox-guest-additions-orig
	  }
	EOF
    fi

    cat <<-'EOF' >> "$run_script"
	
	  # Disable the module removal upon stop as otherwise this will give an error
	  sed -i -E -e 's|^(.*/sbin/modprobe -r .*)$|#\1|g' \
	    /etc/init.d/virtualbox-guest-additions
	EOF

    if [ -n "${debug_enabled+x}" ]; then
      cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "/etc/init.d/virtualbox-guest-additions differences:" 2
	    diff /etc/init.d/virtualbox-guest-additions-orig \
	      /etc/init.d/virtualbox-guest-additions >> /chroot.log || true
	    rm /etc/init.d/virtualbox-guest-additions-orig
	  }
	EOF
    fi
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Define list of packages in addition to base Alpine
#
define_additional_packages() {
  local _initial_pkgs

  _initial_pkgs="ca-certificates chrony htop kbd-bkeymaps logrotate"
  _initial_pkgs="$_initial_pkgs musl-locales rng-tools sshguard"
  case $image_alpine_release in
    v3.13 | v3.14 | v3.15 )
      # These releases do not have suitable acct package
      : ;;
    * )
      _initial_pkgs="$_initial_pkgs acct" ;;
  esac

  case $image_cloud_software in
    cloud-init )
      _initial_pkgs="$_initial_pkgs cloud-init"
      # Fudge!
      _initial_pkgs="$_initial_pkgs dhclient"
      if [ "${image_mdev}" = false ]; then
        _initial_pkgs="$_initial_pkgs eudev"
      fi
      ;;
    none )
      _initial_pkgs="$_initial_pkgs $(define_non_cloud_init_packages)"
      if [ "${image_mdev}" = false ]; then
        _initial_pkgs="$_initial_pkgs eudev"
      fi
      case $image_dhcp_client in
        dhclient )
          _initial_pkgs="$_initial_pkgs dhclient" ;;
        dhcpcd )
          _initial_pkgs="$_initial_pkgs dhcpcd" ;;
      esac
      ;;
    tiny-cloud )
      _initial_pkgs="$_initial_pkgs $(define_tiny_cloud_packages)"
      ;;
  esac

  case $image_auth_control in
    doas )
      _initial_pkgs="$_initial_pkgs doas" ;;
    sudo )
      _initial_pkgs="$_initial_pkgs sudo" ;;
    both )
      _initial_pkgs="$_initial_pkgs doas sudo" ;;
  esac

  if [ -n "${image_enable_utmp+x}" ]; then
    _initial_pkgs="$_initial_pkgs procps utmps"
  fi

  if [ -n "${image_encrypted+x}" ]; then
    _initial_pkgs="$_initial_pkgs cryptsetup"
    if [ -n "${image_experimental+x}" ] && \
       [ -n "${remote_unlock_enabled+x}" ]; then
      _initial_pkgs="$_initial_pkgs dropbear-convert dropbear-unlockdisk"
    fi
  fi

  if [ -n "${image_lvm_rootfs+x}" ]; then
    _initial_pkgs="$_initial_pkgs lvm2"
  fi

  if [ -n "${image_encrypted+x}" ] || \
     [ -n "${image_lvm_rootfs+x}" ]; then
    _initial_pkgs="$_initial_pkgs device-mapper"
  fi

  case $image_firewall in
    awall )
      _initial_pkgs="$_initial_pkgs awall awall-masquerade awall-policies"
      ;;
    iptables )
      _initial_pkgs="$_initial_pkgs iptables"
      if [ -z "${image_disable_ipv6+x}" ]; then
        _initial_pkgs="$_initial_pkgs ip6tables"
      fi
      ;;
    nftables )
      _initial_pkgs="$_initial_pkgs nftables"
      ;;
  esac

  case $image_fs_type in
    btrfs )
      _initial_pkgs="$_initial_pkgs btrfs-progs btrfs-progs-extra" ;;
    ext4 )
      _initial_pkgs="$_initial_pkgs e2fsprogs-extra" ;;
    f2fs )
      _initial_pkgs="$_initial_pkgs f2fs-tools" ;;
    xfs )
      _initial_pkgs="$_initial_pkgs xfsprogs xfsprogs-extra" ;;
  esac

  case $image_ssh_server in
    dropbear )
      _initial_pkgs="$_initial_pkgs dropbear" ;;
    openssh )
      if [ "$image_cloud_software" = "cloud-init" ] || \
         [ -n "${image_pam_enabled+x}" ]; then
        _initial_pkgs="$_initial_pkgs openssh-server-pam"
      else
        _initial_pkgs="$_initial_pkgs openssh-server"
      fi
      ;;
    tinyssh )
      _initial_pkgs="$_initial_pkgs tinyssh openssh-sftp-server" ;;
  esac

  case $image_syslog_server in
    rsyslog )
      _initial_pkgs="$_initial_pkgs rsyslog" ;;
  esac

  case $image_class in
    cloud )
      case $image_cloud_software in
        cloud-init )
          _initial_pkgs="${_initial_pkgs} $(define_cloud_init_machine_packages)" ;;
        none )
          ;;
        tiny-cloud )
          _initial_pkgs="${_initial_pkgs} $(define_tiny_cloud_machine_packages)" ;;
      esac
			;;
    physical )
      _initial_pkgs="${_initial_pkgs} $(define_physical_machine_packages)" ;;
    virtual )
      _initial_pkgs="${_initial_pkgs} $(define_virtual_machine_packages)" ;;
  esac

  echo "$_initial_pkgs"
}


#
# Delete unnecessary users & groups
#
delete_users_groups() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Delete unnecessary users and groups"
	{
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	  # Debug
	  {
	    cp /etc/group /etc/group-orig
	    cp /etc/passwd /etc/passwd-orig
	EOF

    if [ "$image_mdev" = false ]; then
      cat <<-'EOF' >> "$run_script"
	
	    cp /lib/udev/rules.d/50-udev-default.rules \
	      /lib/udev/rules.d/50-udev-default.rules-orig
	EOF
    fi

    cat <<-'EOF' >> "$run_script"
	  }
	
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	  write_log "Delete unnecessary users" 2
	  {
	    _unreq_users_list="cyrus ftp games guest halt lp man news ntp operator"
	    _unreq_users_list="\$_unreq_users_list postmaster shutdown smmsp squid"
	    _unreq_users_list="\$_unreq_users_list sync vpopmail xfs"
	
	    for _unrequired_user in \$_unreq_users_list
	    do
	      write_debug_log "Delete user '\$_unrequired_user'" 4
	      deluser \$_unrequired_user 2> /dev/null
	    done
	  }
	
	  {
	    _unreq_groups_list="abuild cdrw"
	
	    write_log "Delete unnecessary groups" 2
	    {
	      for _unrequired_group in \$_unreq_groups_list
	      do
	        write_debug_log "Delete group '\$_unrequired_group'" 4
	        delgroup \$_unrequired_group
	      done
	    }
	EOF

  if [ "$image_mdev" = false ]; then
    cat <<-'EOF' >> "$run_script"
	
	    write_log "Remove references to deleted groups from udev rules" 4
	    {
	      write_debug_log "Rewrite any wrapped lines into single lines" 6
	      sed -i -e ':x;/\\$/{N;s/\\\n//g;bx;}' -e 's/ [ ]*/ /g' \
	        /lib/udev/rules.d/50-udev-default.rules
	      for _unrequired_group in \$_unreq_groups_list
	      do
	        write_debug_log "Remove group \$_unrequired_group references" 6
	        sed -i -e "/^.*GROUP=\"\$_unrequired_group\".*$/d" \
	          /lib/udev/rules.d/50-udev-default.rules
	      done
	    }
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "Users differences:" 2
	    diff /etc/passwd-orig /etc/passwd >> /chroot.log || true
	
	    write_debug_log "Groups differences:" 2
	    diff /etc/group-orig /etc/group >> /chroot.log || true
	
	    rm /etc/group-orig /etc/passwd-orig
	EOF

    if [ "$image_mdev" = false ]; then
      cat <<-'EOF' >> "$run_script"
	
	    write_debug_log "50-udev-default.rules differences:" 2
	    diff /lib/udev/rules.d/50-udev-default.rules-orig \
	      /lib/udev/rules.d/50-udev-default.rules >> /chroot.log || true
	    rm /lib/udev/rules.d/50-udev-default.rules-orig
	EOF
    fi

  cat <<-'EOF' >> "$run_script"
	  }
	}
	EOF
  fi
}


#
# Disable non-server specific kernel modules
#
disable_kernel_modules() {
  local _disable_modules

  cat <<-'EOF' >> "$run_script"
	
	write_log "Disable non-server kernel modules"
	EOF

  # Drivers
  #---------

  _disable_modules="$CONSTANT_DESKTOP_KERNEL_MODULES"
  if [ "$image_class" != "physical" ] || \
     [ "$(expr "$image_physical_type" : '.*rpi.*')" -eq 0 ]; then
    _disable_modules="$_disable_modules $CONSTANT_VIRTUAL_XEN_KERNEL_MODULES"
  fi

  case $image_class in
    cloud )
      if [ "$image_cloud_type" != "aws" ] && \
         [ "$image_cloud_type" != "generic" ]; then
        _disable_modules="$_disable_modules $CONSTANT_CLOUD_AWS_KERNEL_MODULES"
      fi
      if [ "$image_cloud_type" != "azure" ] && \
         [ "$image_cloud_type" != "generic" ]; then
        _disable_modules="$_disable_modules $CONSTANT_CLOUD_AZURE_KERNEL_MODULES"
        _disable_modules="$_disable_modules $CONSTANT_AZURE_HYPERV_COMMON_KERNEL_MODULES"
      fi
      if [ "$image_cloud_type" != "google" ] && \
         [ "$image_cloud_type" != "generic" ]; then
        _disable_modules="$_disable_modules $CONSTANT_CLOUD_GOOGLE_KERNEL_MODULES"
      fi

      # Disable all VM modules
      _disable_modules="$_disable_modules vmwgfx $CONSTANT_VIRTUAL_KERNEL_MODULES"

      # PTP-related
      _disable_modules="$_disable_modules ptp ptp_vmw"
      case $image_cloud_type in
        generic )
          : ;;
        * )
        _disable_modules="$_disable_modules ptp_kvm" ;;
      esac
      ;;
    physical )
      _disable_modules="$_disable_modules $(disable_kernel_modules_on_physical)"
      ;;
    virtual )
      _disable_modules="$_disable_modules ptp"

      if [ "$image_vm_type" != "generic" ]; then
        # Not generic
        if [ "$image_vm_type" != "hyperv" ]; then
          _disable_modules="$_disable_modules $CONSTANT_VIRTUAL_HYPERV_KERNEL_MODULES"
          _disable_modules="$_disable_modules $CONSTANT_AZURE_HYPERV_COMMON_KERNEL_MODULES"
        fi
        case $image_vm_type in
          libvirtd | lxd | proxmox | qemu | utm )
            : ;;
          * )
            # Disable KVM/QEMU-derived modules
            _disable_modules="$_disable_modules ptp_kvm virtio_rng" ;;
        esac
        if [ "$image_vm_type" != "vmware" ]; then
          # Disable VMware modules
          _disable_modules="$_disable_modules $CONSTANT_VIRTUAL_VMWARE_KERNEL_MODULES"
        fi
        if [ "$image_vm_type" != "virtualbox" ] && \
           [ "$image_vm_type" != "vmware" ]; then
          _disable_modules="$_disable_modules vmwgfx"
        fi
      fi

      # Disable all cloud provider modules
      _disable_modules="$_disable_modules $CONSTANT_CLOUD_KERNEL_MODULES"
      ;;
  esac

  case $image_class in
    cloud | virtual )
      #_disable_modules="$_disable_modules ac battery"
      _disable_modules="$_disable_modules $CONSTANT_PHYSICAL_KERNEL_MODULES"
      #### 'tiny-power-button' is used on Cloud and VM images
      ###_disable_modules="$_disable_modules button"
      _disable_modules="$_disable_modules hid ehci_hcd ehci_pci ehci_platform"
      _disable_modules="$_disable_modules ohci_hcd ohci_pci ohci_platform"
      _disable_modules="$_disable_modules uhci_pci usbcore xhci_hcd xhci_pci"
      ;;
  esac

  blacklist_list_of_kernel_modules "drivers" "$_disable_modules"
  disable_list_of_kernel_modules "drivers" "$_disable_modules"


  # Net
  #-----

  _disable_modules="$CONSTANT_UNUSED_NET_KERNEL_MODULES"
  if [ "$image_class" = "virtual" ]; then
    # Virtual
    case $image_vm_type in
      vmware | generic )
        # Don't disable for VMware or generic
        : ;;
      * )
        _disable_modules="$_disable_modules $CONSTANT_NET_VMWARE_KERNEL_MODULES" ;;
    esac
  fi

  blacklist_list_of_kernel_modules "net" "$_disable_modules"
  disable_list_of_kernel_modules "net" "$_disable_modules"
}


#
# Disable a set of specified kernel modules
#
disable_list_of_kernel_modules() {
  local _modules_section=$1
  local _disable_list="$2"

  local _module_name

  cat <<-EOF >> "$run_script"
	
	write_log "Disabling ${_modules_section} kernel modules" 2
	{
	EOF

  cat <<-EOF >> "$run_script"
  cat <<-_SCRIPT_ > /etc/modprobe.d/disable-${_modules_section}-modules.conf
EOF

  for _module_name in $_disable_list; do
    cat <<EOF >> "$run_script"
	install ${_module_name} /bin/true
EOF
  done

  cat <<EOF >> "$run_script"
	_SCRIPT_
EOF

  cat <<-EOF >> "$run_script"
	  sort -u -o /etc/modprobe.d/disable-${_modules_section}-modules.conf \\
	    /etc/modprobe.d/disable-${_modules_section}-modules.conf
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-EOF >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "Contents of disable-${_modules_section}-modules.conf:" 4
	    cat /etc/modprobe.d/disable-${_modules_section}-modules.conf >> /chroot.log
	  }
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Create relevant filesystems for the disk image and mount these
# inside the chroot directory.
#
format_and_mount_fs() {
  local _boot_on _logs_on _root_on

  cat <<-'EOF' >> "$run_script"
	
	write_log "Formatting and mounting filesystems"
	{
	EOF

  # Format UEFI ESP filesystem if needed
  case $image_boot_type in
    uefi )
      cat <<-EOF >> "$run_script"
	  uefi_part_device="\${loop_device}p${uefi_part_num}"
	EOF
      format_esp_fs
      if [ "$image_boot_reference" = "uuid" ]; then
        cat <<-'EOF' >> "$run_script"
	  esp_fs_uuid="$(get_uuid_from_device "$uefi_part_device")"
	EOF
      fi
      cat <<-EOF >> "$run_script"
	
	EOF
      ;;
  esac

  # Format boot filesystem if needed
  if [ -n "${needs_boot_partition+x}" ]; then
    cat <<-EOF >> "$run_script"
	  boot_part_device="\${loop_device}p${boot_part_num}"
	EOF
    if [ "$image_class" = "physical" ] && \
       [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
      # RPI
      #
      # Ensure that RPI boot filesystem label is *not* called "boot" due to
      # https://github.com/raspberrypi/firmware/issues/1529
      format_fat_fs "\$boot_part_device" "RPI boot" "fat32" \
        "$CONSTANT_RPIBOOT_LABEL" "partition"
    else
      case $image_fs_type in
        btrfs )
          format_btrfs_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
            "partition" ;;
        ext4 )
          format_ext4_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
            "partition" ;;
        f2fs )
          format_f2fs_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
            "partition" ;;
        xfs )
          format_xfs_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
            "partition" ;;
      esac
      if [ "$image_boot_reference" = "uuid" ]; then
        cat <<-'EOF' >> "$run_script"
	  boot_fs_uuid="$(get_uuid_from_device "$boot_part_device")"
	EOF
      fi
    fi
    cat <<-EOF >> "$run_script"
	
	EOF
  fi

  # Format CIDATA filesystem if needed
  if [ "$image_class" = "physical" ] && \
     [ "$image_cloud_software" = "cloud-init" ]; then
    cat <<-EOF >> "$run_script"
	  cidata_part_device="\${loop_device}p${cidata_part_num}"
	EOF
    format_fat_fs "\$cidata_part_device" "CIDATA" "fat12" \
      "$CONSTANT_CIDATA_LABEL" "partition"

    cat <<-EOF >> "$run_script"
	
	EOF
  fi

  # Set fs device variables
  if [ -n "${image_encrypted+x}" ]; then
    # LUKS
    if [ -n "${image_lvm_rootfs+x}" ]; then
      _logs_on="LVM-on-LUKS device"
      _root_on="LVM-on-LUKS device"
      cat <<-EOF >> "$run_script"
	  root_part_device="/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_ROOT_LV_NAME}"
	  logs_part_device="/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_LOGS_LV_NAME}"
	EOF
      if [ "$image_class" != "physical" ] || \
         [ "$(expr "$image_physical_type" : '.*rpi.*')" -eq 0 ]; then
        # Not RPI (which has a separate non-LVM boto partition)
      _boot_on="LVM-on-LUKS device"
      cat <<-EOF >> "$run_script"
	  boot_part_device="/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_BOOT_LV_NAME}"
	EOF
      fi
    else
      _root_on="LUKS device"
      cat <<-EOF >> "$run_script"
	  root_part_device="/dev/mapper/$CONSTANT_LUKS_DEVICE_NAME"
	EOF
    fi
  elif [ -n "${image_lvm_rootfs+x}" ]; then
    # LVM
    _root_on="LVM logical volume"
    cat <<-EOF >> "$run_script"
	  root_part_device="/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_ROOT_LV_NAME}"
	EOF
    if [ "$image_bootloader" = "grub" ]; then
      _boot_on="LVM logical volume"
      cat <<-EOF >> "$run_script"
	  boot_part_device="/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_BOOT_LV_NAME}"
	EOF
    fi
    _logs_on="LVM logical volume"
    cat <<-EOF >> "$run_script"
	  logs_part_device="/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_LOGS_LV_NAME}"
	EOF
  else
    # neither LUKS nor LVM
    _root_on="partition"
    cat <<-EOF >> "$run_script"
	  root_part_device="\${loop_device}p${root_part_num}"
	EOF
  fi

  # Format root filesystem (and boot & logs LVs if needed)
  case $image_fs_type in
    btrfs )
      format_btrfs_fs "\$root_part_device" "root" "$CONSTANT_ROOTFS_LABEL" \
        "$_root_on"
      if [ -n "${image_lvm_rootfs+x}" ]; then
        # boot & logs LVs
        format_btrfs_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
          "$_boot_on"
        format_btrfs_fs "\$logs_part_device" "logs" "$CONSTANT_LOGSFS_LABEL" \
          "$_logs_on"
      fi
      ;;
    ext4 )
      format_ext4_fs "\$root_part_device" "root" "$CONSTANT_ROOTFS_LABEL" \
        "$_root_on"
      if [ -n "${image_lvm_rootfs+x}" ]; then
        if [ "$image_bootloader" = "grub" ]; then
          # boot LV
          format_ext4_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
            "$_boot_on"
        fi
        # logs LV
        format_ext4_fs "\$logs_part_device" "logs" "$CONSTANT_LOGSFS_LABEL" \
          "$_logs_on"
      fi
      ;;
    f2fs )
      format_f2fs_fs "\$root_part_device" "root" "$CONSTANT_ROOTFS_LABEL" \
        "$_root_on"
      if [ -n "${image_lvm_rootfs+x}" ]; then
        # boot and logs LVs
        format_f2fs_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
          "$_boot_on"
        format_f2fs_fs "\$logs_part_device" "logs" "$CONSTANT_LOGSFS_LABEL" \
          "$_logs_on"
      fi
      ;;
    xfs )
      format_xfs_fs "\$root_part_device" "root" "$CONSTANT_ROOTFS_LABEL" \
        "$_root_on"
      if [ -n "${image_lvm_rootfs+x}" ]; then
        # boot and logs LVs
        format_xfs_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
          "$_boot_on"
        format_xfs_fs "\$logs_part_device" "logs" "$CONSTANT_LOGSFS_LABEL" \
          "$_logs_on"
      fi
      ;;
  esac

  if [ "$image_boot_reference" = "uuid" ] && \
     { [ "$image_class" != "physical" ] || \
       [ "$(expr "$image_physical_type" : '.*rpi.*')" -eq 0 ]; } && \
     [ -z "${image_encrypted+x}" ] && \
     { [ -z "${image_lvm_rootfs+x}" ] || \
       [ "$image_bootloader" = "syslinux" ]; }; then
    cat <<-'EOF' >> "$run_script"
	  root_fs_uuid="$(get_uuid_from_device "$root_part_device")"
	EOF
  fi

  # Mount root filesystem
  cat <<-'EOF' >> "$run_script"
	
	  write_log "Mounting root filesystem onto $chroot_dir" 2
	  mkdir -p "$chroot_dir"
	  mount -o private "$root_part_device" "$chroot_dir" >> "$logfile" 2>&1
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-EOF >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "Size of root filesystem:" 2
	    df -BM "\$chroot_dir" >> "\$logfile"
	  }
	EOF
	fi

  # Mount UEFI ESP filesustem if necessary
  case $image_boot_type in
    uefi )
      cat <<-'EOF' >> "$run_script"
	
	  write_log "Mounting ESP filesystem onto $chroot_dir/efi" 2
	  mkdir -p "$chroot_dir"/efi
	  mount -o private "$uefi_part_device" "$chroot_dir"/efi >> "$logfile" 2>&1
	EOF

      if [ -n "${debug_enabled+x}" ]; then
        cat <<-EOF >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "Size of ESP filesystem:" 2
	    df -BM "\$chroot_dir"/efi >> "\$logfile"
	  }
	EOF
      fi
      ;;
  esac

  # Mount boot filesystem if necessary
  if [ -n "${needs_boot_partition+x}" ] || \
     { [ -n "${image_lvm_rootfs+x}" ] && \
       { [ "$image_bootloader" != "syslinux" ] || \
         [ "$image_boot_type" = "bios" ]; }; }; then
    # Needs a boot partition or else is LVM but not Syslinux-based UEFI
    # (where boot is part of ESP partition)
    cat <<-'EOF' >> "$run_script"
	
	  write_log "Mounting boot filesystem onto $chroot_dir/boot" 2
	  mkdir -p "$chroot_dir"/boot
	  mount -o private "$boot_part_device" "$chroot_dir"/boot >> "$logfile" 2>&1
	EOF

    if [ -n "${debug_enabled+x}" ]; then
      cat <<-EOF >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "Size of boot filesystem:" 2
	    df -BM "\$chroot_dir"/boot >> "\$logfile"
	  }
	EOF
  	fi
  elif [ "$image_boot_type" = "uefi" ] && \
       [ "$image_bootloader" = "syslinux" ]; then
    # When using Syslinux with UEFI then, as kernel & initramfs files need
    # to be in EFI/BOOT directory of ESP partition, EFI/BOOT directory of
    # ESP partition is bind-mounted to /boot. This ensures that kernel,
    # initramfs, and extlinux.conf files are in ESP partition.
    cat <<-'EOF' >> "$run_script"
	
	  write_log "Bind mounting ESP filesystem's EFI/BOOT onto $chroot_dir/boot" 2
	  mkdir -p "$chroot_dir"/efi/EFI/BOOT
	  mkdir -p "$chroot_dir"/boot
	  mount -t none -o bind "$chroot_dir"/efi/EFI/BOOT "$chroot_dir"/boot \
	    >> "$logfile" 2>&1
	EOF
  fi

  # Mount logs filesystem if necessary
  if [ -n "${image_lvm_rootfs+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  write_log "Mounting logs filesystem onto $chroot_dir/var/logs" 2
	  mkdir -p "$chroot_dir"/var/log
	  mount -o private "$logs_part_device" "$chroot_dir"/var/log >> "$logfile" 2>&1
	EOF

    if [ -n "${debug_enabled+x}" ]; then
      cat <<-EOF >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "Size of logs filesystem:" 2
	    df -BM "\$chroot_dir"/var/log >> "\$logfile"
	  }
	EOF
  	fi
  fi

  # Mount CIDATA filesystem if necessary
  if [ "$image_class" = "physical" ] && \
     [ "$image_cloud_software" = "cloud-init" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  write_log "Mounting cloud-init YAML filesystem onto $chroot_dir/cidata" 2
	  mkdir -p "$chroot_dir"/cidata
	  mount -o private "$cidata_part_device" "$chroot_dir"/cidata >> "$logfile"
	EOF

    if [ -n "${debug_enabled+x}" ]; then
      cat <<-EOF >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "Size of cloud-init YAML filesystem:" 2
	    df -BM "\$chroot_dir"/cidata >> "\$logfile"
	  }
	EOF
  	fi
  fi

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "Filesystems' UUIDs" 2
	    lsblk --ascii --fs "$loop_device" >> "$logfile" 2>&1
	    write_debug_log "Blkid output:" 2
	    lsblk \
	      --output NAME,FSTYPE,LABEL,UUID,FSSIZE,FSAVAIL,FSUSED,FSUSE%,MOUNTPOINT,PARTLABEL \
	      "$loop_device" >> "$logfile" 2>&1
	  }
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Create a BTRFS filesystem
#
format_btrfs_fs() {
  local device=$1
  local fs_use="$2"
  local label=$3
  local formatting_where="$4"

  cat <<-EOF >> "$run_script"
	
	  write_log "Formatting Btrfs $fs_use filesystem on $formatting_where" 2
	  mkfs.btrfs -q -L $label "$device" >> "\$logfile" 2>&1
	EOF
}


#
# Create a F2FS filesystem
#
format_f2fs_fs() {
  local device=$1
  local fs_use="$2"
  local label=$3
  local formatting_where="$4"

  cat <<-EOF >> "$run_script"
	
	  write_log "Formatting F2FS $fs_use filesystem on $formatting_where" 2
	  mkfs.f2fs -q -l $label "$device" >> "\$logfile" 2>&1
	EOF
}


#
# Create a FAT filesystem
#
format_fat_fs() {
  local device=$1
  local fs_use="$2"
  local fat_type=$3
  local fat_label="$4"
  local formatting_where="$5"

  case $fat_type in
    fat12 )
      fat_info_type="12"
      fat_mkfs_option="-F12 -s 1 -S 512"
      ;;
    fat16 )
      fat_info_type="16"
      fat_mkfs_option="-F16 -s 1 -S 512"
      ;;
    fat32 )
      fat_info_type="32"
      fat_mkfs_option="-F32"
      ;;
  esac

  cat <<-EOF >> "$run_script"
	
	  write_log "Formatting FAT${fat_info_type} $fs_use filesystem on $formatting_where" 2
	  mkfs.fat $fat_mkfs_option -n "$fat_label" "$device" >> "\$logfile" 2>&1
	EOF
}


#
# Create an XFS filesystem
#
format_xfs_fs() {
  local device=$1
  local fs_use="$2"
  local label=$3
  local formatting_where="$4"

  # Force attr=2 to avoid dmesg warning
  fs_options="-i attr=2"
  # Ensure XFS avoids Year 2038 problem.
  fs_options="$fs_options -m bigtime=1"

  cat <<-EOF >> "$run_script"
	
	  write_log "Formatting XFS $fs_use filesystem on $formatting_where" 2
	  mkfs.xfs -q -L $label $fs_options "$device" >> "\$logfile" 2>&1
	EOF
}


#
# Insert function define_cmdline_for_encryption into created script
#
insert_chroot_function_define_cmdline_for_encryption() {
  local _cmdline_list

  cat <<-'EOF' >> "$run_script"
	
	define_cmdline_for_encryption() {
	EOF

  _cmdline_list="cryptroot=UUID=\${luks_part_uuid} cryptdm=$CONSTANT_LUKS_DEVICE_NAME"

  if [ -n "${remote_unlock_enabled+x}" ]; then
    if [ -n "${remote_unlock_static_ip+x}" ]; then
      # Indicate the IP address to use by initramfs for configuring
      # the ethernet interface for Dropbear to listen on.
      _cmdline_list="$_cmdline_list ip=${remote_unlock_static_ip}::${remote_unlock_static_gateway:-}:${remote_unlock_static_netmask:-}::${remote_unlock_static_interface:-}:none:"
    else
      # Indicate that DHCP should be used by initramfs' init.
      _cmdline_list="$_cmdline_list ip=dhcp"
    fi

    # Indicate that Dropbear should be run by initramfs' init.
    _cmdline_list="$_cmdline_list remote_unlock_luks"

    if [ -n "${remote_unlock_ssh_port+x}" ]; then
      # Indicate the port that Dropbear should listen on
      _cmdline_list="$_cmdline_list remote_unlock_luks_ssh_port=$remote_unlock_ssh_port"
    fi
  fi

  cat <<-EOF >> "$run_script"
	  echo "$_cmdline_list"
	}
	EOF
}


#
# Install base Alpine system
#
install_alpine_base() {
  local _base_packages _bootloader_packages

  _base_packages="alpine-base"
  case $image_boot_type in
    uefi )
      _base_packages="$_base_packages efivar" ;;
  esac

  # Add the appropriate package for managing initramfs
  case $image_initramfs_tool in
    booster )
      _base_packages="$_base_packages booster" ;;
    mkinitfs )
      _base_packages="$_base_packages mkinitfs" ;;
  esac

  # Define bootloader-related packages
  case $image_bootloader in
    grub )
      _bootloader_packages="grub"
      case $image_boot_type in
        uefi )
          _bootloader_packages="$_bootloader_packages dosfstools grub-efi" ;;
        * )
          _bootloader_packages="$_bootloader_packages grub-bios" ;;
      esac
      ;;
    syslinux )
      _bootloader_packages="syslinux"
      if [ "$image_boot_type" = "uefi" ]; then
        _bootloader_packages="$_bootloader_packages dosfstools"
      fi
      ;;
    * )
      if [ "$image_class" = "physical" ] && \
         [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
        _bootloader_packages="dosfstools raspberrypi-bootloader-cutdown"
        case $image_alpine_release in
          v3.13 | v3.14 | v3.15 )
            # Prior to 3.16/Edge raspberrypi-common does not exist and so
            # raspberrypi-bootloader must also be installed.
            _bootloader_packages="$_bootloader_packages raspberrypi-bootloader" ;;
        esac
      else
        _bootloader_packages="none"
      fi
      ;;
  esac
  if [ "$_bootloader_packages" != "none" ]; then
    _base_packages="$_base_packages $_bootloader_packages"
  fi

  cat <<-EOF >> "$run_script"
	
	write_log "Bootloader packages to be installed are: $_bootloader_packages"
	
	write_log "Install base Alpine (plus bootloader packages) for ${image_arch} arch inside chroot"
	{
	  # shellcheck disable=SC2086
	  \$TMPDIR/apk.static \\
	    --arch "${image_arch}" --initdb --allow-untrusted --root \$chroot_dir \\
	    --update-cache \\
	    add ${_base_packages} \\
	    >> "\$logfile" 2>&1
	  _rc=\$?
	  if [ \$_rc != 0 ]; then
	    write_log "Failure while installing base Alpine, error code: \$_rc"
	    exit 1
	  fi
	
	  # Tidy-up after apk.static run
	  rm -f \$TMPDIR/apk.static
	  if [ -n "\${temp_ca_dir_created+x}" ] && \\
	     [ "\$temp_ca_dir_created" = "true" ]; then
	    echo "deleting the temporary CA directory"
	    rm -Rf /etc/apk
	  elif [ -n "\${temp_ca_file_created+x}" ] && \\
	     [ "\$temp_ca_file_created" = "true" ]; then
	    echo "deleting the temporary CA file"
	    rm -f /etc/apk/ca.pem
	  fi
	}
	EOF
}


#
# Insert function get_kernel_package_version into created script
#
insert_chroot_function_get_kernel_package_version() {
  local _kernel_package

  cat <<-'EOF' >> "$run_script"
	
	get_kernel_package_version() {
	EOF

  case $image_class in
    cloud | virtual )
      if [ "$image_kernel_type" = "edge" ]; then
        _kernel_package="edge4virt"
      else
        _kernel_package="virt"
      fi
      ;;
    physical )
      case $image_physical_type in
        pc )
          if [ "$image_kernel_type" = "edge" ]; then
            _kernel_package="edge"
          else
            _kernel_package="lts"
          fi
          ;;
        rpi2 | rpi3 )
          if [ "$image_arch" = "armv7" ]; then
            _kernel_package="rpi2"
          else
            _kernel_package="rpi"
          fi
          ;;
        rpi4 )
          _kernel_package="rpi4" ;;
      esac
      ;;
  esac

  cat <<-EOF >> "$run_script"
	  echo "\\\$(apk info linux-$_kernel_package | head -n 1 | sed -e "s/^linux-$_kernel_package-//" \\
	    -e 's/ .*//')"
	}
	EOF
}


#
# Insert functions into created script
#
insert_chroot_functions() {
  cat <<-'EOF' >> "$run_script"
	
	############################################################################
	##		Chroot Functions
	############################################################################
	EOF

  insert_chroot_function_add_fstab_entry
  if [ -n "${image_encrypted+x}" ]; then
    insert_chroot_function_define_cmdline_for_encryption
  fi
  insert_chroot_function_get_kernel_package_version
  insert_chroot_function_get_kernel_version
  insert_chroot_function_write_debug_log
  insert_chroot_function_write_log
}


#
# Install relevant firmware packages
#
install_firmware() {
  local _firmware_pkgs=""

  cat <<-'EOF' >> "$run_script"
	
	write_log "Selecting firmware packages to install"
	{
	EOF

  if [ "$image_class" = "physical" ]; then
    _firmware_pkgs="$(firmware_list_for_physical)"
  fi

  if [ "$_firmware_pkgs" = "" ]; then
    cat <<-EOF >> "$run_script"
	  write_log "No firmware required" 2
	EOF
  else
    cat <<-EOF >> "$run_script"
	  write_log "Installing firmware" 2
	  apk add $_firmware_pkgs >> /chroot.log 2>&1
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Install relevant kernel package
#
install_kernel() {
  local _firmware_pkg _kernel_pkg _kernel_config_file

  case $image_class in
    cloud | virtual )
      # Cloud or Virtual machine
      if [ "$image_kernel_type" = "edge" ]; then
        _kernel_pkg="linux-edge4virt"
        _kernel_config_file="config-edge4virt"
      else
        _kernel_pkg="linux-virt"
        _kernel_config_file="config-virt"
      fi
      ;;
    physical )
      # Physical machine
      _firmware_pkg="linux-firmware-none"

      if [ "$image_physical_type" = "pc" ]; then
        # PC
        if [ "$image_kernel_type" = "edge" ]; then
          _kernel_pkg="linux-edge"
          _kernel_config_file="config-edge"
        else
          _kernel_pkg="linux-lts"
          _kernel_config_file="config-lts"
        fi
      elif [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
        # Raspberry Pi
        case $image_physical_type in
          rpi2 | rpi3 )
            if [ "$image_arch" = "armv7" ]; then
              _kernel_pkg="linux-rpi2"
              _kernel_config_file="config-rpi2"
            else
              _kernel_pkg="linux-rpi"
              _kernel_config_file="config-rpi"
            fi ;;
          rpi4 )
            _kernel_pkg="linux-rpi4"
            _kernel_config_file="config-rpi4"
            ;;
        esac
      fi
      ;;
  esac

  cat <<-EOF >> "$run_script"
	
	write_log "Installing kernel $_kernel_pkg"
	{
	  apk add $_kernel_pkg ${_firmware_pkg:-} >> /chroot.log 2>&1
	EOF

  cat <<-'EOF' >> "$run_script"
	
	  _kernel_version=\$(get_kernel_version)
	  _kernel_package_version=\$(get_kernel_package_version)
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-EOF >> "$run_script"
	
	  write_debug_log "Kernel is: \\\$_kernel_version"
	  write_debug_log "Kernel package version is: \\\$_kernel_package_version"
	
	  # Take a copy of the kernel config file
	  cp /boot/$_kernel_config_file \\
	    /kernel-config_\\\${_kernel_package_version}_${image_arch}_${_kernel_config_file}
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Install CPU microcode packages
#
install_microcode() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Selecting microcode packages to install"
	{
	EOF

  if [ "$image_class" = "physical" ]; then
    # only Physical machines use microcode
    install_microcode_for_physical
  else
    cat <<-'EOF' >> "$run_script"
	  write_log "No microcode required" 2
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# LVM extents are 4MiB in size and so the size of a LV must be rounded
# up to the nearest 4MiB multiple.
#
lvm_round_extents() {
  local _size=$1

  # 4MiB
  local _extent=4

  echo "$_size $_extent" | awk '{print int(($1/$2)+0.75)*$2}'
}


#
# Partition the disk image for booting via BIOS
#
partition_bios() {
  local _boot_part_start _boot_part_end _cidata_part_start _cidata_part_end
  local _luks_part_start _luks_part_end _lvm_part_start _lvm_part_end

  cat <<-'EOF' >> "$run_script"
	
	write_log "Partitioning disk image for BIOS"
	{
	EOF

  create_disk_label "msdos"

  if [ -n "${image_encrypted+x}" ]; then
    # Disk encryption

    if [ -n "${needs_boot_partition+x}" ]; then
      # When using Syslinux with encrypted rootfs or when using remote
      # unlock (whether with Grub or Syslinux) we need to create a separate
      # boot partition which will be unencrypted.
      boot_part_num=1
      _boot_part_start="2"
      _boot_part_end="$((_boot_part_start+image_boot_part_size))"

      create_disk_partition "$boot_part_num" "${_boot_part_start}MiB" \
        "${_boot_part_end}MiB" "$image_boot_part_size" "Boot" "boot"

      if [ "$image_class" = "physical" ] && \
         [ "$image_cloud_software" = "cloud-init" ]; then
        cidata_part_num=2
        _cidata_part_start="${_boot_part_end}"
        _cidata_part_end="$((_cidata_part_start+CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "${_cidata_part_start}MiB" \
          "${_cidata_part_end}MiB" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        luks_part_num=3
        _luks_part_start="${_cidata_part_end}"
        _luks_part_end="100%"
      else
        luks_part_num=2
        _luks_part_start="${_boot_part_end}"
        _luks_part_end="100%"
      fi

      create_disk_partition "$luks_part_num" "${_luks_part_start}MiB" \
        "$_luks_part_end" "$image_luks_part_size" "LUKS"
    else
      # GRUB and no remote unlock enabled

      if [ "$image_class" = "physical" ] && \
         [ "$image_cloud_software" = "cloud-init" ]; then
        cidata_part_num=1
        _cidata_part_start="2"
        _cidata_part_end="$((_cidata_part_start+CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "${_cidata_part_start}MiB" \
          "${_cidata_part_end}MiB" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        luks_part_num=2
        _luks_part_start="$_cidata_part_end"
        _luks_part_end="100%"

      else
        luks_part_num=1
        _luks_part_start="2"
        _luks_part_end="100%"
      fi

      create_disk_partition "$luks_part_num" "${_luks_part_start}MiB" \
        "$_luks_part_end" "$image_luks_part_size" "LUKS" "boot"
    fi

  elif [ -n "${image_lvm_rootfs+x}" ]; then
    # LVM

    if [ -n "${needs_boot_partition+x}" ]; then
      # When using Syslinux with LVM rootfs we need to create a separate
      # boot partition.
      boot_part_num=1
      _boot_part_start="2"
      _boot_part_end="$((_boot_part_start+image_boot_part_size))"

      create_disk_partition "$boot_part_num" "${_boot_part_start}MiB" \
        "${_boot_part_end}MiB" "$image_boot_part_size" "Boot" "boot"

      if [ "$image_class" = "physical" ] && \
         [ "$image_cloud_software" = "cloud-init" ]; then
        # Also create a separate partition for cloud-init config
        cidata_part_num=2
        _cidata_part_start="$_boot_part_end"
        _cidata_part_end="$((_cidata_part_start+CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "${_cidata_part_start}MiB" \
          "${_cidata_part_end}MiB" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        lvm_part_num=3
        _lvm_part_start="$_cidata_part_end"
        _lvm_part_end="100%"
      else
        lvm_part_num=2
        _lvm_part_start="$_boot_part_end"
        _lvm_part_end="100%"
      fi

      create_disk_partition "$lvm_part_num" "${_lvm_part_start}MiB" \
        "$_lvm_part_end" "$image_lvm_part_size" "LVM" "lvm"
    else
      # no separate boot partition

      if [ "$image_class" = "physical" ] && \
         [ "$image_cloud_software" = "cloud-init" ]; then
        # Create a separate partition for cloud-init config
        cidata_part_num=1
        _cidata_part_start="2"
        _cidata_part_end="$((_cidata_part_start+CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "${_cidata_part_start}MiB" \
          "${_cidata_part_end}MiB" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        lvm_part_num=2
        _lvm_part_start="$_cidata_part_end"
        _lvm_part_end="100%"

      else
        lvm_part_num=1
        _lvm_part_start="2"
        _lvm_part_end="100%"
      fi

      create_disk_partition "$lvm_part_num" "${_lvm_part_start}MiB" \
        "$_lvm_part_end" "$image_lvm_part_size" "LVM" "boot lvm"
    fi
  else
    # No disk encryption, no LVM
    if [ -n "${needs_boot_partition+x}" ]; then
      # A separate boot partition is to be created.
      boot_part_num=1
      _boot_part_start="2"
      _boot_part_end="$((_boot_part_start+image_boot_part_size))"

      create_disk_partition "$boot_part_num" "${_boot_part_start}MiB" \
        "${_boot_part_end}MiB" "$image_boot_part_size" "Boot" "boot"

      if [ "$image_class" = "physical" ] && \
         [ "$image_cloud_software" = "cloud-init" ]; then
        cidata_part_num=2
        _cidata_part_start="$_boot_part_end"
        _cidata_part_end="$((_cidata_part_start+CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "${_cidata_part_start}MiB" \
          "${_cidata_part_end}MiB" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        root_part_num=3
        _root_part_start="$((_boot_part_end+CONSTANT_CIDATA_PART_SIZE))"
        _root_part_end="100%"
      else
        root_part_num=2
        _root_part_start="$_boot_part_end"
        _root_part_end="100%"
      fi

      create_disk_partition "$root_part_num" "${_root_part_start}MiB" \
        "$_root_part_end" "$image_root_part_size" "Root"
    else
      # No boot partition created
      if [ "$image_class" = "physical" ] && \
         [ "$image_cloud_software" = "cloud-init" ]; then
        cidata_part_num=1
        _cidata_part_start="2"
        _cidata_part_end="$((_cidata_part_start+CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "${_cidata_part_start}MiB" \
          "${_cidata_part_end}MiB" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        root_part_num=2
        _root_part_start="$_cidata_part_end"
        _root_part_end="100%"
      else
        root_part_num=1
        _root_part_start="2"
        _root_part_end="100%"
      fi

      create_disk_partition "$root_part_num" "${_root_part_start}MiB" \
        "$_root_part_end" "$image_root_part_size" "Root" "boot"
    fi
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Partition for Raspberry Pi use
#
partition_rpi() {
  local _boot_part_start _boot_part_end _cidata_part_start _cidata_part_end
  local _other_part_num _other_part_start _other_part_end _other_part_size
  local _other_part_desc _other_part_flags

  cat <<-'EOF' >> "$run_script"
	
	write_log "Partitioning disk image for Raspberry Pi"
	{
	EOF

  create_disk_label "msdos"

  boot_part_num="1"
  _boot_part_start="0%"
  _boot_part_end="${image_boot_part_size}MiB"

  create_disk_partition "$boot_part_num" "$_boot_part_start" \
    "$_boot_part_end" "$image_boot_part_size" "Boot" "" "fat32"

  if [ "$image_cloud_software" = "cloud-init" ]; then
    # Cloud-init partition
    cidata_part_num="2"
    _cidata_part_start="${image_boot_part_size}MiB"
    _cidata_part_end="$((image_boot_part_size + CONSTANT_CIDATA_PART_SIZE))MiB"

    create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
      "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

    _other_part_num="3"
    _other_part_start="$((image_boot_part_size + CONSTANT_CIDATA_PART_SIZE))MiB"
    _other_part_end="100%"

    if [ -n "${image_encrypted+x}" ]; then
      # Disk encryption
      luks_part_num=$_other_part_num
      _other_part_size=$image_luks_part_size
      _other_part_desc="LUKS"
    elif [ -n "${image_lvm_rootfs+x}" ]; then
      # LVM
      lvm_part_num=$_other_part_num
      _other_part_size=$image_lvm_part_size
      _other_part_desc="LVM"
      _other_part_flags="lvm"
    else
      # No disk encryption
      root_part_num=$_other_part_num
      _other_part_size=$image_root_part_size
      _other_part_desc="Root"
    fi
  else
    # No cloud-init partition
    _other_part_num="2"
    _other_part_start="${image_boot_part_size}MiB"
    _other_part_end="100%"

    if [ -n "${image_encrypted+x}" ]; then
      # Disk encryption
      luks_part_num=$_other_part_num
      _other_part_size=$image_luks_part_size
      _other_part_desc="LUKS"
    elif [ -n "${image_lvm_rootfs+x}" ]; then
      # LVM
      lvm_part_num=$_other_part_num
      _other_part_size=$image_lvm_part_size
      _other_part_desc="LVM"
      _other_part_flags="lvm"
    else
      # No disk encryption
      root_part_num=$_other_part_num
      _other_part_size=$image_root_part_size
      _other_part_desc="Root"
    fi
  fi

  create_disk_partition "$_other_part_num" "$_other_part_start" \
    "$_other_part_end" "$_other_part_size" "$_other_part_desc" "${_other_part_flags:-}"

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


# 
# Partition the disk image for booting via UEFI
#
partition_uefi() {
  local _boot_part_start _boot_part_end _cidata_part_start _cidata_part_end
  local _esp_part_type _luks_part_start _luks_part_end
  local _lvm_part_start _lvm_part_end _uefi_part_start _uefi_part_end

  cat <<-'EOF' >> "$run_script"
	
	write_log "Partitioning disk image for UEFI"
	{
	EOF

  create_disk_label "gpt"

  uefi_part_num=1
  _uefi_part_start="0%"
  _uefi_part_end="${image_uefi_part_size}"

  case $esp_type in
    fat12 | fat16 )
      _esp_part_type="fat16" ;;
    fat32 )
      _esp_part_type="fat32" ;;
  esac

  create_disk_partition "$uefi_part_num" "$_uefi_part_start" \
    "$_uefi_part_end" "$image_uefi_part_size" "ESP" "esp" "$_esp_part_type"
  label_gpt_disk_partition 1 "ESP"

  if [ -n "${image_encrypted+x}" ]; then
    # Disk encryption
    if [ -n "${needs_boot_partition+x}" ]; then
      # When using remote unlock with GRUB we need to create a separate boot
      # partition which will be unencrypted. This is not needed for Syslinux
      # as in that case the EFI partition contains the boot files.
      boot_part_num=2
      _boot_part_start="${_uefi_part_end}"
      _boot_part_end="$((_boot_part_start + image_boot_part_size))"

      create_disk_partition "$boot_part_num" "$_boot_part_start" \
        "$_boot_part_end" "$image_boot_part_size" "Boot" "boot"
      label_gpt_disk_partition $boot_part_num "Boot"

      if [ "$image_class" = "physical" ] && \
         [ "$image_cloud_software" = "cloud-init" ]; then
        cidata_part_num=3
        _cidata_part_start="${_boot_part_end}"
        _cidata_part_end="$((_cidata_part_start + CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
          "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"
        label_gpt_disk_partition $cidata_part_num "cidata"

        luks_part_num=4
        _luks_part_start="${_cidata_part_end}"
        _luks_part_end="100%"
      else
        luks_part_num=3
        _luks_part_start="${_boot_part_end}"
        _luks_part_end="100%"
      fi
    else
      if [ "$image_class" = "physical" ] && \
         [ "$image_cloud_software" = "cloud-init" ]; then
        cidata_part_num=2
        _cidata_part_start="${_uefi_part_end}"
        _cidata_part_end="$((_cidata_part_start + CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
          "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"
        label_gpt_disk_partition $cidata_part_num "cidata"

        luks_part_num=3
        _luks_part_start="${_cidata_part_end}"
        _luks_part_end="100%"
      else
        luks_part_num=2
        _luks_part_start="${_uefi_part_end}"
        _luks_part_end="100%"
      fi
    fi

    create_disk_partition "$luks_part_num" "$_luks_part_start" \
      "$_luks_part_end" "$image_luks_part_size" "LUKS"
    label_gpt_disk_partition $luks_part_num "LUKS"

  elif [ -n "${image_lvm_rootfs+x}" ]; then
    # LVM
    if [ -n "${needs_boot_partition+x}" ]; then
      # When using Syslinux with LVM rootfs we need to create a separate
      # boot partition.
      boot_part_num=2
      _boot_part_start="${_uefi_part_end}"
      _boot_part_end="$((_boot_part_start + image_boot_part_size))"

      create_disk_partition "$boot_part_num" "$_boot_part_start" \
        "$_boot_part_end" "$image_boot_part_size" "Boot" "boot"
      label_gpt_disk_partition $boot_part_num "Boot"

      if [ "$image_class" = "physical" ] && \
         [ "$image_cloud_software" = "cloud-init" ]; then
        # Also create a separate partition for cloud-init config
        cidata_part_num=3
        _cidata_part_start="${_boot_part_end}"
        _cidata_part_end="$((_cidata_part_start + CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
          "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"
        label_gpt_disk_partition $cidata_part_num "cidata"

        lvm_part_num=4
        _lvm_part_start="${_cidata_part_end}"
        _lvm_part_end="100%"
      else
        lvm_part_num=3
        _lvm_part_start="${_boot_part_end}"
        _lvm_part_end="100%"
      fi
    else
      # no separate boot partition
      if [ "$image_class" = "physical" ] && \
         [ "$image_cloud_software" = "cloud-init" ]; then
        # Create a separate partition for cloud-init config
        cidata_part_num=2
        _cidata_part_start="${_uefi_part_end}"
        _cidata_part_end="$((_cidata_part_start + CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
          "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"
        label_gpt_disk_partition $cidata_part_num "cidata"

        lvm_part_num=3
        _lvm_part_start="${_cidata_part_end}"
        _lvm_part_end="100%"
      else
        lvm_part_num=2
        _lvm_part_start="${_uefi_part_end}"
        _lvm_part_end="100%"
      fi
    fi

    create_disk_partition "$lvm_part_num" "$_lvm_part_start" \
      "$_lvm_part_end" "$image_lvm_part_size" "LVM" "lvm"
    label_gpt_disk_partition $lvm_part_num "LVM"

  else
    # No disk encryption, no LVM
    if [ -n "${needs_boot_partition+x}" ]; then
      # A separate boot partition is to be created.
      boot_part_num=2
      _boot_part_start="${_uefi_part_end}"
      _boot_part_end="$((_boot_part_start + image_boot_part_size))"

      create_disk_partition "$boot_part_num" "$_boot_part_start" \
        "$_boot_part_end" "$image_boot_part_size" "Boot"
      label_gpt_disk_partition $boot_part_num "Boot"

      if [ "$image_class" = "physical" ] && \
         [ "$image_cloud_software" = "cloud-init" ]; then
        cidata_part_num=3
        _cidata_part_start="${_boot_part_end}"
        _cidata_part_end="$((_cidata_part_start + CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
          "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"
        label_gpt_disk_partition $cidata_part_num "cidata"

        root_part_num=4
        _root_part_start="${_cidata_part_end}"
        _root_part_end="100%"
      else
        root_part_num=3
        _root_part_start="${_boot_part_end}"
        _root_part_end="100%"
      fi
    else
      # No boot partition
      if [ "$image_class" = "physical" ] && \
         [ "$image_cloud_software" = "cloud-init" ]; then
        cidata_part_num=2
        _cidata_part_start="${_uefi_part_end}"
        _cidata_part_end="$((_cidata_part_start + CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
          "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"
        label_gpt_disk_partition $cidata_part_num "cidata"

        root_part_num=3
        _root_part_start="${_cidata_part_end}"
        _root_part_end="100%"
      else
        root_part_num=2
        _root_part_start="${_uefi_part_end}"
        _root_part_end="100%"
      fi
    fi

    create_disk_partition "$root_part_num" "$_root_part_start" \
      "$_root_part_end" "$image_root_part_size" "Root"
    label_gpt_disk_partition $root_part_num "Root"

  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Prepare the main section of the run script
#
prep_runscript_main_section() {
  cat <<-EOF >> "$run_script"
	
	#############################################################################
	##   Main Section
	#############################################################################
	
	# Ensure if any errors occur that various cleanup operations happen
	trap error_cleanup EXIT
	
	chroot_dir="${chroot_directory}"
	images_dir="${images_directory}"
	TMPDIR="/var/tmp"
	
	image_filename="${filename_for_image}"
	logfile="${logs_output_file}"
	
	EOF

  if [ -n "${image_default_user_password+x}" ]; then
    cat <<-EOF >> "$run_script"
	default_user_password="${image_default_user_password}"
	EOF
  fi

  if [ -n "${image_encrypted+x}" ]; then
    cat <<-EOF >> "$run_script"
	encryption_passphrase="${image_encryption_passphrase}"
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	
	# Create empty logfile
	:> $logfile
	
	EOF

if [ -n "${use_ramdisk+x}" ]; then
  cat <<-EOF >> "$run_script"
	ramdisk_dir="${ramdisk_directory}"
	image_full_filename="\$ramdisk_dir/\$image_filename"
	EOF
else
  cat <<-'EOF' >> "$run_script"
	image_full_filename="$images_dir/$image_filename"
	EOF
fi

cat <<-EOF >> "$run_script"
	
	check_for_required_packages
	check_binfmt_packages ${image_arch}
	
	mkdir -p \$images_dir
	
	EOF
}


#
# Create the /etc/crypttab file
#
setup_crypttab() {
  local _crypttab_options="luks"

  case $image_os_device_media in
    sd | ssd )
      # Enable discard to be triggered at intervals by fstrim via cron.
      _crypttab_options="$_crypttab_options,discard" ;;
  esac

  cat <<-EOF >> "$run_script"
	
	write_log "Creating /etc/crypttab" 2
	echo \\
	  "${CONSTANT_LUKS_DEVICE_NAME} UUID=\${luks_part_uuid} /crypto_keyfile.bin $_crypttab_options" \\
	  > /etc/crypttab
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	# Debug
	{
	  write_debug_log "/etc/crypttab contents:" 4
	  cat /etc/crypttab >> /chroot.log
	}
	EOF
  fi
}


#
# Create Dropbear authorized_keys file
#
setup_dropbear_authorized_keys() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Setup Dropbear authorized_keys file"
	{
	  echo $ssh_public_key \\
	    > /etc/dropbear/authorized_keys
	  chown root:root /etc/dropbear/authorized_keys
	  chmod 600 /etc/dropbear/authorized_keys
	}
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	# Debug
	{
	  write_debug_log "Dropbear authorized_keys contents:" 2
	  cat /etc/dropbear/authorized_keys >> "$logfile"
	}
	EOF
  fi
}


#
# Configure modules to be loaded upon boot
#
setup_etc_modules() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Setup /etc/modules"
	{
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    cp /etc/modules /etc/modules-orig
	  }
	EOF
  fi

  cat <<'EOF' >> "$run_script"

  cat <<-_SCRIPT_ > /etc/modules
	af_packet
EOF

  if [ -z "${image_disable_ipv6+x}" ]; then
    cat <<'EOF' >> "$run_script"
	ipv6
EOF
  fi

  if [ -n "${image_encrypted+x}" ]; then
    cat <<'EOF' >> "$run_script"
	
	# LUKS
	dm-crypt
EOF
  fi

  if [ -n "${image_experimental+x}" ]; then
    # Experimental

    if [ -n "${image_encrypted+x}" ] && \
       [ -n "${remote_unlock_enabled+x}" ]; then
      # Add network module(s) need for remote encryption unlock
      case $image_class in
        physical )
          if [ "$image_physical_type" = "pc" ] && \
             [ -n "${remote_unlock_network_module}" ]; then
            cat <<EOF >> "$run_script"
	
	# For remote SSH unlock
	$remote_unlock_network_module
EOF
          else
            cat <<'EOF' >> "$run_script"
	
	# For remote SSH unlock
	e1000
EOF
          fi
          ;;
        virtual )
          if [ "$image_vm_type" = "vmware" ]; then
            cat <<'EOF' >> "$run_script"
	
	# For remote SSH unlock
	vmxnet3
EOF
          else
            cat <<'EOF' >> "$run_script"
	
	# For remote SSH unlock
	virtio_net
	virtio_pci
EOF
          fi
          ;;
      esac
    fi
  fi # Experimental

###  cat <<'EOF' >> "$run_script"
###
###	# Used by rngd
###	jitterentropy_rng
###EOF

  case $image_class in
    cloud )
      case $image_cloud_software in
        cloud-init )
          etc_modules_list_for_cloud_init ;;
      esac
      ;;
    physical )
      etc_modules_list_for_physical ;;
    virtual )
      etc_modules_list_for_virtual ;;
  esac


  if [ -n "${image_extra_modules+x}" ]; then
    # Add any specified extra modules to the list
    cat <<'EOF' >> "$run_script"
	
	# Extra modules
EOF
    for _module in $image_extra_modules; do
      cat <<EOF >> "$run_script"
	$_module
EOF
    done
  fi


  cat <<'EOF' >> "$run_script"
	_SCRIPT_
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    diff /etc/modules-orig /etc/modules >> /chroot.log || true
	    rm /etc/modules-orig
	  }
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Setup the LUKS device
#
setup_luks_device() {
  case $image_bootloader in
    grub )
      if [ -n "${image_no_grub_encryption+x}" ] || \
         [ -n "${needs_boot_partition+x}" ] || \
         { [ "$image_alpine_release" != "v3.13" ] && \
           [ "$image_encryption_cipher" != "adiantum" ]; }; then
        # Only use LUKSv2 with GRUB if:
        # - GRUB's own support for LUKS is disabled, OR
        # - a separate /boot (unencrypted) partition is also used, OR
        # - Alpine > 3.13 & Adantium is not used as LUKS cipher (which GRUB does not support)
        ###image_luks_version="2"
        #
        # GRUB 2.06's LUKSv2 FDE support does not actually appear to work so
        # only use v1 until it is fixed
        image_luks_version="1"
      else
        image_luks_version="1"
      fi
      ;;
    * )
      image_luks_version="2" ;;
  esac

  cat <<-EOF >> "$run_script"
	
	write_log "Setting up LUKS v${image_luks_version} device using ${image_encryption_cipher} cipher"
	{
	  luks_device="\${loop_device}p${luks_part_num}"
	  write_log "Formatting partition as LUKS version ${image_luks_version}" 2
	  echo "\$encryption_passphrase" | cryptsetup -q --verbose luksFormat \\
	    --pbkdf pbkdf2 --type luks${image_luks_version} --label ${CONSTANT_LUKS_LABEL} \\
	EOF

  if [ "$image_encryption_cipher" = "adiantum" ]; then
    cat <<-'EOF' >> "$run_script"
	    --cipher xchacha12,aes-adiantum-plain64 --hash sha256 --key-size 256 \
	EOF
	else
    cat <<-'EOF' >> "$run_script"
	    --cipher aes-xts-plain64 --hash sha256 --key-size 512 \
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	    "$luks_device" >> "$logfile" 2>&1
	EOF

###      --offset 8 \

  if [ "$image_bootloader" = "grub" ] && \
     { [ -z "${image_experimental+x}" ] || \
       [ -z "${remote_unlock_enabled+x}" ]; } && \
     [ -z "${image_no_grub_encryption+x}" ] && \
     [ -z "${needs_boot_partition+x}" ]; then
    # When:
    #  - disk image is encrypted, AND
    #  - bootloader is Grub, AND
    #  - remote unlock is not enabled (as otherwise /boot is not encrypted), AND
    #  - Grub LUKS encryption support is not disabled, AND
    #  - /boot is not a separate partition
    # then create a keyfile - this will be placed in the initramfs and used to
    # unlock the rootfs - this prevents being prompted for passphrase twice,
    # once by Grub and then again by initramfs.
    cat <<-EOF >> "$run_script"
	
	  write_log "Creating keyfile for LUKS" 2
	  dd bs=512 count=4 if=/dev/random of=crypto_keyfile.bin iflag=fullblock \\
	    >> "\$logfile" 2>&1
	
	  write_log "Adding keyfile to LUKS device" 2
	  echo "\$encryption_passphrase" | \\
	    cryptsetup luksAddKey "\$luks_device" ./crypto_keyfile.bin >> "\$logfile"
	
	  write_log "Opening LUKS device" 2
	  cryptsetup open --type luks${image_luks_version} --key-file ./crypto_keyfile.bin \\
	    "\$luks_device" ${CONSTANT_LUKS_DEVICE_NAME}
	EOF
  else
    # Remote unlock enabled, use default passphrase to open
    cat <<-EOF >> "$run_script"
	
	  write_log "Opening LUKS device" 2
	  echo "\$encryption_passphrase" | \\
	    cryptsetup open --type luks${image_luks_version} "\$luks_device" ${CONSTANT_LUKS_DEVICE_NAME} -
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	  luks_part_uuid=$(get_uuid_from_device "$luks_device")
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    write_log "Show LUKS device details" 2
	    cryptsetup luksDump "$luks_device" >> "$logfile"
	  }
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Setup the LVM device
#
setup_lvm_device() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Setting up LVM device"
	{
	EOF

  if [ -n "${image_encrypted+x}" ]; then
    # LVM on top of LUKS
    cat <<-EOF >> "$run_script"
	  lvm_device="/dev/mapper/${CONSTANT_LUKS_DEVICE_NAME}"
	EOF
  else
    cat <<-EOF >> "$run_script"
	  lvm_device="\${loop_device}p${lvm_part_num}"
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	
	  write_log "Creating LVM physical volume" 2
	  pvcreate --verbose "$lvm_device" >> "$logfile" 2>&1
	  _pv_size=$(pvdisplay --verbose 2>&1 | grep "PV Size" | sed -e 's/^.*PV Size[ ]*//' -e 's/\.[0-9]* MiB.*$//')
	  write_debug_log "    Resultant PV size ${_pv_size}MiB"
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "Physical volume info:"
	    pvdisplay --verbose >> "$logfile" 2>&1
	  }
	EOF
  fi

  cat <<-EOF >> "$run_script"
	
	  write_log "Creating LVM volume group" 2
	  vgcreate --verbose ${CONSTANT_LVM_VG_NAME} "\$lvm_device" >> "\$logfile" 2>&1
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-EOF >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "Volume group info:"
	    vgdisplay --verbose ${CONSTANT_LVM_VG_NAME} >> "\$logfile" 2>&1
	  }
	EOF
  fi

  cat <<-EOF >> "$run_script"
	
	  write_log "Creating $(calculate_lvm_root_lv_size)MiB LVM logical volume for rootfs" 2
	  lvcreate --verbose -L $(calculate_lvm_root_lv_size)m ${CONSTANT_LVM_VG_NAME} -n ${CONSTANT_LVM_ROOT_LV_NAME} >> "\$logfile" 2>&1
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-EOF >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "rootfs Logical Volume info:"
	    lvs --verbose ${CONSTANT_LVM_VG_NAME}/${CONSTANT_LVM_ROOT_LV_NAME} >> "\$logfile" 2>&1
	
	    write_debug_log "Volume group info:"
	    vgdisplay --verbose ${CONSTANT_LVM_VG_NAME} >> "\$logfile" 2>&1
	  }
	EOF
  fi

  if [ -z "${needs_boot_partition+x}" ]; then
    cat <<-EOF >> "$run_script"
	
	  write_log "Creating $(calculate_lvm_boot_lv_size)MiB LVM logical volume for boot" 2
	  lvcreate --verbose -L $(calculate_lvm_boot_lv_size)m ${CONSTANT_LVM_VG_NAME} -n ${CONSTANT_LVM_BOOT_LV_NAME} >> "\$logfile" 2>&1
	EOF

    if [ -n "${debug_enabled+x}" ]; then
      cat <<-EOF >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "boot Logical Volume info:"
	    lvs --verbose ${CONSTANT_LVM_VG_NAME}/${CONSTANT_LVM_BOOT_LV_NAME} >> "\$logfile" 2>&1
	
	    write_debug_log "Volume group info:"
	    vgdisplay --verbose ${CONSTANT_LVM_VG_NAME} >> "\$logfile" 2>&1
	  }
	EOF
    fi
  fi

  cat <<-EOF >> "$run_script"
	
	  write_log "Creating $(calculate_lvm_logs_lv_size)MiB LVM logical volume for logs" 2
	  lvcreate --verbose -L $(calculate_lvm_logs_lv_size)m ${CONSTANT_LVM_VG_NAME} -n ${CONSTANT_LVM_LOGS_LV_NAME} >> "\$logfile" 2>&1
	EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<-EOF >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "logs Logical Volume info:"
	    lvs --verbose ${CONSTANT_LVM_VG_NAME}/${CONSTANT_LVM_LOGS_LV_NAME} >> "\$logfile" 2>&1
	
	    write_debug_log "Volume group info:"
	    vgdisplay --verbose ${CONSTANT_LVM_VG_NAME} >> "\$logfile" 2>&1
	
	    write_debug_log "lvscan output:"
	    lvscan --verbose >> "\$logfile" 2>&1
	  }
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}
