#!/bin/sh -u
# shellcheck disable=SC2039

#############################################################################
##
##  image-functions
##
##  Copyright 2021-2022 Dermot Bradley <dermot_bradley@yahoo.com>
##
##  Licensed via GPL version 2.0
##
#############################################################################


#
# Additional OS configuration
#
additional_os_configuration() {
  cat <<'EOF' >> "$run_script"

write_log "Doing additional OS configuration"
{
  # FIXUP: stop update-ca-certificates displaying a warning
  sed -i \
    -e 's|/etc/ssl/certs|/etc/ssl/certs 2>/dev/null|' \
    /etc/ca-certificates/update.d/certhash
EOF

  if [ "$image_syslog_server" = "rsyslog" ]; then
    cat <<'EOF' >> "$run_script"

  # Create empty file as rsyslog's logrotate config expects it
  :> /var/log/mail.log
EOF
  fi

  if [ "$image_auth_control" = "doas" ] || \
     [ "$image_auth_control" = "both" ]; then
  cat <<'EOF' >> "$run_script"

  write_log "Adding doas configuration for wheel group" 2
  cat <<-_SCRIPT_ > /etc/doas.d/00-configure-wheel-group.conf
	#
	# Allow members of group wheel to become root
	#
	permit persist :wheel
	_SCRIPT_
EOF
  fi

  cat <<'EOF' >> "$run_script"
}
EOF
}


#
# Basic OS configuration
#
basic_os_configuration() {
  local _color_prompt_file _login_banner

  cat <<'EOF' >> "$run_script"

write_log "Doing basic OS configuration"
{
  write_log "Setting the login message to be 'vague'" 2
  {
    printf '\nWelcome\n\n' > /etc/issue
EOF

  if [ "$image_class" = "cloud" ]; then
    # Cloud
    _login_banner="Alpine $image_arch $image_cloud_type Cloud server"
  elif [ "$image_class" = "virtual" ]; then
    # Virtual machine
    _login_banner="Alpine $image_arch $image_vm_type VM server"
  else
    # Physical machine
    if [ "$image_physical_type" = "pc" ]; then
      _login_banner="Alpine $image_arch PC server"
    elif [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
      _login_banner="Alpine $image_arch Raspberry Pi server"
    fi
  fi

  cat <<EOF >> "$run_script"
    printf '\n\n$_login_banner\n\n' > /etc/motd
  }
EOF

  cat <<'EOF' >> "$run_script"

  write_log "Setting the keymap to '\$keymap'" 2
  setup-keymap \$keymap >> "/chroot.log" 2>&1
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    cp /etc/profile.d/locale.sh /etc/profile.d/locale.sh-orig
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"

  write_log "Setting locale to \$locale.UTF-8" 2
  sed -i -E -e "s/^(export LANG=)C.UTF-8/\1\$locale.UTF-8/" \
    /etc/profile.d/locale.sh
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    diff /etc/profile.d/locale.sh-orig /etc/profile.d/locale.sh \
      >> /chroot.log || true
    rm /etc/profile.d/locale.sh-orig

    cp /etc/rc.conf /etc/rc.conf-orig
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"

  write_log "Set OpenRC to log init.d start/stop sequences" 2
  sed -i -e 's|[#]rc_logger=.*|rc_logger="YES"|g' /etc/rc.conf

  write_log "Configure /etc/init.d/bootmisc to keep previous copy of dmesg logfile" 2
  sed -i -e 's|[#]previous_dmesg=.*|previous_dmesg=yes|g' /etc/conf.d/bootmisc

  write_log "Fixup rc.conf so that keyboards and screens use Unicode" 2
  sed -i -e 's/^#unicode="NO"/unicode="YES"/' /etc/rc.conf
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    diff /etc/rc.conf-orig /etc/rc.conf >> /chroot.log || true
    rm /etc/rc.conf-orig
  }
EOF
  fi

  if [ "$image_alpine_release" = "v3.13" ]; then
    _color_prompt_file="color_prompt"
  else
    _color_prompt_file="color_prompt.sh.disabled"
  fi

  cat <<EOF >> "$run_script"

  write_log "Enable colour shell prompt" 2
  cp /etc/profile.d/${_color_prompt_file} /etc/profile.d/color_prompt.sh

  rmdir /media/floppy
}
EOF
}


#
# Disable a set of specified kernel modules
#
blacklist_list_of_kernel_modules() {
  local _modules_section=$1
  local _modules_blacklist="$2"

  cat <<EOF >> "$run_script"

write_log "Blacklisting ${_modules_section} kernel modules" 2
{
  cat <<-_SCRIPT_ > /etc/modprobe.d/blacklist-${_modules_section}-modules.conf
EOF

  for MODULE_NAME in $_modules_blacklist; do
    cat <<EOF >> "$run_script"
	blacklist ${MODULE_NAME}
EOF
  done

  cat <<EOF >> "$run_script"
	_SCRIPT_

  sort -u -o /etc/modprobe.d/blacklist-${_modules_section}-modules.conf \\
    /etc/modprobe.d/blacklist-${_modules_section}-modules.conf
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<EOF >> "$run_script"

  # Debug
  {
    write_debug_log "Contents of blacklist-${_modules_section}-modules.conf:" 4
    cat /etc/modprobe.d/blacklist-${_modules_section}-modules.conf >> /chroot.log
  }
EOF
  fi

  cat <<EOF >> "$run_script"
}
EOF
}


#
# Calculate size of the boot partition if it is required.
#
calculate_boot_part_size() {
  local _size _fs_total_size

  if [ -n "${needs_boot_partition+x}" ]; then
    _fs_total_size=$((general_boot_part_size))
    if [ "$image_fs_type" = "ext4" ]; then
      # Allow for Ext4 FS reserved percentage
      _size=$((_fs_total_size + (_fs_total_size * CONSTANT_EXT4_RESERVED_PERCENT / 100 + 1)))
    elif [ "$image_fs_type" = "f2fs" ]; then
      # Allow for F2FS overprovision percentage
      _size=$((_fs_total_size + (_fs_total_size * CONSTANT_F2FS_RESERVED_PERCENT / 100 + 1)))
    else
      _size=$_fs_total_size
    fi
  fi

  echo "${_size:-0}"
}


#
# Calculate size of the resultant disk image taking into account
# whether bootloader, boot and cloud-init partitions are needed.
#
calculate_image_size() {
  local _image_total_size

  if [ -n "${image_encrypted+x}" ]; then
	  # LUKS (including LVM-on-LUKS)
    _image_total_size=$(($(calculate_luks_part_size)))
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_image_size, initial image size for LUKS is $_image_total_size MiB" >> debug
  	fi
  elif [ -n "${image_lvm_rootfs+x}" ]; then
	  # LVM
    _image_total_size=$(($(calculate_lvm_vg_size) + 4))
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_image_size, initial image size for LVM (including 4MiB rounding) is $_image_total_size MiB" >> debug
  	fi
  else
    _image_total_size=$(calculate_root_part_size)
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_image_size, initial image size is $_image_total_size MiB" >> debug
  	fi
  fi

  if [ "$image_class" = "physical" ] && \
	   [ -z "${image_without_cloud_init+x}" ]; then
    _image_total_size="$((_image_total_size + CONSTANT_CIDATA_PART_SIZE))"
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_image_size, adding on CIDATA partition, giving $_image_total_size MiB" >> debug
  	fi
  fi

  if [ -n "${needs_boot_partition+x}" ]; then
    _image_total_size="$((_image_total_size + $(calculate_boot_part_size)))"
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_image_size, adding on Boot partition, giving $_image_total_size MiB" >> debug
  	fi
  fi

  if [ "$image_boot_type" = "bios" ]; then
	  # Allow for 2MiB boot sector
    _image_total_size="$((_image_total_size + 2))"

    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_image_size, added on 1MiB for boot sector, giving $_image_total_size MiB" >> debug
		fi
  elif [ "$image_boot_type" = "uefi" ]; then
    _image_total_size="$((_image_total_size + $(calculate_uefi_part_size)))"
    if [ -n "${debug_enabled+x}" ]; then
      echo "calculate_image_size, adding on ESP partition, giving $_image_total_size MiB" >> debug
  	fi
  fi

  echo "$_image_total_size"
}


#
# Calculate size of the LUKS partition taking into account whether
# separate boot partition is not needed (so boot files add to size).
#
calculate_luks_part_size() {
  local _luks_total_size _size

  _luks_total_size=$general_root_part_size
	if [ -n "${debug_enabled+x}" ]; then
		echo "calculate_luks_part_size, initial LUKS partition is $_luks_total_size MiB" >> debug
  fi

  if [ -z "${needs_boot_partition+x}" ]; then
    _luks_total_size=$((_luks_total_size + general_boot_part_size))
  	if [ -n "${debug_enabled+x}" ]; then
	  	echo "calculate_luks_part_size, no boot partition so adding boot files, size is $_luks_total_size MiB" >> debug
    fi
  fi

  if [ "$image_fs_type" = "ext4" ]; then
    # Allow for Ext4 FS reserved percentage
    _size=$((_luks_total_size + (_luks_total_size * CONSTANT_EXT4_RESERVED_PERCENT / 100)))
  	if [ -n "${debug_enabled+x}" ]; then
	  	echo "calculate_luks_part_size, allowing for Ext4 reserved space, size is $_size MiB" >> debug
    fi
  elif [ "$image_fs_type" = "f2fs" ]; then
    # Allow for F2FS overprovision percentage
    _size=$((_luks_total_size + (_luks_total_size * CONSTANT_F2FS_RESERVED_PERCENT / 100)))
  	if [ -n "${debug_enabled+x}" ]; then
	  	echo "calculate_luks_part_size, allowing for F2FS overprovisioning percentage, size is $_size MiB" >> debug
    fi
  else
    _size=$_luks_total_size
		if [ -n "${debug_enabled+x}" ]; then
	  	echo "calculate_luks_part_size, size is $_size MiB" >> debug
    fi
  fi

  if [ -n "${image_lvm_rootfs+x}" ]; then
    # LVM-on-LUKS
    _size=$((_size + (_size * CONSTANT_LVM_OVERHEAD_PERCENT / 100) + 4))
  	if [ -n "${debug_enabled+x}" ]; then
	  	echo "calculate_luks_part_size, allowing for LVM overhead, size is $_size MiB" >> debug
    fi
  fi

  # add LUKS overhead, rounding up to nearest 4MiB
  _size=$((_size + (_size * CONSTANT_LUKS_OVERHEAD_PERCENT / 100)))
	_size=$(lvm_round_extents $_size)
  if [ -n "${debug_enabled+x}" ]; then
	  echo "calculate_luks_part_size, allowing for LUKS overhead, size is $_size MiB" >> debug
  fi

  echo "$_size"
}


#
# Calculate size of the LVM boot LV.
#
calculate_lvm_boot_lv_size() {
  local _boot_total_size _lv_total_size

  _boot_total_size=$general_boot_part_size
	if [ -n "${debug_enabled+x}" ]; then
		echo "calculate_lvm_boot_lv_size, initial Boot LV size is $_boot_total_size MiB" >> debug
  fi

  if [ "$image_fs_type" = "ext4" ]; then
    # Allow for Ext4 FS reserved percentage
    _boot_total_size=$((_boot_total_size + (_boot_total_size * CONSTANT_EXT4_RESERVED_PERCENT / 100)))
  	if [ -n "${debug_enabled+x}" ]; then
	  	echo "calculate_lvm_boot_lv_size, allowing for Ext4 reserved space, size is $_boot_total_size MiB" >> debug
    fi
  elif [ "$image_fs_type" = "f2fs" ]; then
    # Allow for F2FS overprovision percentage
    _boot_total_size=$((_boot_total_size + (_boot_total_size * CONSTANT_F2FS_RESERVED_PERCENT / 100)))
  	if [ -n "${debug_enabled+x}" ]; then
	  	echo "calculate_lvm_boot_lv_size, allowing for F2FS overprovisioning percentage, size is $_boot_total_size MiB" >> debug
    fi
  fi

  # Round up to next extent
  _lv_total_size=$(lvm_round_extents $_boot_total_size)
  if [ -n "${debug_enabled+x}" ]; then
	  echo "calculate_lvm_boot_lv_size, rounding up to next extent, size is $_lv_total_size MiB" >> debug
  fi
  echo "$_lv_total_size"
}


#
# Calculate size of the LVM logs LV.
#
calculate_lvm_logs_lv_size() {
  local _logs_total_size _lv_total_size

  _logs_total_size=$CONSTANT_LVM_LOGS_LV_SIZE
	if [ -n "${debug_enabled+x}" ]; then
		echo "calculate_lvm_logs_lv_size, initial Logs LV size is $_logs_total_size MiB" >> debug
  fi

  if [ "$image_fs_type" = "ext4" ]; then
    # Allow for Ext4 FS reserved percentage
    _logs_total_size=$((_logs_total_size + (_logs_total_size * CONSTANT_EXT4_RESERVED_PERCENT / 100)))
  	if [ -n "${debug_enabled+x}" ]; then
	  	echo "calculate_lvm_logs_lv_size, allowing for Ext4 reserved space, size is $_logs_total_size MiB" >> debug
    fi
  elif [ "$image_fs_type" = "f2fs" ]; then
    # Allow for F2FS overprovision percentage
    _logs_total_size=$((_logs_total_size + (_logs_total_size * CONSTANT_F2FS_RESERVED_PERCENT / 100)))
  	if [ -n "${debug_enabled+x}" ]; then
	  	echo "calculate_lvm_logs_lv_size, allowing for F2FS overprovisioning percentage, size is $_logs_total_size MiB" >> debug
    fi
  fi

  # Round up to next extent
  _lv_total_size=$(lvm_round_extents $_logs_total_size)
  if [ -n "${debug_enabled+x}" ]; then
	  echo "calculate_lvm_logs_lv_size, rounding up to next extent, size is $_lv_total_size MiB" >> debug
  fi
  echo "$_lv_total_size"
}


#
# Calculate size of the LVM root LV.
#
calculate_lvm_root_lv_size() {
  local _root_total_size _lv_total_size

  _root_total_size=$general_root_part_size
	if [ -n "${debug_enabled+x}" ]; then
		echo "calculate_lvm_root_lv_size, initial Root LV size is $_root_total_size MiB" >> debug
  fi

  if [ "$image_fs_type" = "ext4" ]; then
    # Allow for Ext4 FS reserved percentage
    _root_total_size=$((_root_total_size + (_root_total_size * CONSTANT_EXT4_RESERVED_PERCENT / 100)))
  	if [ -n "${debug_enabled+x}" ]; then
	  	echo "calculate_lvm_root_lv_size, allowing for Ext4 reserved space, size is $_root_total_size MiB" >> debug
    fi
  elif [ "$image_fs_type" = "f2fs" ]; then
    # Allow for F2FS overprovision percentage
    _root_total_size=$((_root_total_size + (_root_total_size * CONSTANT_F2FS_RESERVED_PERCENT / 100)))
  	if [ -n "${debug_enabled+x}" ]; then
	  	echo "calculate_lvm_root_lv_size, allowing for F2FS overprovisioning percentage, size is $_root_total_size MiB" >> debug
    fi
  fi

  # Round up to next extent
  _lv_total_size=$(lvm_round_extents $_root_total_size)
  if [ -n "${debug_enabled+x}" ]; then
	  echo "calculate_lvm_root_lv_size, rounding up to next extend, size is $_lv_total_size MiB" >> debug
  fi
  echo "$_lv_total_size"
}


#
# Calculate size of the LVM partition taking into account whether
# separate boot partition is not needed (so boot files add to size).
#
calculate_lvm_vg_size() {
  local _boot_total_size _root_total_size _logs_total_size _vg_total_size

  if [ -z "${needs_boot_partition+x}" ]; then
    _boot_total_size=$(calculate_lvm_boot_lv_size)
		if [ -n "${debug_enabled+x}" ]; then
		  echo "calculate_lvm_vg_size, Boot LV size is $_boot_total_size MiB" >> debug
    fi
  fi
  _root_total_size=$(calculate_lvm_root_lv_size)
  _logs_total_size=$(calculate_lvm_logs_lv_size)
	if [ -n "${debug_enabled+x}" ]; then
		echo "calculate_lvm_vg_size, Root LV size is $_root_total_size MiB" >> debug
		echo "calculate_lvm_vg_size, Logs LV size is $_logs_total_size MiB" >> debug
  fi

  if [ -n "${needs_boot_partition+x}" ]; then
    _vg_total_size=$((_root_total_size + _logs_total_size))
		if [ -n "${debug_enabled+x}" ]; then
		  echo "calculate_lvm_vg_size, adding Root+Logs LVs gives VG total size of $_vg_total_size MiB" >> debug
    fi
  else
    _vg_total_size=$((_boot_total_size + _root_total_size + _logs_total_size))
		if [ -n "${debug_enabled+x}" ]; then
		  echo "calculate_lvm_vg_size, adding Boot+Root+Logs LVs gives VG total size of $_vg_total_size MiB" >> debug
    fi
  fi
  echo "$_vg_total_size"
}


#
# Calculate size of the root partition taking into account whether
# separate boot partition is not needed (so boot files add to size of root).
#
calculate_root_part_size() {
  local _fs_total_size

  _fs_total_size=$general_root_part_size
  if [ -z "${needs_boot_partition+x}" ]; then
    _fs_total_size=$((_fs_total_size + general_boot_part_size))
  fi
  if [ "$image_fs_type" = "ext4" ]; then
    # Allow for Ext4 FS reserved percentage
    _fs_total_size=$((_fs_total_size + (_fs_total_size * CONSTANT_EXT4_RESERVED_PERCENT / 100 + 1)))
  elif [ "$image_fs_type" = "f2fs" ]; then
    # Allow for F2FS overprovision percentage
    _fs_total_size=$((_fs_total_size + (_fs_total_size * CONSTANT_F2FS_RESERVED_PERCENT / 100 + 1)))
  fi

  echo "$_fs_total_size"
}


#
# Calculate size of the UEFI ESP partition taking into account if it will
# also contain boot files.
#
calculate_uefi_part_size() {
  local _fs_total_size

  _fs_total_size=$((general_uefi_part_size))

  if [ "$image_bootloader" = "syslinux" ]; then
    # There is size of boot files to account for when
    # using Syslinux as then EFI partition is also /boot.
    _fs_total_size="$((_fs_total_size + general_boot_part_size))"
  fi

  echo "$_fs_total_size"
}


#
# Configure Grub
#
configure_bootloader_grub() {
  local _cmdline _modules

  cat <<'EOF' >> "$run_script"

write_log "Configuring Grub"
{
  mkdir -p /boot/grub
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_debug_log "Root fs partition device is $root_part_device" 2
    write_debug_log "Loopback device is $loop_device" 2
  }
EOF
  fi

  # Busybox's losetup is not suitable when installing Grub on a loopback
  # device as it may truncate the name of the underlying filename.
  case $image_alpine_release in
    v3.13 | v3.14 )
      losetup_package="util-linux" ;;
    v3.15 )
      losetup_package="util-linux-misc" ;;
    * )
      losetup_package="losetup" ;;
  esac
  cat <<EOF >> "$run_script"

  # If relevant package is not already installed then install it
  if [ ! \\\$(apk info -e $losetup_package) ]; then
    write_log "Installing $losetup_package package for losetup" 2
    apk add $losetup_package >> /chroot.log 2>&1
    losetup_package_installed=true
  fi
EOF

  if [ "$image_boot_reference" = "label" ]; then
    patch_grub_for_label
  fi

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    ###write_debug_log "Contents of /etc/grub.d/10_linux:" 2
    ###cat /etc/grub.d/10_linux >> /chroot.log
    cp /etc/default/grub /etc/default/grub-orig
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"

  write_log "Updating /etc/default/grub" 2
  {
    sed -i \
      -e 's|^GRUB_DISABLE_RECOVERY=.*$|GRUB_DISABLE_RECOVERY=false|g' \
      -e 's|^GRUB_TIMEOUT=.*$|GRUB_TIMEOUT=5|g' \
      -e '/^GRUB_CMDLINE_LINUX_DEFAULT=.*$/d' \
      /etc/default/grub
EOF

  _cmdline="rootfstype=$image_fs_type"
  # Add modules list
  _modules="$(define_cmdline_for_modules)"
  if [ -n "${_modules}" ]; then
    _cmdline="$_cmdline modules=$_modules"
  fi
  if [ "$image_console_type" = "serial" ] || \
     [ "$image_console_type" = "both" ]; then
    # Serial console
    _cmdline="$_cmdline console=${serial_port_name},${serial_port_speed}"
  fi
  if [ "$image_console_type" = "normal" ] || \
     [ "$image_console_type" = "both" ]; then
    # Normal console
    _cmdline="$_cmdline console=$image_console_name"
  fi
  if [ "$image_boot_type" = "bios" ] && \
     [ -z "${debug_enabled+x}" ]; then
    # With BIOS can disable graphics as "standard" VGA provides text output
    _cmdline="$_cmdline nomodeset"
  fi
  if [ -n "${image_disable_ipv6+x}" ]; then
    _cmdline="$_cmdline ipv6.disable=1"
  fi
  if [ "$image_class" = "cloud" ] || \
     [ "$image_class" = "virtual" ]; then
    # Using tiny-power-button for Cloud/VMs but Busybox init doesn't
    # handle the usual signal this sends, so specify USR2 which Busybox
    # accepts for "poweroff" situations.
    _cmdline="$_cmdline tiny_power_button.power_signal=12"
  fi
  if [ -n "${image_bootchart+x}" ]; then
    _cmdline="$_cmdline chart"
  fi
  if [ -z "${debug_enabled+x}" ]; then
    _cmdline="$_cmdline quiet"
  fi

  if [ -n "${image_encrypted+x}" ]; then
    # Add other LUKS-related cmdline entries
    if [ -z "${image_lvm_rootfs+x}" ]; then
      _cmdline="$_cmdline root=/dev/mapper/${CONSTANT_LUKS_DEVICE_NAME}"
    fi
    _cmdline="$_cmdline \\\$(define_cmdline_for_encryption)"

    if [ "$image_bootloader" = "grub" ] && \
       { [ -z "${image_experimental+x}" ] || \
         [ -z "${remote_unlock_enabled+x}" ]; } && \
       [ -z "${image_no_grub_encryption+x}" ] && \
       [ -z "${needs_boot_partition+x}" ]; then
      # Cryptkey is used for unlock rootfs without 2nd password prompt.
      # It applies only when:
      #  - disk image is encrypted, AND
      #  - bootloader is Grub, AND
      #  - remote unlock is not enabled (as otherwise /boot is not encrypted), AND
      #  - Grub LUKS encryption support is not disabled, AND
      #  - /boot is not a separate partition.
      _cmdline="$_cmdline cryptkey"
    fi
###  elif [ -n "${image_lvm_rootfs+x}" ]; then
###    # Add LVM-specific cmdline entry
###    _cmdline="$_cmdline root=/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_ROOT_LV_NAME}"
  fi

  if [ -n "${image_extra_cmdline_options+x}" ]; then
    # Add any additionally specified cmdline options
    _cmdline="$_cmdline $image_extra_cmdline_options"
  fi

  cat <<EOF >> "$run_script"

    cmdline="$_cmdline"
    {
      echo "GRUB_CMDLINE_LINUX_DEFAULT=\"\\\$cmdline\""
EOF

  if [ "$image_boot_reference" = "label" ]; then
    cat <<'EOF' >> "$run_script"
      echo 'GRUB_ENABLE_LINUX_LABEL=true'
EOF
  else
    cat <<'EOF' >> "$run_script"
      echo 'GRUB_ENABLE_LINUX_LABEL=false'
EOF
  fi

  if [ "$image_boot_type" = "bios" ]; then
    cat <<'EOF' >> "$run_script"
      echo 'GRUB_GFXPAYLOAD_LINUX=text'
EOF
  fi

  if [ -n "${image_encrypted+x}" ]; then
    cat <<'EOF' >> "$run_script"
      echo 'GRUB_DISABLE_LINUX_UUID=true'
EOF
  else
    cat <<'EOF' >> "$run_script"
      echo 'GRUB_DISABLE_LINUX_UUID=false'
EOF
  fi

  cat <<'EOF' >> "$run_script"
      echo 'GRUB_DISABLE_OS_PROBER=true'
      echo 'GRUB_RECORDFAIL_TIMEOUT=20'
    } >> /etc/default/grub
EOF

  if [ "$image_boot_type" = "bios" ]; then
    cat <<'EOF' >> "$run_script"
    if ! grep -q "^GRUB_TERMINAL=" /etc/default/grub; then
      echo 'GRUB_TERMINAL=console' >> /etc/default/grub
    fi
EOF
  fi

  if [ -n "${image_encrypted+x}" ] && \
     { [ -z "${image_experimental+x}" ] || \
       [ -z "${remote_unlock_enabled+x}" ]; } && \
     [ -z "${image_no_grub_encryption+x}" ] && \
		 [ -z "${needs_boot_partition+x}" ]; then
    # Enable Grub LUKS encryption support when:
    #  - disk image is encrypted, AND
    #  - remote unlock is not enabled (as otherwise /boot is not encrypted), AND
    #  - Grub LUKS encryption support is not disabled, AND
    #  - /boot is not a separate partition.
    cat <<'EOF' >> "$run_script"
    echo 'GRUB_ENABLE_CRYPTODISK=y' >> /etc/default/grub
EOF
  else
    cat <<'EOF' >> "$run_script"
    echo 'GRUB_ENABLE_CRYPTODISK=n' >> /etc/default/grub
EOF
  fi

  cat <<'EOF' >> "$run_script"
    ###chmod g=,o= /etc/default/grub
  }
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    diff /etc/default/grub-orig /etc/default/grub >> /chroot.log || true
    rm /etc/default/grub-orig

    # Fudge to see what is going on inside grub-mkconfig
    ###sed -i -e 's|^set -e$|set -ex|' /usr/sbin/grub-mkconfig
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"

  write_log "Generating GRUB config" 2
  grub-mkconfig -o /boot/grub/grub.cfg >> /chroot.log 2>&1

  write_log "Checking GRUB config" 2
  grub-script-check /boot/grub/grub.cfg >> /chroot.log

  chmod g=,o= /boot/grub/grub.cfg
}
EOF
}


#
# Setup the config files used by Raspberry Pi bootloader
#
configure_bootloader_rpi() {
  local _cmdline _extra_modules _modules

  ###_modules="sd-mod,usb-storage"
  _modules=""
  _extra_modules="$(define_cmdline_for_modules)"
  if [ -n "${_extra_modules}" ]; then
    if [ -z "${_modules}" ]; then
      _modules="$_extra_modules"
    else
      _modules="$_modules,$_extra_modules"
    fi
  fi
  _cmdline="rootfstype=$image_fs_type ro"
  if [ -n "${_modules}" ]; then
    _cmdline="$_cmdline modules=$_modules"
  fi
  if [ -n "${image_encrypted+x}" ]; then
    _cmdline="$_cmdline root=/dev/mapper/${CONSTANT_LUKS_DEVICE_NAME} \\\$(define_cmdline_for_encryption)"
  elif [ -n "${image_lvm_rootfs+x}" ]; then
    _cmdline="$_cmdline root=/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_ROOT_LV_NAME}"
  else
    _cmdline="$_cmdline root=/dev/mmcblk0p${root_part_num}"
  fi
  if [ -n "${image_disable_ipv6+x}" ]; then
	  _cmdline="$_cmdline ipv6.disable=1"
	fi
  if [ -n "${image_bootchart+x}" ]; then
    _cmdline="$_cmdline chart"
  fi
  _cmdline="$_cmdline console=${image_console_name} quiet"

  if [ -n "${image_extra_cmdline_options+x}" ]; then
    # Add any additionally specified cmdline options
    _cmdline="$_cmdline $image_extra_cmdline_options"
  fi

  cat <<EOF >> "$run_script"

write_log "Create RPI bootloader configuration"
{
  write_log "Creating /boot/cmdline.txt" 2
  cat <<-_SCRIPT_ > /boot/cmdline.txt
	$_cmdline
	_SCRIPT_
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_debug_log "/boot/cmdline.txt contents:" 2
    cat /boot/cmdline.txt >> /chroot.log
  }
EOF
  fi

  cat <<EOF >> "$run_script"

  write_log "Creating /boot/config.txt" 2
  cat <<-_SCRIPT_ > /boot/config.txt
EOF

  if [ "$image_physical_type" = "rpi2" ] || \
     [ "$image_physical_type" = "all-rpi" ]; then
	  # RPI 2
	  cat <<'EOF' >> "$run_script"
	[pi2]
	kernel=vmlinuz-rpi
	initramfs initramfs-rpi
EOF
  fi

  if [ "$image_physical_type" = "rpi3" ] || \
     [ "$image_physical_type" = "all-rpi" ]; then
	  # RPI 3
	  cat <<'EOF' >> "$run_script"
	[pi3]
	kernel=vmlinuz-rpi
	initramfs initramfs-rpi
	[pi3+]
	kernel=vmlinuz-rpi
	initramfs initramfs-rpi
EOF
  fi

  if [ "$image_physical_type" = "rpi4" ] || \
     [ "$image_physical_type" = "all-rpi" ]; then
	  # RPI 4
	  cat <<'EOF' >> "$run_script"
	[pi4]
	enable_gic=1
	kernel=vmlinuz-rpi4
	initramfs initramfs-rpi4
EOF
  fi

  cat <<'EOF' >> "$run_script"
	[all]
EOF

  if [ "$image_arch" = "aarch64" ]; then
	  cat <<'EOF' >> "$run_script"
	arm_64bit=1
EOF
  fi

  cat <<'EOF' >> "$run_script"
	# Set GPU memory to 16MB when using cutdown bootloader
	gpu_mem=16
	include usercfg.txt
	_SCRIPT_
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_debug_log "/boot/config.txt contents:" 2
    cat /boot/config.txt >> /chroot.log
  }
EOF
  fi

  if [ "$image_physical_type" != "all-rpi" ]; then
    if [ "$image_physical_type" != "rpi4" ]; then
	    # RPI 2 or RPI 3
      FIXUP_FILE="fixup_cd.dat"
      START_FILE="start_cd.elf"
    else
	    # RPI 4
      FIXUP_FILE="fixup4cd.dat"
      START_FILE="start4cd.elf"
  	fi
    cat <<EOF >> "$run_script"

  write_log "Creating /boot/usercfg.txt" 2
  cat <<-_SCRIPT_ > /boot/usercfg.txt
	fixup_file=$FIXUP_FILE
	start_file=$START_FILE
	
	# Default is 1
	boot_delay=1
	
	# Do not display rainbow screen.
	disable_splash=1
	
	# Prevent GPU ever going into turbo mode
	disable_auto_turbo=1
	
	# Rotate HDMI output 90 degrees clockwise
	###display_hdmi_rotate=1
	
	# Don't send CEC message during boot
	hdmi_ignore_cec_init=1
	
	# Enable I2C
	dtparam=i2c_arm=on
	
	# Disable Bluetooth
	dtoverlay=disable-bt
	# Disable Wifi
	dtoverlay=disable-wifi

	# Disable audio
	dtparam=audio=off
	
	# Disable I2S
	dtparam=i2s=off
	
	# Disable SPI
	dtparam=spi=off
	
	# Disable UART
	enable_uart=0	
	_SCRIPT_
EOF
  fi

  if [ -n "${rpi_use_rtc+x}" ]; then
    cat <<EOF >> "$run_script"

  write_log "Adding RTC configuration to /boot/usercfg.txt" 2
  cat <<-_SCRIPT_ >> /boot/usercfg.txt
	
	# Enable hardware I2C-based RTC
	dtoverlay=i2c-rtc,ds1307
	_SCRIPT_
EOF
  fi

  if [  -n "${rpi_use_poe_hat+x}" ]; then
    cat <<EOF >> "$run_script"
	
  write_log "Adding PoE HAT configuration to /boot/usercfg.txt" 2
  cat <<-_SCRIPT_ >> /boot/usercfg.txt
	# PoE Hat Fan Speeds - start at 50, full speed by 80
	dtparam=poe_fan_temp0=50000
	dtparam=poe_fan_temp1=60000
	dtparam=poe_fan_temp2=70000
	dtparam=poe_fan_temp3=80000
	_SCRIPT_
EOF
  fi

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_debug_log "/boot/usercfg.txt contents:" 2
    cat /boot/usercfg.txt >> /chroot.log
  }
EOF
  fi

cat <<'EOF' >> "$run_script"
}
EOF
}


#
# Configure Syslinux
#
configure_bootloader_syslinux() {
  local _cmdline _extra_modules _modules_list

  cat <<'EOF' >> "$run_script"

write_log "Configuring Syslinux"
{
  mkdir -p /boot
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    cp /etc/update-extlinux.conf /etc/update-extlinux.conf-orig
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"

  write_log "Updating update-extlinux.conf" 2
  {
EOF

  _cmdline="rootfstype=$image_fs_type"
  if [ "$image_console_type" = "serial" ] || \
     [ "$image_console_type" = "both" ]; then
    _cmdline="$_cmdline console=${serial_port_name},${serial_port_speed}"
  fi
  if [ "$image_console_type" = "normal" ] || \
     [ "$image_console_type" = "both" ]; then
    _cmdline="$_cmdline console=${image_console_name}"
  fi
  if [ "$image_boot_type" = "bios" ]; then
    _cmdline="$_cmdline nomodeset"
  fi
  if [ -n "${image_disable_ipv6+x}" ]; then
    _cmdline="$_cmdline ipv6.disable=1"
  fi
  if [ -n "${image_bootchart+x}" ]; then
    _cmdline="$_cmdline chart"
  fi
  _cmdline="$_cmdline quiet"

  if [ -n "${image_extra_cmdline_options+x}" ]; then
    # Add any additionally specified cmdline options
    _cmdline="$_cmdline $image_extra_cmdline_options"
  fi

  if [ -n "${image_encrypted+x}" ]; then
    _cmdline="$_cmdline \\\$(define_cmdline_for_encryption)"
  fi

  cat <<EOF >> "$run_script"
    kernel_opts="$_cmdline"
EOF

  _modules_list="$image_fs_type"
  _extra_modules="$(define_cmdline_for_modules)"
  if [ -n "${_extra_modules}" ]; then
    _modules_list="$_modules_list,$_extra_modules"
  fi

  if [ -n "${image_encrypted+x}" ]; then
    cat <<EOF >> "$run_script"
    fs_reference="/dev/mapper/${CONSTANT_LUKS_DEVICE_NAME}"
EOF
  elif [ "$image_boot_reference" = "label" ]; then
    # Use LABELs to refer to filesystems
    if [ "$image_boot_type" = "uefi" ]; then
      cat <<EOF >> "$run_script"
    ###fs_reference="LABEL=SYSTEM_EFI"
    fs_reference="LABEL=$CONSTANT_ROOTFS_LABEL"
EOF
    else
      cat <<EOF >> "$run_script"
    fs_reference="LABEL=$CONSTANT_ROOTFS_LABEL"
EOF
    fi
  else
    # Use UUIDs to refer to filesystems
    if [ "$image_boot_type" = "uefi" ]; then
      cat <<'EOF' >> "$run_script"
    ###fs_reference="UUID=$esp_fs_uuid"
    fs_reference="UUID=$root_fs_uuid"
EOF
    else
      cat <<'EOF' >> "$run_script"
    fs_reference="UUID=$root_fs_uuid"
EOF
    fi
  fi

  cat <<EOF >> "$run_script"
    modules="$_modules_list"
EOF

  cat <<'EOF' >> "$run_script"
    sed -i \
      -e 's|^overwrite=(.*)$|overwrite=1|g' \
      -e 's|^hidden=.*$|hidden=0|g' \
      -e 's|^timeout=.*$|timeout=3|g' \
      -e "s|^default_kernel_opts=.*$|default_kernel_opts=\"\$kernel_opts\"|g" \
      -e "s|^root=.*$|root=\$fs_reference|g" \
      /etc/update-extlinux.conf
    if [ -n "\${modules+x}" ]; then
      sed -i -e "s|^modules=.*$|modules=\$modules|g" /etc/update-extlinux.conf
    fi
  }
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_debug_log "diff update-extlinux.conf" 2
    diff /etc/update-extlinux.conf-orig /etc/update-extlinux.conf \\
      >> /chroot.log || true
    rm /etc/update-extlinux.conf-orig
    write_debug_log "update-extlinux.conf contents:" 2
    cat /etc/update-extlinux.conf >> /chroot.log
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"
}
EOF
}


#
# Configure cloud-init
#
configure_cloud_init() {
  cat <<'EOF' >> "$run_script"

write_log "Configuring cloud-init"
{
  write_log "Running setup-cloud-init" 2
  setup-cloud-init >> /chroot.log 2>&1

  write_log "Precompiling cloud-init python files" 2
  _python_dir=\$(find /usr/lib/ -type d -name 'python?.*' -exec basename {} \;)
  python3 -OO -m compileall \
    -q /usr/lib/\${_python_dir}/site-packages/cloudinit >> /chroot.log 2>&1
EOF

  if [ "$image_class" = "cloud" ]; then
    # Cloud
    define_cloud_settings
  elif [ "$image_class" = "physical" ]; then
    # Physical
    datasource_list="'NoCloud'"
  else
    # VM
    define_virtual_settings
  fi

  if [ -n "${cloud_seed_url+x}" ]; then
		datasource_list="'NoCloud'"
    add_seed_network_config_file
  fi

  if [ -z "${datasource_list+x}" ]; then
    datasource_list="'None'"
  else
    datasource_list="$datasource_list,'None'"
  fi

  # Need to sort out serial console settings at this stage, after specific
  # clouds/VM types may/may not have overriden the defaults.
  if [ "$image_console_type" = "serial" ] || \
     [ "$image_console_type" = "both" ]; then
    if [ -z "${serial_port_number+x}" ]; then
      serial_port_number=$CONSTANT_DEFAULT_SERIAL_PORT_NUMBER
      serial_port_name=$CONSTANT_DEFAULT_SERIAL_PORT_NAME
    fi
    if [ -z "${serial_port_speed+x}" ]; then
      serial_port_speed=$CONSTANT_DEFAULT_SERIAL_PORT_SPEED
    fi
  fi

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    cp /etc/cloud/cloud.cfg /etc/cloud/cloud.cfg-orig
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"

  cat <<-_SCRIPT_ > /etc/cloud/cloud.cfg
	# Tailored config file
	
	users:
	   - default
	_SCRIPT_
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  write_log "Unlocking the root account" 2
  cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	   - name: root
	     lock_passwd: False
EOF
  else
    cat <<'EOF' >> "$run_script"

  write_log "Locking the root account" 2
  cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	   - name: root
	     lock_passwd: True
EOF
  fi

  if [ -n "${image_default_user_password+x}" ]; then
    cat <<'EOF' >> "$run_script"
	_SCRIPT_

  write_log "Setting the default user's password" 2
  cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	
	# The password for the default user account, changing it is forced on login.
	password: $default_user_password
EOF
  fi

  cat <<'EOF' >> "$run_script"
	
	mount_default_fields: [~, ~, 'auto', 'defaults,nofail', '0', '2']
	resize_rootfs_tmp: /dev
	
	preserve_hostname: False
	
	# Modules that run in 'init' stage
	cloud_init_modules:
	  - migrator
	  - seed_random
	  - bootcmd
	  - write-files
	  - growpart
	  - resizefs
	  - disk_setup
	  - mounts
	  - set_hostname
	  - update_hostname
	  - update_etc_hosts
	  - resolv_conf
	  - ca-certs
	  - rsyslog
	  - users-groups
	  - ssh

	# Modules that run in 'config' stage
	cloud_config_modules:
	  - locale
	  - set-passwords
	  - apk-configure
	  - ntp
	  - timezone
	  - disable-ec2-metadata
	  - runcmd
	
	# Modules that run in 'final' stage
	cloud_final_modules:
	  - package-update-upgrade-install
	  - write-files-deferred
	  - scripts-vendor
	  - scripts-per-once
	  - scripts-per-boot
	  - scripts-per-instance
	  - scripts-user
	  - ssh-authkey-fingerprints
	  - keys-to-console
	  - install-hotplug
	  - phone-home
	  - final-message
	  - power-state-change

	system_info:
	  distro: alpine
	  default_user:
EOF

  cat <<EOF >> "$run_script"
	_SCRIPT_

  write_log "Setting the default username to '$image_admin_username'" 2
  cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	    name: $image_admin_username
EOF

  if [ "$image_auth_control" = "doas" ] || \
     [ "$image_auth_control" = "both" ]; then
  cat <<EOF >> "$run_script"
	    doas: ["permit nopass $image_admin_username"]
EOF
  fi

  if [ -n "${image_default_user_password+x}" ]; then
    cat <<'EOF' >> "$run_script"
	_SCRIPT_

  write_log "Ensure default user's account is not locked as password is set" 2
  cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	    lock_passwd: False
EOF
  else
    cat <<'EOF' >> "$run_script"
	_SCRIPT_

  write_log "Ensure default user's account is locked (for password access)" 2
  cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	    lock_passwd: True
EOF
  fi

  cat <<'EOF' >> "$run_script"
	    gecos: Default cloud-init user
EOF

  if [ "$image_auth_control" = "sudo" ] || \
     [ "$image_auth_control" = "both" ]; then
  cat <<'EOF' >> "$run_script"
	    groups: [adm, sudo, wheel]
	    sudo: ["ALL=(ALL) NOPASSWD:ALL"]
EOF
  else
  cat <<'EOF' >> "$run_script"
	    groups: [adm, wheel]
EOF
  fi

  cat <<'EOF' >> "$run_script"
	    shell: /bin/ash
	  paths:
	    cloud_dir: /var/lib/cloud/
	    templates_dir: /etc/cloud/templates/
EOF

  if [ "$image_ssh_server" = "openssh" ]; then
  cat <<'EOF' >> "$run_script"
	  ssh_svcname: sshd
EOF
  elif [ "$image_ssh_server" = "tinyssh" ]; then
  cat <<'EOF' >> "$run_script"
	  ssh_svcname: tinysshd
EOF
  fi

  cat <<EOF >> "$run_script"
	_SCRIPT_

  write_log "Setting up DataSources list" 2
  cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	
	datasource_list: [$datasource_list]
EOF

  if [ -n "${datasource_settings+x}" ]; then
    cat <<EOF >> "$run_script"
	datasource:
$datasource_settings
EOF
  fi

  if [ "$image_class" = "cloud" ]; then
    case $image_cloud_type in
      # Enable network interface hotplug for supported DataSources
      aws )
        cat <<'EOF' >> "$run_script"
	
	updates:
	  network:
	    when: ["boot","hotplug"]
EOF
        ;;
    esac
  fi

  cat <<'EOF' >> "$run_script"
	
	###################################################################
	#                     NTP settings
	###################################################################
	
EOF

  if [ "$image_class" = "cloud" ]; then
    # Cloud

    cat <<EOF >> "$run_script"
	ntp:
	  enabled: True
EOF

	  case $image_cloud_type in
		  aws )
        # Sync with AWS' internal NTP server(s)
        cat <<EOF >> "$run_script"
	  servers:
EOF
        if [ -z "${image_disable_ipv4+x}" ]; then
          cat <<EOF >> "$run_script"
	  - $CONSTANT_AWS_NTP_IPV4ADDRESS
EOF
        fi
        if [ -z "${image_disable_ipv6+x}" ]; then
          cat <<EOF >> "$run_script"
	  - $CONSTANT_AWS_NTP_IPV6ADDRESS
EOF
        fi
        ;;

        azure )
          # Sync with host machine's clock (using PTP)
          cat <<'EOF' >> "$run_script"
	  hypervisor_clock: True
EOF
        ;;

		  gce )
        # Sync with GCE' internal NTP server(s)
        cat <<EOF >> "$run_script"
	  servers:
	  - $CONSTANT_GCE_NTP_INTERNAL_SERVER
EOF
        ;;
    esac
  elif [ "$image_class" = "virtual" ]; then
    # Virtual

	  case $image_vm_type in
			libvirtd | lxd | proxmox | qemu )
        cat <<'EOF' >> "$run_script"
	ntp:
	  enabled: True
	  hypervisor_clock: True
EOF
        ;;
    esac
	fi

  cat <<'EOF' >> "$run_script"
	
	###################################################################
	#                     SSH settings
	###################################################################
	
	# Prevent SSH access to root user
	disable_root: True
	
	# Delete any pre-existing SSH hosts keys
	ssh_deletekeys: True
EOF

  if [ "$image_ssh_keytypes" = "ed25519" ]; then
    cat <<'EOF' >> "$run_script"
	
	# Only create ED25519 SSH host key
	ssh_genkeytypes: ["ed25519"]
EOF
  else
    cat <<'EOF' >> "$run_script"
	
	# Only create ED25519 and RSA SSH host keys
	ssh_genkeytypes: ["ed25519","rsa"]
EOF
  fi

  cat <<'EOF' >> "$run_script"
	
	# Disable SSH password authentication
	ssh_pwauth: False
	
	# SSH host key settings
	#-----------------------
	ssh:
	  # Show SSH host keys and their fingerprints on console
	  emit_keys_to_console: True
	#
	# Don't show these SSH host key types on console (DSA is never shown)
	ssh_key_console_blacklist: ["ssh-ecdsa","ssh-ed25519","ssh-rsa"]
	#
	# Don't display SSH host keygen output including VisualArt
	ssh_quiet_keygen: True
	
	# Don't display users' SSH key fingerprints on console.
	no_ssh_fingerprints: True
	
	###################################################################
	
	_SCRIPT_
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    cp /etc/cloud/templates/hosts.alpine.tmpl \
      /etc/cloud/templates/hosts.alpine.tmpl-orig
  }
EOF
  fi

  if [ -n "${image_disable_ipv4+x}" ]; then
    cat <<'EOF' >> "$run_script"

  sed -i \
    -e '/^# The following lines are desirable for IPv4.*$/d' \
    -e '/^127\.0.*$/d' \
    /etc/cloud/templates/hosts.alpine.tmpl
EOF
  elif [ -n "${image_disable_ipv6+x}" ]; then
    cat <<'EOF' >> "$run_script"

  sed -i \
    -e '/^# The following lines are desirable for IPv6.*$/d' \
    -e '/^::1.*$/d' \
    -e '/^ff02::.*$/d' \
    /etc/cloud/templates/hosts.alpine.tmpl
EOF
  fi

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    diff /etc/cloud/cloud.cfg-orig /etc/cloud/cloud.cfg >> /chroot.log || true
    rm /etc/cloud/cloud.cfg-orig

    diff etc/cloud/templates/hosts.alpine.tmpl-orig \
      etc/cloud/templates/hosts.alpine.tmpl \
      >> /chroot.log || true
    rm etc/cloud/templates/hosts.alpine.tmpl-orig

    cp /etc/cloud/cloud.cfg.d/05_logging.cfg \
      /etc/cloud/cloud.cfg.d/05_logging.cfg-orig
  }

  write_log "Enabling cloud-init debugging" 2
  sed -i \
    -E '\$!N; s/(class=.*Handler\n[[:space:]]*)level=INFO/\1level=DEBUG/g ;P;D' \
    /etc/cloud/cloud.cfg.d/05_logging.cfg

  # Debug
  {
    diff /etc/cloud/cloud.cfg.d/05_logging.cfg-orig \
      /etc/cloud/cloud.cfg.d/05_logging.cfg \
      >> /chroot.log || true
    rm /etc/cloud/cloud.cfg.d/05_logging.cfg-orig
  }
EOF
  else
    cat <<'EOF' >> "$run_script"

  write_log "Disabling cloud-init debugging" 2
  sed -i \
    -E '\$!N; s/(class=.*Handler\n[[:space:]]*)level=DEBUG/\1level=INFO/g ;P;D' \
    /etc/cloud/cloud.cfg.d/05_logging.cfg
EOF
  fi

  if [ "$image_class" = "cloud" ]; then
    # Cloud
    case $image_cloud_type in
      azure )
        create_etc_filesystems "ISO" ;;
    esac
  elif [ "$image_class" = "virtual" ]; then
    # Virtual machine
    create_etc_filesystems "ISO"
  else
    # Physical
    create_etc_filesystems "VFAT"
  fi

  if [ "$image_class" = "physical" ]; then
    # Physical
    create_cloud_init_yaml_files
  fi

  cat <<EOF >> "$run_script"
}
EOF
}


#
# Place entries in /etc/fstab for various filesystems
#
configure_fstab() {
  local _boot_mount_options _logs_mount_options _mountpoint
  local _root_mount_options

  cat <<'EOF' >> "$run_script"

write_log "Add /etc/fstab entries"
{
EOF

  # Root filesystem
  _root_mount_options="rw,relatime"
  if [ "$image_fs_type" = "ext4" ] && \
     { [ "$image_boot_device_media" = "flash" ] || \
       [ "$image_boot_device_media" = "sd" ] || \
       [ "$image_boot_device_media" = "ssd" ]; }; then
    # Sync every 5 minutes, rather than the default of every 5 seconds,
    # to reduce writes to flash/SSD storage.
    _root_mount_options="$_root_mount_options,commit=300"
  fi
  if [ -n "${image_encrypted+x}" ]; then
    if [ -n "${image_lvm_rootfs+x}" ]; then
    cat <<EOF >> "$run_script"
  add_fstab_entry DEVICE "/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_ROOT_LV_NAME}" "/" "$image_fs_type" "$_root_mount_options" "rootfs"
EOF
    else
      cat <<EOF >> "$run_script"
  add_fstab_entry DEVICE "/dev/mapper/${CONSTANT_LUKS_DEVICE_NAME}" "/" "$image_fs_type" "$_root_mount_options" "rootfs"
EOF
    fi
  elif [ -n "${image_lvm_rootfs+x}" ]; then
    cat <<EOF >> "$run_script"
  add_fstab_entry DEVICE "/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_ROOT_LV_NAME}" "/" "$image_fs_type" "$_root_mount_options" "rootfs"
EOF
  else
    if [ "$image_class" = "physical" ] && \
       [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
      # RPI
      cat <<EOF >> "$run_script"
  add_fstab_entry LABEL "$CONSTANT_ROOTFS_LABEL" "/" "$image_fs_type" "$_root_mount_options" "rootfs"
EOF
    else
      # Non-RPI
      case $image_boot_reference in
        label )
          cat <<EOF >> "$run_script"
  add_fstab_entry LABEL "$CONSTANT_ROOTFS_LABEL" "/" "$image_fs_type" "$_root_mount_options" "rootfs"
EOF
          ;;
        * )
          cat <<EOF >> "$run_script"
  add_fstab_entry UUID "\$root_fs_uuid" "/" "$image_fs_type" "$_root_mount_options" "rootfs"
EOF
          ;;
      esac
    fi
  fi

  # UEFI ESP
	if [ "$image_boot_type" = "uefi" ]; then
    _mountpoint="/efi"

    case $image_boot_reference in
      label )
        cat <<EOF >> "$run_script"
  add_fstab_entry LABEL "SYSTEM_EFI" "${_mountpoint}" "vfat" "rw" "ESP filesystem"
EOF
        ;;
		  *)
        cat <<EOF >> "$run_script"
  add_fstab_entry UUID "\$esp_fs_uuid" "${_mountpoint}" "vfat" "rw" "ESP filesystem"
EOF
        ;;
		esac

    if [ "$image_bootloader" = "syslinux" ]; then
      cat <<'EOF' >> "$run_script"
  add_fstab_entry BIND "/efi/EFI/BOOT" "/boot" "none" "rw,relatime" "/boot ESP bind-mount"
EOF
    fi
	fi

  # /boot
  if [ -n "${needs_boot_partition+x}" ]; then
    _boot_mount_options="rw,relatime"

    if [ "$image_class" = "physical" ] && \
       [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
      # RPI 2, 3, or 4
      cat <<EOF >> "$run_script"
  mkdir /media/sdcard
  add_fstab_entry LABEL "RPIBOOT" "/media/sdcard" "vfat" "$_boot_mount_options" "/media/sdcard"
  add_fstab_entry BIND "/media/sdcard" "/boot" "none" "$_boot_mount_options" "/boot bind-mount"
EOF
    else
      # Not RPI 2, 3, or 4
      if [ "$image_fs_type" = "ext4" ] && \
         { [ "$image_boot_device_media" = "flash" ] || \
           [ "$image_boot_device_media" = "sd" ] || \
           [ "$image_boot_device_media" = "ssd" ]; }; then
        # Sync every 5 minutes, rather than the default of every 5 seconds,
        # to reduce writes to flash storage.
        _boot_mount_options="$_boot_mount_options,commit=300"
      fi
      if [ "$image_boot_reference" = "label" ]; then
        cat <<EOF >> "$run_script"
  add_fstab_entry LABEL "$CONSTANT_BOOTFS_LABEL" "/boot" "$image_fs_type" "$_boot_mount_options" "boot"
EOF
      else
        cat <<EOF >> "$run_script"
  add_fstab_entry UUID "\$boot_fs_uuid" "/boot" "$image_fs_type" "$_boot_mount_options" "boot"
EOF
      fi
    fi

  elif [ -n "${image_lvm_rootfs+x}" ] && \
       [ -z "${needs_boot_partition+x}" ]; then
    _boot_mount_options="rw,relatime"

    if [ "$image_fs_type" = "ext4" ] && \
       { [ "$image_boot_device_media" = "flash" ] || \
         [ "$image_boot_device_media" = "sd" ] || \
         [ "$image_boot_device_media" = "ssd" ]; }; then
      # Sync every 5 minutes, rather than the default of every 5 seconds,
      # to reduce writes to flash storage.
      _boot_mount_options="$_boot_mount_options,commit=300"
    fi

    cat <<EOF >> "$run_script"
  add_fstab_entry DEVICE "/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_BOOT_LV_NAME}" "/boot" "$image_fs_type" "$_boot_mount_options" "boot"
EOF
  fi

  # logs filesystem
  if [ -n "${image_lvm_rootfs+x}" ]; then
    _logs_mount_options="rw,relatime"
    if [ "$image_fs_type" = "ext4" ] && \
       { [ "$image_boot_device_media" = "flash" ] || \
         [ "$image_boot_device_media" = "sd" ] || \
         [ "$image_boot_device_media" = "ssd" ]; }; then
      # Sync every 5 minutes, rather than the default of every 5 seconds,
      # to reduce writes to flash storage.
      _logs_mount_options="$_logs_mount_options,commit=300"
    fi

    cat <<EOF >> "$run_script"
  add_fstab_entry DEVICE "/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_LOGS_LV_NAME}" "/var/log" "$image_fs_type" "$_logs_mount_options" "logsfs"
EOF
  fi

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_debug_log "Resultant /etc/fstab contents:" 2
    cat /etc/fstab >> "/chroot.log"
  }
EOF
  fi

  cat <<EOF >> "$run_script"
}
EOF
}


#
# Copy LUKS keyfile into place
#
copy_luks_keyfile_into_place() {
  cat <<'EOF' >> "$run_script"

write_log "Moving LUKS keyfile into chroot directory" 2
{
  mv crypto_keyfile.bin "$chroot_dir"/
  chmod 400 "$chroot_dir"/crypto_keyfile.bin
}
EOF
}


#
# For physical machines create the cloud-init YAML config files
#
create_cloud_init_yaml_files() {
  local _grow_device _grow_device_short _grow_part_num _part_grow_message
  local _part_grow_size _resize_command _resize_logs_fs_part _resize_logs_lv
  local _resize_luks_device _resize_pv_device _resize_pv_part
  local _resize_root_fs_part _resize_root_lv _resize_vg

  cat <<'EOF' >> "$run_script"

  write_log "Creating cloud-init YAML files for physical machine"
  {
    write_log "Create example YAML files" 2
    mkdir /cidata/examples

    cat <<-_SCRIPT_ > /cidata/examples/meta-data
	instance-id: iid-local0
	_SCRIPT_

    cat <<-_SCRIPT_ > /cidata/examples/network-dhcp
	version: 2
	ethernets:
	  eth0:
	    dhcpv4: yes
	    dhcpv6: yes
	_SCRIPT_

    cat <<-_SCRIPT_ > /cidata/examples/network-static
	version: 2
	ethernets:
	  eth0:
	    addresses:
	      - 192.168.0.2/24
	    gateway4: 192.168.0.1
	_SCRIPT_

    cat <<-_SCRIPT_ > /cidata/examples/user-data
	#cloud-config
	
	apk_repos:
	  preserve_repositories: False
	  alpine_repo:
EOF

  cat <<EOF >> "$run_script"
	    version: '$image_alpine_release'
	    base_url: $alpine_mirror_site
	    community_enabled: True
EOF

  if [ "$image_alpine_release" = "edge" ]; then
    cat <<'EOF' >> "$run_script"
	    testing_enabled: True
EOF
  else
    cat <<'EOF' >> "$run_script"
	    testing_enabled: False
EOF
  fi

  if [ -n "${local_alpine_repository+x}" ]; then
    cat <<EOF >> "$run_script"
	  local_repo_base_url: $local_alpine_repository
EOF
  fi

  cat <<'EOF' >> "$run_script"
	
	package_reboot_if_required: False
	package_update: False
	package_upgrade: False
	
	debug:
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"
	  verbose: True
EOF
  else
    cat <<'EOF' >> "$run_script"
	  verbose: False
EOF
  fi

  if [ -n "${image_full_hostname+x}" ]; then
    cat <<'EOF' >> "$run_script"
	
	# Hostname including domain
	fqdn: $full_hostname
EOF
  elif [ -n "${image_short_hostname+x}" ]; then
    cat <<'EOF' >> "$run_script"
	
	# Hostname without domain
	hostname: \$short_hostname
EOF
  fi

  cat <<'EOF' >> "$run_script"
	
	locale: \$locale
	timezone: \$timezone
	
	ntp:
	  enabled: True
	  servers:
	    - pool.ntp.org
EOF

  if [ -n "${image_encrypted+x}" ] || \
     [ -n "${image_lvm_rootfs+x}" ] || \
     { [ "$image_boot_device_media" = "flash" ] || \
       [ "$image_boot_device_media" = "sd" ] || \
       [ "$image_boot_device_media" = "ssd" ]; }; then

    # Cannot use cloud-init's growpart and resize_rootfs
    cat <<EOF >> "$run_script"
	
	# Growpart & resize does not work for LUKS or LVM currently
	# so this will be handled via runcmd instead.
	growpart:
	  mode: False
	resize_rootfs: False
EOF

    if [ "$image_boot_device_media" = "flash" ] || \
       [ "$image_boot_device_media" = "sd" ] || \
       [ "$image_boot_device_media" = "ssd" ]; then
      # Leave a percentage of disk unallocated for "overprovisioning"
      _disk_leave_free_percent=$image_resize_free_percent
      _part_grow_message=" leaving ${_disk_leave_free_percent}% of device unused"
    else
      _disk_leave_free_percent="0"
    fi
    _part_grow_size="$((100-$_disk_leave_free_percent))%"

    if [ -n "${image_encrypted+x}" ]; then
      # LUKS or LVM-on-LUKS

      _grow_part_num="$luks_part_num"
      _resize_luks_device="$CONSTANT_LUKS_DEVICE_NAME"
      if [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ] ||
         [ "$image_boot_device_type" = "sd" ]; then
        # RPI or PC with SDcard boot device
        _grow_device_short="mmcblk0"
      elif [ "$image_boot_device_type" = "nvme" ]; then
        # PC with NVME boot device
        _grow_device_short="nvme0n1"
      else
        # SATA, SCSI, or USB boot device
        _grow_device_short="sda"
      fi
      _grow_device="/dev/${_grow_device_short}"
      _resize_root_fs_part="/dev/mapper/$CONSTANT_LUKS_DEVICE_NAME"

      cat <<EOF >> "$run_script"
	
	runcmd:
	  # Grow the LUKS partition${_part_grow_message:-}
	  - parted --machine --script --align=optimal $_grow_device resizepart $_grow_part_num $_part_grow_size
	  # Grow LUKS to fill the partition
	  - cryptsetup resize ${_resize_luks_device}
EOF

      if [ -n "${image_lvm_rootfs+x}" ]; then
        # LVM-on-LUKS
        _resize_pv_device="/dev/mapper/$CONSTANT_LUKS_DEVICE_NAME"
        _resize_vg="$CONSTANT_LVM_VG_NAME"
        _resize_logs_lv="$CONSTANT_LVM_LOGS_LV_NAME"
        _resize_root_lv="$CONSTANT_LVM_ROOT_LV_NAME"
        _resize_logs_fs_part="/dev/mapper/${_resize_vg}-${_resize_logs_lv}"
        _resize_root_fs_part="/dev/mapper/${_resize_vg}-${_resize_root_lv}"
        cat <<EOF >> "$run_script"
	  # Grow the LVM PV to fill the LUKS partition
	  - pvresize resize ${_resize_pv_device}
	  # Don't resize the root LV at all
	  #
	  # Grow the logs LV by 10M
	  - lvextend -L +10m $_resize_logs_lv
EOF
      fi

    elif [ -n "${image_lvm_rootfs+x}" ]; then

      # LVM
      _grow_part_num="$lvm_part_num"
      _resize_vg="$CONSTANT_LVM_VG_NAME"
      _resize_logs_lv="$CONSTANT_LVM_LOGS_LV_NAME"
      _resize_root_lv="$CONSTANT_LVM_ROOT_LV_NAME"
      _resize_logs_fs_part="/dev/mapper/${_resize_vg}-${_resize_logs_lv}"
      _resize_root_fs_part="/dev/mapper/${_resize_vg}-${_resize_root_lv}"
      if [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ] ||
         [ "$image_boot_device_type" = "sd" ]; then
        # RPI or PC with SDcard boot device
        _grow_device_short="mmcblk0"
        _resize_pv_part="/dev/${_grow_device_short}p${lvm_part_num}"
      elif [ "$image_boot_device_type" = "nvme" ]; then
        # PC with NVME boot device
        _grow_device_short="nvme0n1"
        _resize_pv_part="/dev/${_grow_device_short}p${lvm_part_num}"
      else
        # SATA, SCSI, or USB boot device
        _grow_device_short="sda"
        _resize_pv_part="/dev/${_grow_device_short}${lvm_part_num}"
      fi
      _grow_device="/dev/${_grow_device_short}"

      cat <<EOF >> "$run_script"
	
	runcmd:
	  # Grow the LVM partition${_part_grow_message:-}
	  - parted --machine --script --align=optimal $_grow_device resizepart $_grow_part_num $_part_grow_size
	  # Grow the LVM PV to fill the partition
	  - pvresize $_resize_pv_part
	  # Don't resize the root LV at all
	  #
	  # Grow the logs LV by 10M
	  - lvextend -L +10m $_resize_logs_lv
EOF
    else
      # Neither LUKS nor LVM

      _grow_part_num="$root_part_num"

      if [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ] ||
         [ "$image_boot_device_type" = "sd" ]; then
        # RPI or PC with SDcard boot device
        _grow_device_short="mmcblk0"
        _resize_root_fs_part="/dev/${_grow_device_short}p${root_part_num}"
      elif [ "$image_boot_device_type" = "nvme" ]; then
        # PC with NVME boot device
        _grow_device_short="nvme0n1"
        _resize_root_fs_part="/dev/${_grow_device_short}p${root_part_num}"
      else
        # SATA, SCSI, or USB boot device
        _grow_device_short="sda"
        _resize_root_fs_part="/dev/${_grow_device_short}${root_part_num}"
      fi
      _grow_device="/dev/${_grow_device_short}"

      if [ "$image_alpine_release" = "v3.13" ] || \
         [ "$image_alpine_release" = "v3.14" ] || \
         [ "$image_alpine_release" = "v3.15" ]; then
        # growpart with no overprovisioning support

        cat <<EOF >> "$run_script"
	
	runcmd:
	  # Grow the root partition${_part_grow_message:-}
	  - parted --machine --script --align=optimal $_grow_device resizepart $_grow_part_num $_part_grow_size
EOF
      else
        # growpart version that does support overprovisioning
        cat <<EOF >> "$run_script"
	
	runcmd:
	  # Grow the root partition${_part_grow_message:-}
	  - growpart --free-percent=$_disk_leave_free_percent $_grow_device $_grow_part_num
EOF
      fi
    fi

    if [ -z "${image_lvm_rootfs+x}" ]; then
      # root is not on LVM so resize it

      cat <<EOF >> "$run_script"
	  # Resize the underlying root filesystem
EOF

      case $image_fs_type in
        btrfs )
          _resize_command="btrfs filesystem resize max $_resize_root_fs_part" ;;
        ext4 )
          _resize_command="resize2fs $_resize_root_fs_part" ;;
        f2fs )
          _resize_command="resize.f2fs $_resize_root_fs_part" ;;
        xfs )
          _resize_command="xfs_growfs $_resize_root_fs_part" ;;
      esac

      cat <<EOF >> "$run_script"
	  - $_resize_command
EOF
    fi

    if [ -n "${image_lvm_rootfs+x}" ]; then
      cat <<EOF >> "$run_script"
	  # Resize the underlying logs filesystem
EOF
      case $image_fs_type in
        btrfs )
          _resize_command="btrfs filesystem resize max $_resize_logs_fs_part" ;;
        ext4 )
          _resize_command="resize2fs $_resize_logs_fs_part" ;;
        f2fs )
          _resize_command="resize.f2fs $_resize_logs_fs_part" ;;
        xfs )
          _resize_command="xfs_growfs $_resize_logs_fs_part" ;;
      esac
      cat <<EOF >> "$run_script"
	  - $_resize_command
EOF
    fi
  else
    cat <<'EOF' >> "$run_script"
	
	# Grow the root partition and resize rootfs to fill it
	growpart:
	  mode: auto
	resize_rootfs: True
EOF
  fi

  cat <<'EOF' >> "$run_script"
	
	ssh:
	  # Whether to show either host keys or their fingerprints on console
	  emit_keys_to_console: False
EOF

  if [ -n "${ssh_public_key+x}" ]; then
    cat <<EOF >> "$run_script"
	
	users:
	  - default
	  - name: $image_admin_username
	    ssh_authorized_keys:
EOF
    # shellcheck disable=SC2028
    echo "\t      - '$ssh_public_key'" >> "$run_script"
  fi

  cat <<'EOF' >> "$run_script"
	
	_SCRIPT_

    write_log "Creating meta-data" 2
    cp /cidata/examples/meta-data /cidata/meta-data

    write_log "Creating network-config" 2
    cp /cidata/examples/network-dhcp /cidata/network-config

    write_log "Creating user-data" 2
    cp /cidata/examples/user-data /cidata/user-data
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

    # Debug
    {
      write_debug_log "meta-data contents:" 2
      cat /cidata/meta-data >> /chroot.log

      write_debug_log "network-config contents:" 2
      cat /cidata/network-config >> /chroot.log

      write_debug_log "user-data contents:" 2
      cat /cidata/user-data >> /chroot.log
    }
EOF
  fi

  cat <<'EOF' >> "$run_script"
  }
EOF
}


#
# Create /etc/filesystems for Busybox mount
#
create_etc_filesystems() {
  local _config_fs_type=$1

  # Busybox mount command requires the following config

  cat <<EOF >> "$run_script"

  write_log "Setting up /etc/filesystems for $_config_fs_type mount" 2
  {
    cat <<-_SCRIPT_ > /etc/filesystems
	#
	# /etc/filesystems
	#
	
	# Needed for cloud-init cidata $_config_fs_type
EOF

  if [ "$_config_fs_type" = "ISO" ]; then
    cat <<'EOF' >> "$run_script"
	iso9660
	_SCRIPT_
EOF
  else
    cat <<'EOF' >> "$run_script"
	vfat
	_SCRIPT_
EOF
  fi

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

    # Debug
    {
      write_debug_log "/etc/filesystems content:" 4
      cat /etc/filesystems >> /chroot.log
    }
EOF
  fi

  cat <<'EOF' >> "$run_script"
  }
EOF
}


#
# Create an init.d script for preventing the loading of kernel modules
#
create_module_blocking_initd() {
  cat <<'EOF' >> "$run_script"

write_log "Creating init.d script for disabling kernel module loading" 2
{
  cat <<-_SCRIPT_ > /etc/init.d/block-modules-loading
	#!/sbin/openrc-run
	
	description="Disable loading of kernel modules"
	
	depend() {
		after *
		keyword -openvz -prefix -uml -vserver -xenu -lxc
	}
	
	start() {
		ebegin "Disabling loading of kernel modules"
		sysctl -q -w kernel.modules_disabled=1
		eend $?
	}
	_SCRIPT_
  chmod a+x /etc/init.d/block-modules-loading
  {
EOF
  add_init_d_service "block-modules-loading" "default" 4

  cat <<'EOF' >> "$run_script"
  } >> /chroot.log 2>&1
}
EOF
}


#
# Define list of packages in addition to base Alpine
#
define_additional_packages() {
  local _initial_pkgs

  _initial_pkgs="ca-certificates chrony htop kbd-bkeymaps logrotate"
  _initial_pkgs="$_initial_pkgs musl-locales rng-tools sshguard"
	if [ -z "${image_without_cloud_init+x}" ]; then
    _initial_pkgs="$_initial_pkgs cloud-init"
	else
    _initial_pkgs="$_initial_pkgs cloud-utils-growpart ifupdown-ng-iproute2"
    _initial_pkgs="$_initial_pkgs iproute2-minimal tzdata"
  fi
  if [ "${image_mdev}" = false ]; then
    _initial_pkgs="$_initial_pkgs eudev"
  fi

  if [ -n "${image_bootchart+x}" ]; then
    _initial_pkgs="$_initial_pkgs acct"
  fi

  case $image_auth_control in
    doas )
      _initial_pkgs="$_initial_pkgs doas"
      ;;
    sudo )
      _initial_pkgs="$_initial_pkgs sudo"
      ;;
    both )
      _initial_pkgs="$_initial_pkgs doas sudo"
      ;;
  esac

  case $image_dhcp_client in
    dhclient )
      _initial_pkgs="$_initial_pkgs dhclient"
      ;;
    dhcpcd )
      _initial_pkgs="$_initial_pkgs dhcpcd"
      ;;
  esac

  if [ -n "${image_enable_utmp+x}" ]; then
    _initial_pkgs="$_initial_pkgs utmps"
  fi

  if [ -n "${image_encrypted+x}" ]; then
    _initial_pkgs="$_initial_pkgs cryptsetup"
    if [ -n "${remote_unlock_enabled+x}" ]; then
      _initial_pkgs="$_initial_pkgs dropbear-convert dropbear-unlockdisk"
    fi
  fi

  case $image_firewall in
    awall )
      _initial_pkgs="$_initial_pkgs awall awall-masquerade awall-policies"
      ;;
    iptables )
      _initial_pkgs="$_initial_pkgs iptables"
      if [ -z "${image_disable_ipv6+x}" ]; then
        _initial_pkgs="$_initial_pkgs ip6tables"
      fi
      ;;
    nftables )
      _initial_pkgs="$_initial_pkgs nftables"
      ;;
  esac

  if [ "$image_boot_device_media" = "sd" ] || \
     [ "$image_boot_device_media" = "ssd" ]; then
    # Require fstrim command, so install relevant package
    case $image_alpine_release in
      v3.13 | v3.14 )
        _initial_pkgs="$_initial_pkgs util-linux" ;;
      v3.15 )
        _initial_pkgs="$_initial_pkgs util-linux-misc" ;;
      * )
        _initial_pkgs="$_initial_pkgs fstrim" ;;
    esac
  fi

  if [ "${image_fs_type}" = "btrfs" ]; then
    _initial_pkgs="$_initial_pkgs btrfs-progs btrfs-progs-extra"
  elif [ "${image_fs_type}" = "ext4" ]; then
    _initial_pkgs="$_initial_pkgs e2fsprogs-extra"
  elif [ "${image_fs_type}" = "f2fs" ]; then
    _initial_pkgs="$_initial_pkgs f2fs-tools"
  elif [ "${image_fs_type}" = "xfs" ]; then
    _initial_pkgs="$_initial_pkgs xfsprogs xfsprogs-extra"
  fi

  if [ -n "${image_lvm_rootfs+x}" ]; then
    _initial_pkgs="$_initial_pkgs lvm2"
    ###_initial_pkgs="$_initial_pkgs lvm2-dmeventd"
  fi

  case $image_ssh_server in
    dropbear )
      _initial_pkgs="$_initial_pkgs dropbear" ;;
    openssh )
      if [ -z "${image_without_cloud_init+x}" ] || \
         [ -n "${image_pam_enabled+x}" ]; then
        _initial_pkgs="$_initial_pkgs openssh-server-pam"
      else
        _initial_pkgs="$_initial_pkgs openssh-server"
      fi
      ;;
    tinyssh )
      _initial_pkgs="$_initial_pkgs tinyssh openssh-sftp-server" ;;
  esac

  case $image_syslog_server in
    rsyslog )
      _initial_pkgs="$_initial_pkgs rsyslog" ;;
  esac

  if [ "$image_class" = "cloud" ]; then
    # Cloud Providers
    case $image_cloud_type in
      aws )
        _initial_pkgs="${_initial_pkgs} aws-cli nvme-cli" ;;
      azure )
        _initial_pkgs="${_initial_pkgs} hvtools" ;;
      digitalocean )
         if [ "$image_alpine_release" != "v3.13" ] && \
            [ "$image_alpine_release" != "v3.14" ] && \
            [ "$image_alpine_release" != "v3.15" ]; then
          _initial_pkgs="${_initial_pkgs} doctl"
         fi
         ;;
      gce )
        _initial_pkgs="${_initial_pkgs} nvme-cli" ;;
      hetzner )
        _initial_pkgs="${_initial_pkgs} hcloud" ;;
      ###vultr )
      ###  _initial_pkgs="${_initial_pkgs} vultr-cli" ;;
    esac
  elif [ "$image_class" = "physical" ]; then
    # Physical machine
    if [ "$image_physical_type" = "pc" ]; then
      # PC
      _initial_pkgs="${_initial_pkgs} irqbalance nvme-cli"
      if [ "$image_boot_device_type" = "sd" ]; then
        _initial_pkgs="${_initial_pkgs} mmc-utils"
      fi
    elif [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
      # RPI
	  	_initial_pkgs="${_initial_pkgs} irqbalance raspberrypi"
      if [ "$image_alpine_release" != "v3.13" ] && \
         [ "$image_alpine_release" != "v3.14" ]; then
  	  	_initial_pkgs="${_initial_pkgs} mmc-utils"
      fi
    fi
    # Packages for all types of physical machines
    _initial_pkgs="${_initial_pkgs} ethtool lm-sensors lm-sensors-sensord"
  elif [ "$image_class" = "virtual" ]; then
    # Virtual Machine
    case $image_vm_type in
      hyperv )
        _initial_pkgs="${_initial_pkgs} hvtools" ;;
      libvirtd | lxd | proxmox | qemu )
        _initial_pkgs="${_initial_pkgs} qemu-guest-agent" ;;
      virtualbox )
        _initial_pkgs="${_initial_pkgs} virtualbox-guest-additions" ;;
      vmware )
        _initial_pkgs="${_initial_pkgs} open-vm-tools open-vm-tools-guestinfo"
        _initial_pkgs="${_initial_pkgs} open-vm-tools-timesync open-vm-tools-vix"
				;;
    esac
  fi

###  if [ -n "${add_packages_list+x}" ]; then
###    _initial_pkgs="${_initial_pkgs} ${add_packages_list}"
###  fi

  echo "$_initial_pkgs"
}


#
# Define the cloud-init DataSource(s) to enable for the relevant Cloud type
#
define_cloud_settings() {
  case $image_cloud_type in
    generic )
      datasource_list="'AliYun','Azure','BigStep','ConfigDrive','DigitalOcean','E24Cloud','Ec2','Exoscale','GCE','Hetzner','IBMCloud','Oracle','RbxCloud','Scaleway','UpCloud','Vultr'" ;;
    aliyun )
      datasource_list="'AliYun'" ;;
    aws )
      datasource_list="'Ec2'"
      if [ "$image_arch" = "aarch64" ]; then
        image_console_name="ttyAMA1"
      fi
      image_console_type="both"
      if [ "$image_console_type" = "serial" ] || \
         [ "$image_console_type" = "both" ]; then
        serial_port_number="0"
        if [ "$image_arch" = "aarch64" ]; then
          serial_port_name="ttyAMA${serial_port_number}"
        else
          serial_port_name="ttyS${serial_port_number}"
        fi
      fi
      ;;
    azure )
      datasource_list="'Azure'" ;;
    bigstep )
      datasource_list="'Bigstep'" ;;
    brightbox )
      datasource_list="'Ec2'" ;;
    digitalocean )
      datasource_list="'DigitalOcean'"
      image_console_type="both"
      serial_port_number="0"
      serial_port_name="ttyS${serial_port_number}"
      ;;
    e24 )
      datasource_list="'E24Cloud'" ;;
    exoscale )
      datasource_list="'Exoscale'" ;;
    gce )
      datasource_list="'GCE'" ;;
    hetzner )
      datasource_list="'Ec2'" ;;
    hyperone )
      datasource_list="'RbxCloud'" ;;
    ibmcloud )
      datasource_list="'IBMCloud'" ;;
    oracle )
      datasource_list="'Oracle'"
      if [ "$image_arch" = "aarch64" ]; then
        image_console_name="ttyAMA1"
      fi
      image_console_type="both"
      if [ "$image_console_type" = "serial" ] || \
         [ "$image_console_type" = "both" ]; then
        serial_port_number="0"
        if [ "$image_arch" = "aarch64" ]; then
          serial_port_name="ttyAMA${serial_port_number}"
        else
          serial_port_name="ttyS${serial_port_number}"
        fi
      fi
      ;;
    rootbox )
      datasource_list="'RbxCloud'" ;;
    scaleway )
      datasource_list="'Scaleway'" ;;
    tencent )
      datasource_list="'ConfigDrive'" ;;
    upcloud )
      datasource_list="'UpCloud'" ;;
    vultr )
      datasource_list="'Vultr'"
      image_console_type="normal"
      ;;
  esac
}


#
# Define entries for kernel command line modules list
#
define_cmdline_for_modules() {
  local _list_of_modules

  ###_list_of_modules="rng-core"
  ###if [ "$image_class" = "virtual" ]; then
  ###  case $image_vm_type in
  ###    libvirtd | lxd | proxmox | qemu | generic )
  ###      _list_of_modules="$_list_of_modules,virtio-rng" ;;
  ###  esac
  ###fi
  ###if [ "$image_class" = "cloud" ] || \
  ###   [ "$image_class" = "virtual" ]; then
  ###_list_of_modules="$_list_of_modules,tiny-power-button"
  ###fi

  ###_list_of_modules="$_list_of_modules,jitterentropy_rng"

  ###if [ -z "${image_disable_ipv6+x}" ]; then
  ###  if [ -n "${_list_of_modules+x}" ]; then
  ###    _list_of_modules="$_list_of_modules,ipv6"
  ###  else
  ###    _list_of_modules="ipv6"
  ###  fi
  ###fi

  echo "${_list_of_modules:-}"
}


#
#
#
add_seed_network_config_file() {
  cat <<'EOF' >> "$run_script"

  write_log "Creating seed network configuration file" 2
  mkdir -p /var/lib/cloud/seed/nocloud
  cat <<-_SCRIPT_ > /var/lib/cloud/seed/nocloud/network-config
	version: 2
	ethernets:
	  eth0:
EOF

  if [ -z "${image_disable_ipv4+x}" ]; then
    cat <<'EOF' >> "$run_script"
	    dhcp4: True
EOF
  fi

  if [ -z "${image_disable_ipv6+x}" ]; then
    cat <<'EOF' >> "$run_script"
	    dhcp6: True
EOF
  fi

  cat <<'EOF' >> "$run_script"
	_SCRIPT_
EOF
}


#
# Define the cloud-init DataSource(s) to enable for the relevant VM type
#
define_virtual_settings() {
  case $image_vm_type in
    hyperv )
      datasource_list="'NoCloud'" ;;
    libvirtd | lxd | proxmox | qemu )
      datasource_list="'NoCloud'"
      if { [ "$image_console_type" = "serial" ] || \
           [ "$image_console_type" = "both" ]; } && \
         { [ "$image_arch" = "armv7" ] || \
           [ "$image_arch" = "aarch64" ]; }; then
        serial_port_number="0"
        serial_port_name="ttyAMA${serial_port_number}"
      fi
      ;;
    opennebula )
      datasource_list="'Opennebula'" ;;
    openstack )
      datasource_list="'Openstack'" ;;
    rhevm )
      datasource_list="'AltCloud'" ;;
    virtualbox )
      datasource_list="'NoCloud'" ;;
    vmware )
      datasource_list="'OVF'" ;;
    vsphere )
      datasource_list="'AltCloud'" ;;
    generic )
      datasource_list="'AltCloud','ConfigDrive','Opennebula','Openstack','NoCloud','OVF'" ;;
  esac
  if [ "$datasource_list" = "'NoCloud'" ] && \
     [ -n "${cloud_seed_url+x}" ]; then
    datasource_settings="$(printf \\t%s\\n "  NoCloud:" "    seedfrom: $cloud_seed_url")"
  fi
}


#
# Delete unnecessary users & groups
#
delete_users_groups() {
  cat <<'EOF' >> "$run_script"

write_log "Delete unnecessary users and groups"
{
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"
  # Debug
  {
    cp /etc/group /etc/group-orig
    cp /etc/passwd /etc/passwd-orig
EOF

    if [ "$image_mdev" = false ]; then
      cat <<'EOF' >> "$run_script"

    cp /lib/udev/rules.d/50-udev-default.rules \
      /lib/udev/rules.d/50-udev-default.rules-orig
EOF
    fi

    cat <<'EOF' >> "$run_script"
  }

EOF
  fi

  cat <<'EOF' >> "$run_script"
  write_log "Delete unnecessary users" 2
  {
    _unreq_users_list="cyrus ftp games guest halt lp man news ntp operator"
    _unreq_users_list="\$_unreq_users_list postmaster shutdown smmsp squid"
    _unreq_users_list="\$_unreq_users_list sync vpopmail xfs"

    for _unrequired_user in \$_unreq_users_list
    do
      write_debug_log "Delete user '\$_unrequired_user'" 4
      deluser \$_unrequired_user 2> /dev/null
    done
  }

  {
    _unreq_groups_list="abuild cdrw tape"

    write_log "Delete unnecessary groups" 2
    {
      for _unrequired_group in \$_unreq_groups_list
      do
        write_debug_log "Delete group '\$_unrequired_group'" 4
        delgroup \$_unrequired_group
      done
    }
EOF

  if [ "$image_mdev" = false ]; then
    cat <<'EOF' >> "$run_script"

    write_log "Remove references to deleted groups from udev rules" 4
    {
      write_debug_log "Rewrite any wrapped lines into single lines" 6
      sed -i -e ':x;/\\$/{N;s/\\\n//g;bx;}' -e 's/ [ ]*/ /g' \
        /lib/udev/rules.d/50-udev-default.rules
      for _unrequired_group in \$_unreq_groups_list
      do
        write_debug_log "Remove group \$_unrequired_group references" 6
        sed -i -e "/^.*GROUP=\"\$_unrequired_group\".*$/d" \
          /lib/udev/rules.d/50-udev-default.rules
      done
    }
EOF
  fi

  cat <<'EOF' >> "$run_script"
  }
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_debug_log "Users differences:" 2
    diff /etc/passwd-orig /etc/passwd >> /chroot.log || true

    write_debug_log "Groups differences:" 2
    diff /etc/group-orig /etc/group >> /chroot.log || true

    rm /etc/group-orig /etc/passwd-orig
EOF

    if [ "$image_mdev" = false ]; then
      cat <<'EOF' >> "$run_script"

    write_debug_log "50-udev-default.rules differences:" 2
    diff /lib/udev/rules.d/50-udev-default.rules-orig \
      /lib/udev/rules.d/50-udev-default.rules >> /chroot.log || true
EOF
    fi

  cat <<'EOF' >> "$run_script"
  }
}
EOF
  fi
}


#
# Disable most of the gettys normally configured to run
#
disable_extra_getty() {
  local _first_getty_to_disable

  cat <<'EOF' >> "$run_script"

write_log "Disabling extra getty processes"
{
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    cp /etc/inittab /etc/inittab-orig
  }
EOF
  fi

  if [ "$image_class" = "cloud" ] || \
     [ "$image_class" = "virtual" ]; then
    # Only have 1 getty for cloud/virtual machines
    _first_getty_to_disable="2"
  else
    # Keep 2 gettys for physical machines
    _first_getty_to_disable="3"
  fi

  cat <<EOF >> "$run_script"

  sed -i -E -e 's|^tty([${_first_getty_to_disable}-6].*)|#tty\1|g' /etc/inittab
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    diff /etc/inittab-orig /etc/inittab >> /chroot.log || true
    rm /etc/inittab-orig
  }
EOF
  fi

  cat <<EOF >> "$run_script"
}
EOF
}


#
# Disable non-server specific kernel modules
#
disable_kernel_modules() {
  local _disable_modules

  cat <<'EOF' >> "$run_script"

write_log "Disable non-server kernel modules"
EOF

  # Drivers
  #---------

  _disable_modules="$CONSTANT_DESKTOP_KERNEL_MODULES"
  if [ "$image_class" != "physical" ] || \
     [ "$(expr "$image_physical_type" : '.*rpi.*')" -eq 0 ]; then
    _disable_modules="$_disable_modules $CONSTANT_VIRTUAL_XEN_KERNEL_MODULES"
  fi

  if [ "$image_class" = "cloud" ]; then
    # Cloud

    # ENA
    if [ "$image_cloud_type" != "aws" ] && \
       [ "$image_cloud_type" != "generic" ]; then
      _disable_modules="$_disable_modules $CONSTANT_CLOUD_AWS_KERNEL_MODULES"
    fi
    # HV
    if [ "$image_cloud_type" != "azure" ] && \
       [ "$image_cloud_type" != "generic" ]; then
      _disable_modules="$_disable_modules $CONSTANT_CLOUD_AZURE_KERNEL_MODULES"
    fi
    if [ "$image_cloud_type" != "gce" ] && \
       [ "$image_cloud_type" != "generic" ]; then
      _disable_modules="$_disable_modules $CONSTANT_CLOUD_GCE_KERNEL_MODULES"
    fi

    # Disable all VM modules
    _disable_modules="$_disable_modules vmwgfx $CONSTANT_VIRTUAL_KERNEL_MODULES"

    # PTP
    if [ "$image_cloud_type" != "azure" ] && \
       [ "$image_cloud_type" != "generic" ]; then
      _disable_modules="$_disable_modules ptp"
    fi
    if [ "$image_cloud_type" != "generic" ]; then
      _disable_modules="$_disable_modules ptp_kvm"
    fi
    ###_disable_modules="$_disable_modules ptp_vmw"
  elif [ "$image_class" = "physical" ]; then
    # Physical

    if [ "$(expr "$image_physical_type" : '.*rpi.*')" -ne 0 ]; then
      # RPI has no ACPI so neither 'button' nor 'tiny-power-button' are used
      _disable_modules="$_disable_modules button tiny-power-button"
      # RPI as server does not need multimedia-related modules
      _disable_modules="$_disable_modules bcm2835_codec bcm2835_isp"
			_disable_modules="$_disable_modules bcm2835_mmal_vchiq bcm2835_v4l2"
      _disable_modules="$_disable_modules backlight cec drm drm_kms_helper"
			_disable_modules="$_disable_modules drm_panel_orientiation_quirks"
      _disable_modules="$_disable_modules fb_sys_fops i2c-bcm2708 input_leds mc"
      _disable_modules="$_disable_modules snd snd-pcm snd-pcm-dmaengine"
			_disable_modules="$_disable_modules snd-soc-core snd-timer"
      _disable_modules="$_disable_modules syscopyarea sysfillrect sysimgblt"
      _disable_modules="$_disable_modules uio uio_pdrv_genirq"
      _disable_modules="$_disable_modules vc_sm_cma vc4"
      _disable_modules="$_disable_modules videobuf2_common videobuf2_dma_contig"
			_disable_modules="$_disable_modules videobuf2_memops videobuf2_vmalloc"
			_disable_modules="$_disable_modules videobuf2_v4l2 videodev v4l2_mem2mem"
    fi
    # 'button' is instead used on Physical machines
    _disable_modules="$_disable_modules tiny-power-button"

    # Disable all cloud provider and virtual modules on x86/x86_64 physical machines
    if [ "$(expr "$image_physical_type" : '.*rpi.*')" -eq 0 ]; then
      _disable_modules="$_disable_modules $CONSTANT_CLOUD_KERNEL_MODULES"
      _disable_modules="$_disable_modules $CONSTANT_VIRTUAL_KERNEL_MODULES"
      _disable_modules="$_disable_modules $CONSTANT_CLOUD_VIRTUAL_COMMON_KERNEL_MODULES"
    fi
  elif [ "$image_class" = "virtual" ]; then
    # Virtual

    if [ "$image_vm_type" != "generic" ]; then
      # Not generic
      if [ "$image_vm_type" != "hyperv" ]; then
        _disable_modules="$_disable_modules $CONSTANT_VIRTUAL_HYPERV_KERNEL_MODULES"
      fi
      if [ "$image_vm_type" != "libvirtd" ] && \
         [ "$image_vm_type" != "lxd" ] && \
         [ "$image_vm_type" != "proxmox" ] && \
         [ "$image_vm_type" != "qemu" ]; then
				# Disable KVM/QEMU-derived modules
        _disable_modules="$_disable_modules ptp_kvm virtio_rng"
      fi
			if [ "$image_vm_type" != "hyperv" ] && \
         [ "$image_vm_type" != "libvirtd" ] && \
         [ "$image_vm_type" != "lxd" ] && \
         [ "$image_vm_type" != "proxmox" ] && \
         [ "$image_vm_type" != "qemu" ] && \
         [ "$image_vm_type" != "vmware" ]; then
        _disable_modules="$_disable_modules ptp"
			fi
      if [ "$image_vm_type" != "vmware" ]; then
        # Disable VMware modules
        _disable_modules="$_disable_modules $CONSTANT_VIRTUAL_VMWARE_KERNEL_MODULES"
      fi
      if [ "$image_vm_type" != "virtualbox" ] && \
         [ "$image_vm_type" != "vmware" ]; then
        _disable_modules="$_disable_modules vmwgfx"
      fi
    fi

    # Disable all cloud provider modules
    _disable_modules="$_disable_modules $CONSTANT_CLOUD_KERNEL_MODULES"
  fi

  if [ "$image_class" = "cloud" ] || \
     [ "$image_class" = "virtual" ]; then
    # Cloud or Virtual

    #_disable_modules="$_disable_modules ac battery"
    _disable_modules="$_disable_modules $CONSTANT_PHYSICAL_KERNEL_MODULES"
    #### 'tiny-power-button' is used on Cloud and VM images
    ###_disable_modules="$_disable_modules button"
    _disable_modules="$_disable_modules hid ehci_hcd ehci_pci ehci_platform"
    _disable_modules="$_disable_modules ohci_hcd ohci_pci ohci_platform"
    _disable_modules="$_disable_modules uhci_pci usbcore xhci_hcd xhci_pci"
  fi

  blacklist_list_of_kernel_modules "drivers" "$_disable_modules"
  disable_list_of_kernel_modules "drivers" "$_disable_modules"


  # Net
  #-----

  _disable_modules="$CONSTANT_UNUSED_NET_KERNEL_MODULES"
  if [ "$image_class" = "virtual" ]; then
    # Virtual
    if [ "$image_vm_type" != "vmware" ] && \
       [ "$image_vm_type" != "generic" ]; then
      _disable_modules="$_disable_modules $CONSTANT_NET_VMWARE_KERNEL_MODULES"
    fi
  fi

  blacklist_list_of_kernel_modules "net" "$_disable_modules"
  disable_list_of_kernel_modules "net" "$_disable_modules"
}


#
# Disable a set of specified kernel modules
#
disable_list_of_kernel_modules() {
  local _modules_section=$1
  local _disable_list="$2"

  local _module_name

  cat <<EOF >> "$run_script"

write_log "Disabling ${_modules_section} kernel modules" 2
{
  cat <<-_SCRIPT_ > /etc/modprobe.d/disable-${_modules_section}-modules.conf
EOF

  for _module_name in $_disable_list; do
    cat <<EOF >> "$run_script"
	install ${_module_name} /bin/true
EOF
  done

  cat <<EOF >> "$run_script"
	_SCRIPT_

  sort -u -o /etc/modprobe.d/disable-${_modules_section}-modules.conf \\
    /etc/modprobe.d/disable-${_modules_section}-modules.conf
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<EOF >> "$run_script"

  # Debug
  {
    write_debug_log "Contents of disable-${_modules_section}-modules.conf:" 4
    cat /etc/modprobe.d/disable-${_modules_section}-modules.conf >> /chroot.log
  }
EOF
  fi

cat <<EOF >> "$run_script"
}
EOF
}


#
# Create relevant filesystems for the disk image and mount these
# inside the chroot directory.
#
format_and_mount_fs() {
  local _boot_on _logs_on _root_on

	cat <<'EOF' >> "$run_script"

write_log "Formatting and mounting filesystems"
{
EOF

  # Format UEFI ESP filesystem if needed
  if [ "$image_boot_type" = "uefi" ]; then
    cat <<EOF >> "$run_script"
  uefi_part_device="\${loop_device}p${uefi_part_num}"
EOF
    format_esp_fs
    if [ "$image_boot_reference" = "uuid" ]; then
      cat <<'EOF' >> "$run_script"
  esp_fs_uuid="$(get_uuid_from_device "$uefi_part_device")"
EOF
    fi
    cat <<EOF >> "$run_script"

EOF
  fi

  # Format boot filesystem if needed
  if [ -n "${needs_boot_partition+x}" ]; then
    cat <<EOF >> "$run_script"
  boot_part_device="\${loop_device}p${boot_part_num}"
EOF
    if [ "$image_class" = "physical" ] && \
       [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
      # RPI
      #
      # Ensure that RPI boot filesystem label is *not* called "boot" due to
      # https://github.com/raspberrypi/firmware/issues/1529
      format_fat_fs "\$boot_part_device" "RPI boot" "fat32" \
        "$CONSTANT_RPIBOOT_LABEL" "partition"
    else
      if [ "$image_fs_type" = "btrfs" ]; then
        format_btrfs_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
          "partition"
      elif [ "$image_fs_type" = "ext4" ]; then
        format_ext4_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
          "partition"
      elif [ "$image_fs_type" = "f2fs" ]; then
        format_f2fs_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
          "partition"
      elif [ "$image_fs_type" = "xfs" ]; then
        format_xfs_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
          "partition"
      fi
      if [ "$image_boot_reference" = "uuid" ]; then
        cat <<'EOF' >> "$run_script"
  boot_fs_uuid="$(get_uuid_from_device "$boot_part_device")"
EOF
      fi
    fi
    cat <<EOF >> "$run_script"

EOF
  fi

  # Format CIDATA filesystem if needed
  if [ "$image_class" = "physical" ] && \
     [ -z "${image_without_cloud_init+x}" ]; then
    cat <<EOF >> "$run_script"
  cidata_part_device="\${loop_device}p${cidata_part_num}"
EOF
    format_fat_fs "\$cidata_part_device" "CIDATA" "fat12" \
      "$CONSTANT_CIDATA_LABEL" "partition"

    cat <<EOF >> "$run_script"

EOF
  fi

  # Set fs device variables
  if [ -n "${image_encrypted+x}" ]; then
    # LUKS
    if [ -n "${image_lvm_rootfs+x}" ]; then
      _logs_on="LVM-on-LUKS device"
      _root_on="LVM-on-LUKS device"
      cat <<EOF >> "$run_script"
  root_part_device="/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_ROOT_LV_NAME}"
  logs_part_device="/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_LOGS_LV_NAME}"
EOF
      if [ "$image_class" != "physical" ] || \
         [ "$(expr "$image_physical_type" : '.*rpi.*')" -eq 0 ]; then
        # Not RPI (which has a separate non-LVM boto partition)
      _boot_on="LVM-on-LUKS device"
      cat <<EOF >> "$run_script"
  boot_part_device="/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_BOOT_LV_NAME}"
EOF
      fi
    else
      _root_on="LUKS device"
      cat <<EOF >> "$run_script"
  root_part_device="/dev/mapper/$CONSTANT_LUKS_DEVICE_NAME"
EOF
    fi
  elif [ -n "${image_lvm_rootfs+x}" ]; then
    # LVM
    _root_on="LVM logical volume"
    cat <<EOF >> "$run_script"
  root_part_device="/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_ROOT_LV_NAME}"
EOF
    if [ "$image_bootloader" = "grub" ]; then
      _boot_on="LVM logical volume"
      cat <<EOF >> "$run_script"
  boot_part_device="/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_BOOT_LV_NAME}"
EOF
    fi
    _logs_on="LVM logical volume"
    cat <<EOF >> "$run_script"
  logs_part_device="/dev/mapper/${CONSTANT_LVM_VG_NAME}-${CONSTANT_LVM_LOGS_LV_NAME}"
EOF
  else
    # neither LUKS nor LVM
    _root_on="partition"
    cat <<EOF >> "$run_script"
  root_part_device="\${loop_device}p${root_part_num}"
EOF
  fi

  # Format root filesystem (and boot & logs LVs if needed)
  if [ "$image_fs_type" = "btrfs" ]; then
    format_btrfs_fs "\$root_part_device" "root" "$CONSTANT_ROOTFS_LABEL" \
      "$_root_on"
    if [ -n "${image_lvm_rootfs+x}" ]; then
      # boot & logs LVs
      format_btrfs_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
        "$_boot_on"
      format_btrfs_fs "\$logs_part_device" "logs" "$CONSTANT_LOGSFS_LABEL" \
        "$_logs_on"
    fi
  elif [ "$image_fs_type" = "ext4" ]; then
    format_ext4_fs "\$root_part_device" "root" "$CONSTANT_ROOTFS_LABEL" \
      "$_root_on"
    if [ -n "${image_lvm_rootfs+x}" ]; then
      if [ "$image_bootloader" = "grub" ]; then
        # boot LV
        format_ext4_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
          "$_boot_on"
      fi
      # logs LV
      format_ext4_fs "\$logs_part_device" "logs" "$CONSTANT_LOGSFS_LABEL" \
        "$_logs_on"
    fi
  elif [ "$image_fs_type" = "f2fs" ]; then
    format_f2fs_fs "\$root_part_device" "root" "$CONSTANT_ROOTFS_LABEL" \
      "$_root_on"
    if [ -n "${image_lvm_rootfs+x}" ]; then
      # boot and logs LVs
      format_f2fs_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
        "$_boot_on"
      format_f2fs_fs "\$logs_part_device" "logs" "$CONSTANT_LOGSFS_LABEL" \
        "$_logs_on"
    fi
  elif [ "$image_fs_type" = "xfs" ]; then
    format_xfs_fs "\$root_part_device" "root" "$CONSTANT_ROOTFS_LABEL" \
      "$_root_on"
    if [ -n "${image_lvm_rootfs+x}" ]; then
      # boot and logs LVs
      format_xfs_fs "\$boot_part_device" "boot" "$CONSTANT_BOOTFS_LABEL" \
        "$_boot_on"
      format_xfs_fs "\$logs_part_device" "logs" "$CONSTANT_LOGSFS_LABEL" \
        "$_logs_on"
    fi
  fi

  if [ "$image_boot_reference" = "uuid" ] && \
     { [ "$image_class" != "physical" ] || \
       [ "$(expr "$image_physical_type" : '.*rpi.*')" -eq 0 ]; } && \
     [ -z "${image_encrypted+x}" ] && \
     { [ -z "${image_lvm_rootfs+x}" ] || \
       [ "$image_bootloader" = "syslinux" ]; }; then
    cat <<'EOF' >> "$run_script"
  root_fs_uuid="$(get_uuid_from_device "$root_part_device")"
EOF
  fi

  # Mount root filesystem
  cat <<'EOF' >> "$run_script"

  write_log "Mounting root filesystem onto $chroot_dir" 2
  mkdir -p "$chroot_dir"
  mount -o private "$root_part_device" "$chroot_dir" >> "$logfile" 2>&1
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<EOF >> "$run_script"

  # Debug
  {
    write_debug_log "Size of root filesystem:" 2
    df -BM "\$chroot_dir" >> "\$logfile"
  }
EOF
	fi

  # Mount UEFI ESP filesustem if necessary
  if [ "$image_boot_type" = "uefi" ]; then
    cat <<'EOF' >> "$run_script"

  write_log "Mounting ESP filesystem onto $chroot_dir/efi" 2
  mkdir -p "$chroot_dir"/efi
  mount -o private "$uefi_part_device" "$chroot_dir"/efi >> "$logfile" 2>&1
EOF

    if [ -n "${debug_enabled+x}" ]; then
      cat <<EOF >> "$run_script"

  # Debug
  {
    write_debug_log "Size of ESP filesystem:" 2
    df -BM "\$chroot_dir"/efi >> "\$logfile"
  }
EOF
  	fi
  fi

  # Mount boot filesystem if necessary
  if [ -n "${needs_boot_partition+x}" ] || \
     { [ -n "${image_lvm_rootfs+x}" ] && \
       { [ "$image_boot_type" != "uefi" ] || \
         [ "$image_bootloader" != "syslinux" ]; }; }; then
    # Needs a boot partition or else is LVM but not Syslinux-based UEFI
    # (where boot is part of ESP partition)
    cat <<'EOF' >> "$run_script"

  write_log "Mounting boot filesystem onto $chroot_dir/boot" 2
  mkdir -p "$chroot_dir"/boot
  mount -o private "$boot_part_device" "$chroot_dir"/boot >> "$logfile" 2>&1
EOF

    if [ -n "${debug_enabled+x}" ]; then
      cat <<EOF >> "$run_script"

  # Debug
  {
    write_debug_log "Size of boot filesystem:" 2
    df -BM "\$chroot_dir"/boot >> "\$logfile"
  }
EOF
  	fi
  elif [ "$image_boot_type" = "uefi" ] && \
       [ "$image_bootloader" = "syslinux" ]; then
    # When using Syslinux with UEFI then, as kernel & initramfs files need
    # to be in EFI/BOOT directory of ESP partition, EFI/BOOT directory of
    # ESP partition is bind-mounted to /boot. This ensures that kernel,
    # initramfs, and extlinux.conf files are in ESP partition.
    cat <<'EOF' >> "$run_script"

  write_log "Bind mounting ESP filesystem's EFI/BOOT onto $chroot_dir/boot" 2
  mkdir -p "$chroot_dir"/efi/EFI/BOOT
  mkdir -p "$chroot_dir"/boot
  mount -t none -o bind "$chroot_dir"/efi/EFI/BOOT "$chroot_dir"/boot \
    >> "$logfile" 2>&1
EOF
  fi

  # Mount logs filesystem if necessary
  if [ -n "${image_lvm_rootfs+x}" ]; then
    cat <<'EOF' >> "$run_script"

  write_log "Mounting logs filesystem onto $chroot_dir/var/logs" 2
  mkdir -p "$chroot_dir"/var/log
  mount -o private "$logs_part_device" "$chroot_dir"/var/log >> "$logfile" 2>&1
EOF

    if [ -n "${debug_enabled+x}" ]; then
      cat <<EOF >> "$run_script"

  # Debug
  {
    write_debug_log "Size of logs filesystem:" 2
    df -BM "\$chroot_dir"/var/log >> "\$logfile"
  }
EOF
  	fi
  fi

  # Mount CIDATA filesystem if necessary
  if [ "$image_class" = "physical" ] && \
     [ -z "${image_without_cloud_init+x}" ]; then
    cat <<'EOF' >> "$run_script"

  write_log "Mounting cloud-init YAML filesystem onto $chroot_dir/cidata" 2
  mkdir -p "$chroot_dir"/cidata
  mount -o private "$cidata_part_device" "$chroot_dir"/cidata >> "$logfile"
EOF

    if [ -n "${debug_enabled+x}" ]; then
      cat <<EOF >> "$run_script"

  # Debug
  {
    write_debug_log "Size of cloud-init YAML filesystem:" 2
    df -BM "\$chroot_dir"/cidata >> "\$logfile"
  }
EOF
  	fi
  fi

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_debug_log "Filesystems' UUIDs" 2
    lsblk --ascii --fs "$loop_device" >> "$logfile" 2>&1
    write_debug_log "Blkid output:" 2
    lsblk \
      --output NAME,FSTYPE,LABEL,UUID,FSSIZE,FSAVAIL,FSUSED,FSUSE%,MOUNTPOINT,PARTTYPENAME,PARTLABEL \
      "$loop_device" >> "$logfile" 2>&1
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"
}
EOF
}


#
# Create a BTRFS filesystem
#
format_btrfs_fs() {
  local device=$1
  local fs_use="$2"
  local label=$3
  local formatting_where="$4"

  cat <<EOF >> "$run_script"

  write_log "Formatting Btrfs $fs_use filesystem on $formatting_where" 2
  mkfs.btrfs -q -L $label "$device" >> "\$logfile" 2>&1
EOF
}


#
# Create a F2FS filesystem
#
format_f2fs_fs() {
  local device=$1
  local fs_use="$2"
  local label=$3
  local formatting_where="$4"

  cat <<EOF >> "$run_script"

  write_log "Formatting F2FS $fs_use filesystem on $formatting_where" 2
  mkfs.f2fs -q -l $label "$device" >> "\$logfile" 2>&1
EOF
}


#
# Create a FAT filesystem
#
format_fat_fs() {
  local device=$1
  local fs_use="$2"
  local fat_type=$3
  local fat_label=$4
  local formatting_where="$5"

  case $fat_type in
    fat12 )
      fat_info_type="12"
      fat_mkfs_option="-F12 -s 1 -S 512"
      ;;
    fat16 )
      fat_info_type="16"
      fat_mkfs_option="-F16 -s 1 -S 512"
      ;;
    fat32 )
      fat_info_type="32"
      fat_mkfs_option="-F32"
      ;;
  esac

  cat <<EOF >> "$run_script"

  write_log "Formatting FAT${fat_info_type} $fs_use filesystem on $formatting_where" 2
  mkfs.fat $fat_mkfs_option -n $fat_label "$device" >> "\$logfile" 2>&1
EOF
}


#
# Create an XFS filesystem
#
format_xfs_fs() {
  local device=$1
  local fs_use="$2"
  local label=$3
  local formatting_where="$4"

  # Force attr=2 to avoid dmesg warning
  fs_options="-i attr=2"
  # Ensure XFS avoids Year 2038 problem.
  fs_options="$fs_options -m bigtime=1"

  cat <<EOF >> "$run_script"

  write_log "Formatting XFS $fs_use filesystem on $formatting_where" 2
  mkfs.xfs -q -L $label $fs_options "$device" >> "\$logfile" 2>&1
EOF
}


#
# Insert function define_cmdline_for_encryption into created script
#
insert_chroot_function_define_cmdline_for_encryption() {
  local _cmdline_list

  cat <<'EOF' >> "$run_script"

define_cmdline_for_encryption() {
EOF

  _cmdline_list="cryptroot=UUID=\${luks_part_uuid} cryptdm=$CONSTANT_LUKS_DEVICE_NAME"

  if [ -n "${remote_unlock_enabled+x}" ]; then
    if [ -n "${remote_unlock_static_ip+x}" ]; then
      # Indicate the IP address to use by initramfs for configuring
      # the ethernet interface for Dropbear to listen on.
      _cmdline_list="$_cmdline_list ip=${remote_unlock_static_ip}::${remote_unlock_static_gateway:-}:${remote_unlock_static_netmask:-}::${remote_unlock_static_interface:-}:none:"
    else
      # Indicate that DHCP should be used by initramfs' init.
      _cmdline_list="$_cmdline_list ip=dhcp"
    fi

    # Indicate that Dropbear should be run by initramfs' init.
    _cmdline_list="$_cmdline_list remote_unlock_luks"

    if [ -n "${remote_unlock_ssh_port+x}" ]; then
      # Indicate the port that Dropbear should listen on
      _cmdline_list="$_cmdline_list remote_unlock_luks_ssh_port=$remote_unlock_ssh_port"
    fi
  fi

  cat <<EOF >> "$run_script"
  echo "$_cmdline_list"
}
EOF
}


#
# Install base Alpine system
#
install_alpine_base() {
  local _base_packages _bootloader_packages

  _base_packages="alpine-base"
  if [ "$image_boot_type" = "uefi" ]; then
    _base_packages="$_base_packages efivar"
  fi

  # RPI alpine-base doesn't depend on mkinitfs so add it to list.
  if [ "$image_class" = "physical" ] && \
     [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
    _base_packages="$_base_packages mkinitfs"
  fi

  # Define bootloader-related packages
  if [ "$image_bootloader" = "grub" ]; then
    _bootloader_packages="grub"
    if [ "$image_boot_type" = "uefi" ]; then
      _bootloader_packages="$_bootloader_packages dosfstools grub-efi"
    else
      _bootloader_packages="$_bootloader_packages grub-bios"
    fi
    _base_packages="$_base_packages $_bootloader_packages"
  elif [ "$image_bootloader" = "syslinux" ]; then
    _bootloader_packages="syslinux"
    if [ "$image_boot_type" = "uefi" ]; then
      _bootloader_packages="$_bootloader_packages dosfstools"
    fi
    _base_packages="$_base_packages $_bootloader_packages"
  elif [ "$image_class" = "physical" ] && \
       [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
    _bootloader_packages="dosfstools raspberrypi-bootloader-cutdown"
    if [ "$image_alpine_release" = "v3.13" ] || \
       [ "$image_alpine_release" = "v3.14" ] || \
       [ "$image_alpine_release" = "v3.15" ]; then
      # Prior to 3.16/Edge raspberrypi-common does not exist and so
      # raspberrypi-bootloader must also be installed.
      _bootloader_packages="raspberrypi-bootloader"
    fi
    _base_packages="$_base_packages $_bootloader_packages"
  else
    _bootloader_packages="none"
  fi

  cat <<EOF >> "$run_script"

write_log "Bootloader packages to be installed are: $_bootloader_packages"

write_log "Install base Alpine (plus bootloader packages) inside chroot"
{
  # shellcheck disable=SC2086
  \$TMPDIR/apk-tools-${apk_static_version}/apk \\
    --arch "${image_arch}" --initdb --allow-untrusted --root \$chroot_dir \\
    --update-cache \\
    add ${_base_packages} \\
    >> "\$logfile" 2>&1
  _rc=\$?
  if [ \$_rc != 0 ]; then
    write_log "Failure while installing base Alpine, error code: \$_rc"
    exit 1
  fi
}
EOF
}


#
# Insert function get_kernel_package_version into created script
#
insert_chroot_function_get_kernel_package_version() {
  local _kernel_package

  cat <<'EOF' >> "$run_script"

get_kernel_package_version() {
EOF

  case $image_class in
    cloud | virtual )
      if [ "$image_kernel_type" = "edge" ]; then
        _kernel_package="edge4virt"
      else
        _kernel_package="virt"
      fi
      ;;
    physical )
      case $image_physical_type in
        pc )
          if [ "$image_kernel_type" = "edge" ]; then
            _kernel_package="edge"
          else
            _kernel_package="lts"
          fi
          ;;
        rpi2 | rpi3 )
          if [ "$image_arch" = "armv7" ]; then
            _kernel_package="rpi2"
          else
            _kernel_package="rpi"
          fi
          ;;
        rpi4 )
          _kernel_package="rpi4" ;;
      esac
      ;;
  esac

  cat <<EOF >> "$run_script"
  echo "\\\$(apk info linux-$_kernel_package | head -n 1 | sed -e "s/^linux-$_kernel_package-//" \\
    -e 's/ .*//')"
}
EOF
}


#
# Insert functions into created script
#
insert_chroot_functions() {
  cat <<'EOF' >> "$run_script"

############################################################################
##		Chroot Functions
############################################################################
EOF

  insert_chroot_function_add_fstab_entry
  if [ -n "${image_encrypted+x}" ]; then
    insert_chroot_function_define_cmdline_for_encryption
  fi
  insert_chroot_function_get_kernel_package_version
  insert_chroot_function_get_kernel_version
  insert_chroot_function_write_debug_log
  insert_chroot_function_write_log
}


#
# Install relevant firmware packages
#
install_firmware() {
  local _firmware_pkgs

  cat <<'EOF' >> "$run_script"

write_log "Selecting firmware packages to install"
{
EOF

  if [ "$image_class" = "physical" ]; then
    # Physical machine
    if [ "$image_physical_type" = "pc" ]; then
      # PC
      if [ -n "${image_optimise+x}" ] && \
         [ -n "${image_graphics_vendor+x}" ] && \
         [ "$image_graphics_vendor" = "amd" ]; then
        cat <<'EOF' >> "$run_script"
  write_log "Selecting AMD graphics firmware" 2
EOF
        if [ -n "${image_graphics_vendor_driver+x}" ] && \
           [ "$image_graphics_vendor_driver" = "amdgpu" ]; then
          _firmware_pkgs="linux-firmware-amdgpu"
        elif [ -n "${image_graphics_vendor_driver+x}" ] && \
             [ "$image_graphics_vendor_driver" = "radeon" ]; then
          _firmware_pkgs="linux-firmware-radeon"
        else
          _firmware_pkgs="linux-firmware-amdgpu linux-firmware-radeon"
        fi
      elif [ -n "${image_optimise+x}" ] && \
           [ -n "${image_graphics_vendor+x}" ] && \
           [ "$image_graphics_vendor" = "intel" ]; then
        cat <<'EOF' >> "$run_script"
  write_log "Selecting Intel graphics firmware" 2
EOF
        _firmware_pkgs="linux-firmware-i915"
      else
        cat <<'EOF' >> "$run_script"
  write_log "Selecting AMD and Intel graphics firmware" 2
EOF
        _firmware_pkgs="linux-firmware-amdgpu linux-firmware-radeon linux-firmware-i915"
      fi
    elif [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
      # No RPI firmware used currently
      :
    fi
  fi

  if [ -z "${_firmware_pkgs+x}" ]; then
    cat <<EOF >> "$run_script"
  write_log "No firmware required" 2
EOF
  else
    cat <<EOF >> "$run_script"
  write_log "Installing firmware" 2
  apk add $_firmware_pkgs >> /chroot.log 2>&1
EOF
  fi

  cat <<'EOF' >> "$run_script"
}
EOF
}


#
# Install GRUB onto disk
#
install_grub() {
  local _grub_options _grub_efi_options _grub_modules_list _grub_target

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

# Debug
{
  write_debug_log "grub.cfg contents:"
  cat /boot/grub/grub.cfg >> /chroot.log || true
}
EOF
  fi

  ###_grub_efi_options="--bootloader-id=alpine --efi-directory=/efi --no-nvram"
  _grub_efi_options="--removable --efi-directory=/efi --no-nvram"

  if [ -n "${image_optimise+x}" ]; then
    _grub_modules_list="acpi disk echo elf gzio linux loadenv minicmd normal probe search test video_colors video_fb"

    # Filesystem
    if [ "$image_fs_type" = "ext4" ]; then
      _grub_modules_list="$_grub_modules_list ext2"
    else
      _grub_modules_list="$_grub_modules_list $image_fs_type"
    fi

    # Encryption
    if [ -n "${image_encrypted+x}" ] && \
       { [ -z "${image_experimental+x}" ] || \
         [ -z "${remote_unlock_enabled+x}" ]; } && \
       [ -z "${image_no_grub_encryption+x}" ] && \
       [ -z "${needs_boot_partition+x}" ]; then
      # Grub LUKS encryption support only applies when:
      #  - bootloader is Grub, AND
      #  - disk image is encrypted, AND
      #  - remote unlock is not enabled (as otherwise /boot is not encrypted), AND
      #  - Grub LUKS encryption support is not disabled AND
      #  - /boot is not a separate partition.
      _grub_modules_list="$_grub_modules_list gcry_rijndael gcry_sha256"
      if [ "$image_luks_version" = 1 ]; then
        _grub_modules_list="$_grub_modules_list luks"
      else
        _grub_modules_list="$_grub_modules_list luks2"
      fi
    fi

    # LVM
    if [ -n "${image_lvm_rootfs+x}" ]; then
      _grub_modules_list="$_grub_modules_list lvm"
    fi

    # Bootloader Password
    if [ -n "${image_bootloader_password+x}" ]; then
      _grub_modules_list="$_grub_modules_list password_pbkdf2"
    fi

    # Serial
    if [ "$image_console_type" = "serial" ] || \
       [ "$image_console_type" = "both" ]; then
      _grub_modules_list="$_grub_modules_list serial"
    fi

    # USB
    if [ "$image_arch" = "aarch64" ]; then
      # aarch64 machines only use USB keyboards
      _grub_modules_list="$_grub_modules_list ehci ohci usb usb_keyboard"
    elif [ "$keyboard_type" = "usb" ] || \
         [ "$keyboard_type" = "both" ]; then
      _grub_modules_list="$_grub_modules_list ehci usb usb_keyboard"

      if [ -z "${image_cpu_vendor+x}" ] || \
         [ "$image_cpu_vendor" = "amd" ]; then
        _grub_modules_list="$_grub_modules_list ohci"
      fi
      if [ -z "${image_cpu_vendor+x}" ] || \
         [ "$image_cpu_vendor" = "intel" ]; then
        _grub_modules_list="$_grub_modules_list uhci"
      fi
    fi

    # PS/2 keyboard
    if { [ "$image_arch" = "x86" ] || \
         [ "$image_arch" = "x86_64" ]; } && \
       { [ "$keyboard_type" = "ps2" ] || \
         [ "$keyboard_type" = "both" ]; }; then
      _grub_modules_list="$_grub_modules_list at_keyboard"
    fi

    # Storage
    if [ "$image_class" = "physical" ] && \
       [ "$image_physical_type" = "pc" ]; then
      case $image_boot_device_type in
        nvme | sata )
          _grub_modules_list="$_grub_modules_list ahci" ;;
        scsi | sd | usb )
          _grub_modules_list="$_grub_modules_list scsi" ;;
      esac
    fi
  fi

  if [ "$image_arch" = "aarch64" ] && [ "$image_boot_type" = "uefi" ]; then
    _grub_options="--target=arm64-efi $_grub_efi_options"
    if [ -n "${image_optimise+x}" ]; then
      _grub_modules_list="$_grub_modules_list all_video efi_gop efifwsetup gfxterm part_gpt"
    fi
  elif [ "$image_arch" = "x86" ]; then
    _grub_target="i386-pc"
    if [ -n "${image_optimise+x}" ]; then
      _grub_modules_list="$_grub_modules_list biosdisk part_msdos vga vga_text"
      if [ "$image_class" = "cloud" ]; then
        _grub_modules_list="$_grub_modules_list video_bochs"
      elif [ "$image_class" = "virtual" ]; then
        case $image_vm_type in
          libvirtd | lxd | proxmox | qemu | generic )
            _grub_modules_list="$_grub_modules_list video_bochs"
            ;;
        esac
      fi
    fi
  elif [ "$image_arch" = "x86_64" ] && [ "$image_boot_type" = "bios" ]; then
    _grub_options="--target=i386-pc"
    if [ -n "${image_optimise+x}" ]; then
      _grub_modules_list="$_grub_modules_list biosdisk part_msdos vga vga_text"
      if [ "$image_class" = "cloud" ]; then
        _grub_modules_list="$_grub_modules_list video_bochs"
      elif [ "$image_class" = "virtual" ]; then
        case image_vm_type in
          libvirtd | lxd | proxmox | qemu | generic )
            _grub_modules_list="$_grub_modules_list video_bochs"
            ;;
        esac
      fi
    fi
  else
    _grub_options="--target=x86_64-efi $_grub_efi_options"
    if [ -n "${image_optimise+x}" ]; then
      _grub_modules_list="$_grub_modules_list all_video efi_gop efifwsetup gfxterm part_gpt"
    fi
  fi

  if [ "$image_boot_type" = "uefi" ]; then
    cat <<'EOF' >> "$run_script"

mkdir -p /efi/EFI
EOF
  fi

  if [ -n "${debug_enabled+x}" ]; then
    _grub_options="${_grub_options} --verbose"
  fi

  if [ -n "${image_optimise+x}" ]; then
    _grub_options=$(printf '%s \\\n  %s' "$_grub_options" \
      "--install-modules=\"$_grub_modules_list\"")
  fi

  cat <<EOF >> "$run_script"

{
  write_log "Temporarily creating a dummy device.map file for GRUB" 2
  touch /boot/grub/device.map

  write_log "Installing GRUB bootloader" 2
  grub-install $_grub_options \\
    \$loop_device >> /chroot.log 2>&1
EOF

  cat <<EOF >> "$run_script"

  write_log "Deleting temporary Grub device.map file"
  rm /boot/grub/device.map

  if [ -n "\\\${losetup_package_installed+x}" ]; then
    write_log "Removing $losetup_package package that was temporarily installed"
    apk del $losetup_package >> /chroot.log 2>&1
  fi
EOF

  if [ "$image_mdev" = true ]; then
    # Remove the eudev package that was temporarily installed
    # so that grub-probe could use udevadm.
    cat <<EOF >> "$run_script"

  write_log "Removing eudev package that was temporarily installed"
  apk del eudev >> /chroot.log 2>&1
EOF
  fi

  cat <<EOF >> "$run_script"
}
EOF
}


#
# Install relevant kernel package
#
install_kernel() {
  local _firmware_pkg _kernel_pkg _kernel_config_file

  if [ "$image_class" = "cloud" ] || \
     [ "$image_class" = "virtual" ]; then
    # Cloud or Virtual machine
    if [ "$image_kernel_type" = "edge" ]; then
      _kernel_pkg="linux-edge4virt"
      _kernel_config_file="config-edge4virt"
    else
      _kernel_pkg="linux-virt"
      _kernel_config_file="config-virt"
    fi
  else
    # Physical machine
    _firmware_pkg="linux-firmware-none"

    if [ "$image_physical_type" = "pc" ]; then
      # PC
      if [ "$image_kernel_type" = "edge" ]; then
        _kernel_pkg="linux-edge"
        _kernel_config_file="config-edge"
      else
        _kernel_pkg="linux-lts"
        _kernel_config_file="config-lts"
      fi
    elif [ "$(expr "$image_physical_type" : '.*rpi.*')" -gt 0 ]; then
      # Raspberry Pi
      case $image_physical_type in
        rpi2 | rpi3 )
          if [ "$image_arch" = "armv7" ]; then
            _kernel_pkg="linux-rpi2"
            _kernel_config_file="config-rpi2"
          else
            _kernel_pkg="linux-rpi"
            _kernel_config_file="config-rpi"
          fi ;;
        rpi4 )
          _kernel_pkg="linux-rpi4"
          _kernel_config_file="config-rpi4"
          ;;
      esac
    fi
  fi

  cat <<EOF >> "$run_script"

write_log "Installing kernel $_kernel_pkg"
{
  apk add $_kernel_pkg ${_firmware_pkg:-} >> /chroot.log 2>&1
EOF

  cat <<'EOF' >> "$run_script"

  _kernel_version=\$(get_kernel_version)
  _kernel_package_version=\$(get_kernel_package_version)
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<EOF >> "$run_script"

  write_debug_log "Kernel is: \\\$_kernel_version"
  write_debug_log "Kernel package version is: \\\$_kernel_package_version"

  # Take a copy of the kernel config file
  cp /boot/$_kernel_config_file \\
    /kernel-config_\\\${_kernel_package_version}_${image_arch}_${_kernel_config_file}
EOF
  fi

  cat <<'EOF' >> "$run_script"
}
EOF
}


#
# Install CPU microcode packages
#
install_microcode() {
  local _microcode_pkgs

  cat <<'EOF' >> "$run_script"

write_log "Selecting microcode packages to install"
{
EOF

  if [ "$image_class" = "physical" ]; then
    # Physical machine
    if [ -n "${image_cpu_vendor+x}" ] && \
       [ "$image_cpu_vendor" = "amd" ]; then
      cat <<'EOF' >> "$run_script"
  write_log "Selecting AMD CPU microcode" 2
EOF
      _microcode_pkgs="amd-ucode"
    elif [ -n "${image_cpu_vendor+x}" ] && \
         [ "$image_cpu_vendor" = "intel" ]; then
      cat <<'EOF' >> "$run_script"
  write_log "Selecting Intel CPU microcode" 2
EOF
        _microcode_pkgs="intel-ucode"
    else
      cat <<'EOF' >> "$run_script"
  write_log "Selecting AMD and Intel microcode" 2
EOF
      _microcode_pkgs="amd-ucode intel-ucode"
    fi
  fi

  if [ -z "${_microcode_pkgs+x}" ]; then
    cat <<EOF >> "$run_script"
  write_log "No microcode required" 2
EOF
  else
    cat <<EOF >> "$run_script"
  write_log "Installing microcode" 2
  apk add $_microcode_pkgs >> /chroot.log 2>&1
EOF
  fi

  cat <<'EOF' >> "$run_script"
}
EOF
}


#
# Install Syslinux onto disk
#
install_syslinux() {
 if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

# Debug
{
  cp /boot/extlinux.conf /boot/extlinux.conf-orig
  write_debug_log "/boot/extlinux.conf contents at start:"
  cat /boot/extlinux.conf >> /chroot.log
}
EOF
  fi

  cat <<'EOF' >> "$run_script"

write_log "Installing Syslinux"
{
EOF

  if [ "$image_boot_type" = "bios" ]; then
    # BIOS
    cat <<'EOF' >> "$run_script"
  write_log "Installing BIOS MBR" 2
  dd bs=440 count=1 conv=notrunc if=/usr/share/syslinux/mbr.bin \
    of="$loop_device" >> /chroot.log 2>&1
  write_log "Installing Syslinux files in /boot directory" 2
  extlinux --install /boot/ >> /chroot.log 2>&1
EOF

    if [ -n "${debug_enabled+x}" ]; then
      cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_debug_log "/boot/extlinux.conf contents after extlinux --install:"
    cat /boot/extlinux.conf >> /chroot.log
  }
EOF
    fi

  else
    # UEFI
    cat <<'EOF' >> "$run_script"
  ###write_log "Installing Syslinux files in EFI/boot" 2
  ###mkdir -p /boot/EFI/BOOT
  ###cp \
  ###  /usr/share/syslinux/efi64/syslinux.efi \
  ###  /boot/EFI/boot/bootx64.efi
  ###cp \
  ###  /boot/initramfs-* \
  ###  /boot/vmlinuz-* \
  ###  /usr/share/syslinux/efi64/ldlinux.e64 \
  ###  /boot/EFI/alpine/*.c32 \
  ###  /boot/EFI/boot/

  write_log "Installing Syslinux UEFI files in EFI/BOOT aka /boot" 2
  cp /usr/share/syslinux/efi64/syslinux.efi /boot/bootx64.efi
  rm /boot/*.c32
  cp \\
    /usr/share/syslinux/efi64/syslinux.c32 \\
    /usr/share/syslinux/efi64/ldlinux.e64 \\
    /usr/share/syslinux/efi64/libcom32.c32 \\
    /usr/share/syslinux/efi64/libutil.c32 \\
    /usr/share/syslinux/efi64/mboot.c32 \\
    /usr/share/syslinux/efi64/menu.c32 \\
    /usr/share/syslinux/efi64/vesamenu.c32 \\
    /boot/
EOF

    if [ -n "${debug_enabled+x}" ]; then
      cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_debug_log "After installing Syslinux UEFI files" 2
    ls -ltrR /boot/ >> /chroot.log
    write_debug_log "/boot/extlinux.conf contents:"
    cat /boot/extlinux.conf >> /chroot.log
  }
EOF
    fi

  fi

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_debug_log "Before update-extlinux" 2
    ls -ltrR /boot/ >> /chroot.log
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"

  write_log "Updating extlinux.conf file" 2
  update-extlinux --verbose --warn-only >> /chroot.log 2>&1
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_debug_log "/boot/extlinux.conf contents after update-extlinux:"
    cat /boot/extlinux.conf >> /chroot.log
  }

EOF
  fi

  cat <<'EOF' >> "$run_script"
  write_log "Fix permissions on extlinux.conf files" 2
  chmod g=,o= /boot/extlinux.conf*
EOF

  if [ -n "${debug_enabled+x}" ]; then

    cat <<'EOF' >> "$run_script"

  # Debug
  {
EOF

    if [ "$image_boot_type" = "uefi" ]; then
      # UEFI
      cat <<'EOF' >> "$run_script"
    write_debug_log "/boot/extlinux.conf contents after everything:"
    cat /boot/extlinux.conf >> /chroot.log
    write_debug_log "/boot contents:" 2
    ls -ltrR /boot/ >> /chroot.log

EOF
    fi

    cat <<'EOF' >> "$run_script"
    diff /boot/extlinux.conf-orig /boot/extlinux.conf >> /chroot.log || true
    rm /boot/extlinux.conf-orig

    write_debug_log "extlinux.conf contents:" 2
    cat /boot/extlinux.conf >> /chroot.log
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"
}
EOF
}


#
# LVM extents are 4MiB in size and so the size of a LV must be rounded
# up to the nearest 4MiB multiple.
#
lvm_round_extents() {
  local _size=$1

  # 4MiB
  local _extent=4

  echo "$(echo "$_size $_extent" | awk '{print int(($1/$2)+0.75)*$2}')"
}


#
# Partition the disk image for booting via BIOS
#
partition_bios() {
  local _boot_part_start _boot_part_end _cidata_part_start _cidata_part_end
  local _luks_part_start _luks_part_end _lvm_part_start _lvm_part_end

  cat <<EOF >> "$run_script"

write_log "Partitioning disk image for BIOS"
{
EOF

  create_disk_label "msdos"

  if [ -n "${image_encrypted+x}" ]; then
    # Disk encryption

    if [ -n "${needs_boot_partition+x}" ]; then
      # When using Syslinux with encrypted rootfs or when using remote
      # unlock (whether with Grub or Syslinux) we need to create a separate
      # boot partition which will be unencrypted.
      boot_part_num=1
      ###_boot_part_start="0%"
      ###_boot_part_end="${image_boot_part_size}MiB"
      ###
      ###create_disk_partition "$boot_part_num" "$_boot_part_start" \
      ###  "$_boot_part_end" "$image_boot_part_size" "Boot" "boot"

      _boot_part_start="2"
      _boot_part_end="$((_boot_part_start+image_boot_part_size))"

      create_disk_partition "$boot_part_num" "${_boot_part_start}MiB" \
        "${_boot_part_end}MiB" "$image_boot_part_size" "Boot" "boot"

      if [ "$image_class" = "physical" ]; then
        cidata_part_num=2
        ###_cidata_part_start="${image_boot_part_size}MiB"
        ###_cidata_part_end="$((image_boot_part_size+CONSTANT_CIDATA_PART_SIZE))MiB"
        ###
        ###create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
        ###  "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        _cidata_part_start="${_boot_part_end}"
        _cidata_part_end="$((_cidata_part_start+CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "${_cidata_part_start}MiB" \
          "${_cidata_part_end}MiB" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        luks_part_num=3
        ###_luks_part_start="$((image_boot_part_size+CONSTANT_CIDATA_PART_SIZE))MiB"
        _luks_part_start="${_cidata_part_end}"
        _luks_part_end="100%"
      else
        luks_part_num=2
        ###_luks_part_start="${image_boot_part_size}MiB"
        _luks_part_start="${_boot_part_end}"
        _luks_part_end="100%"
      fi

      ###create_disk_partition "$luks_part_num" "$_luks_part_start" \
      ###  "$_luks_part_end" "$image_luks_part_size" "LUKS"
      create_disk_partition "$luks_part_num" "${_luks_part_start}MiB" \
        "$_luks_part_end" "$image_luks_part_size" "LUKS"
    else
      # GRUB and no remote unlock enabled

      if [ "$image_class" = "physical" ]; then
        cidata_part_num=1
        ###_cidata_part_start="0%"
        ###_cidata_part_end="${CONSTANT_CIDATA_PART_SIZE}MiB"
        ###
        ###create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
        ###  "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        _cidata_part_start="2"
        _cidata_part_end="$((_cidata_part_start+CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "${_cidata_part_start}MiB" \
          "${_cidata_part_end}MiB" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        luks_part_num=2
        ###_luks_part_start="${CONSTANT_CIDATA_PART_SIZE}MiB"
        _luks_part_start="$_cidata_part_end"
        _luks_part_end="100%"

      else
        luks_part_num=1
        ###_luks_part_start="0%"
        _luks_part_start="2"
        _luks_part_end="100%"
      fi

      create_disk_partition "$luks_part_num" "${_luks_part_start}MiB" \
        "$_luks_part_end" "$image_luks_part_size" "LUKS" "boot"
    fi

  elif [ -n "${image_lvm_rootfs+x}" ]; then
    # LVM

    if [ -n "${needs_boot_partition+x}" ]; then
      # When using Syslinux with LVM rootfs we need to create a separate
      # boot partition.
      boot_part_num=1
      ###_boot_part_start="0%"
      ###_boot_part_end="${image_boot_part_size}MiB"
      ###
      ###create_disk_partition "$boot_part_num" "$_boot_part_start" \
      ###  "$_boot_part_end" "$image_boot_part_size" "Boot" "boot"

      _boot_part_start="2"
      _boot_part_end="$((_boot_part_start+image_boot_part_size))"

      create_disk_partition "$boot_part_num" "${_boot_part_start}MiB" \
        "${_boot_part_end}MiB" "$image_boot_part_size" "Boot" "boot"

      if [ "$image_class" = "physical" ] && \
         [ -z "${image_without_cloud_init+x}" ]; then
        # Also create a seperate partition for cloud-init config
        cidata_part_num=2
        ###_cidata_part_start="${image_boot_part_size}MiB"
        ###_cidata_part_end="$((image_boot_part_size+CONSTANT_CIDATA_PART_SIZE))MiB"
        ###
        ###create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
        ###  "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        _cidata_part_start="$_boot_part_end"
        _cidata_part_end="$((_cidata_part_start+CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "${_cidata_part_start}MiB" \
          "${_cidata_part_end}MiB" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        lvm_part_num=3
        ###_lvm_part_start="$((image_boot_part_size+CONSTANT_CIDATA_PART_SIZE))MiB"
        _lvm_part_start="$_cidata_part_end"
        _lvm_part_end="100%"
      else
        lvm_part_num=2
        ###_lvm_part_start="${image_boot_part_size}MiB"
        _lvm_part_start="$_boot_part_end"
        _lvm_part_end="100%"
      fi

      ###create_disk_partition "$lvm_part_num" "$_lvm_part_start" \
      ###  "$_lvm_part_end" "$image_lvm_part_size" "LVM" "lvm"

      create_disk_partition "$lvm_part_num" "${_lvm_part_start}MiB" \
        "$_lvm_part_end" "$image_lvm_part_size" "LVM" "lvm"
    else
      # no separate boot partition

      if [ "$image_class" = "physical" ] && \
         [ -z "${image_without_cloud_init+x}" ]; then
        # Create a seperate partition for cloud-init config
        cidata_part_num=1
        ###_cidata_part_start="0%"
        ###_cidata_part_end="${CONSTANT_CIDATA_PART_SIZE}MiB"
        ###
        ###create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
        ###  "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        _cidata_part_start="2"
        _cidata_part_end="$((_cidata_part_start+CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "${_cidata_part_start}MiB" \
          "${_cidata_part_end}MiB" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        lvm_part_num=2
        ###_lvm_part_start="${CONSTANT_CIDATA_PART_SIZE}MiB"
        _lvm_part_start="$_cidata_part_end"
        _lvm_part_end="100%"

      else
        lvm_part_num=1
        ###_lvm_part_start="0%"
        _lvm_part_start="2"
        _lvm_part_end="100%"
      fi

      create_disk_partition "$lvm_part_num" "${_lvm_part_start}MiB" \
        "$_lvm_part_end" "$image_lvm_part_size" "LVM" "boot lvm"
    fi
  else
    # No disk encryption, no LVM
    if [ -n "${needs_boot_partition+x}" ]; then
      # A separate boot partition is to be created.
      boot_part_num=1
      ###_boot_part_start="0%"
      ###_boot_part_end="${image_boot_part_size}MiB"
      ###
      ###create_disk_partition "$boot_part_num" "$_boot_part_start" \
      ###  "$_boot_part_end" "$image_boot_part_size" "Boot" "boot"

      _boot_part_start="2"
      _boot_part_end="$((_boot_part_start+image_boot_part_size))"

      create_disk_partition "$boot_part_num" "${_boot_part_start}MiB" \
        "${_boot_part_end}MiB" "$image_boot_part_size" "Boot" "boot"

      if [ "$image_class" = "physical" ]; then
        cidata_part_num=2
        ###_cidata_part_start="${image_boot_part_size}MiB"
        ###_cidata_part_end="$((image_boot_part_size+CONSTANT_CIDATA_PART_SIZE))MiB"
        ###
        ###create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
        ###  "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        _cidata_part_start="$_boot_part_end"
        _cidata_part_end="$((_cidata_part_start+CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "${_cidata_part_start}MiB" \
          "${_cidata_part_end}MiB" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        root_part_num=3
        ###_root_part_start="$((image_boot_part_size+CONSTANT_CIDATA_PART_SIZE))MiB"
        _root_part_start="$((_boot_part_end+CONSTANT_CIDATA_PART_SIZE))"
        _root_part_end="100%"
      else
        root_part_num=2
        ###_root_part_start="${image_boot_part_size}MiB"
        _root_part_start="$_boot_part_end"
        _root_part_end="100%"
      fi

      ###create_disk_partition "$root_part_num" "$_root_part_start" \
      ###  "$_root_part_end" "$image_root_part_size" "Root" "boot"
      create_disk_partition "$root_part_num" "${_root_part_start}MiB" \
        "$_root_part_end" "$image_root_part_size" "Root" "boot"
    else
      # No boot partition created
      if [ "$image_class" = "physical" ]; then
        cidata_part_num=1
        ###_cidata_part_start="0%"
        ###_cidata_part_end="${CONSTANT_CIDATA_PART_SIZE}MiB"
        ###
        ###create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
        ###  "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        _cidata_part_start="2"
        _cidata_part_end="$((_cidata_part_start+CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "${_cidata_part_start}MiB" \
          "${_cidata_part_end}MiB" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        root_part_num=2
        ###_root_part_start="${CONSTANT_CIDATA_PART_SIZE}MiB"
        _root_part_start="$_cidata_part_end"
        _root_part_end="100%"
      else
        root_part_num=1
        ###_root_part_start="0%"
        _root_part_start="2"
        _root_part_end="100%"
      fi

      ###create_disk_partition "$root_part_num" "$_root_part_start" \
      ###  "$_root_part_end" "$image_root_part_size" "Root" "boot"
      create_disk_partition "$root_part_num" "${_root_part_start}MiB" \
        "$_root_part_end" "$image_root_part_size" "Root" "boot"
    fi
  fi

  cat <<EOF >> "$run_script"
}
EOF
}


#
# Partition for Raspberry Pi use
#
partition_rpi() {
  local _boot_part_start _boot_part_end _cidata_part_start _cidata_part_end
  local _luks_part_start _luks_part_end _lvm_part_start _lvm_part_end

  cat <<EOF >> "$run_script"

write_log "Partitioning disk image for Raspberry Pi"
{
EOF

  create_disk_label "msdos"

  boot_part_num="1"
  _boot_part_start="0%"
  _boot_part_end="${image_boot_part_size}MiB"

  create_disk_partition "$boot_part_num" "$_boot_part_start" \
    "$_boot_part_end" "$image_boot_part_size" "Boot" "" "fat32"

  cidata_part_num="2"
  _cidata_part_start="${image_boot_part_size}MiB"
  _cidata_part_end="$((image_boot_part_size + CONSTANT_CIDATA_PART_SIZE))MiB"

  create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
    "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

  if [ -n "${image_encrypted+x}" ]; then
    # Disk encryption
    luks_part_num=3
    _luks_part_start="$((image_boot_part_size + CONSTANT_CIDATA_PART_SIZE))MiB"
    _luks_part_end="100%"

    create_disk_partition "$luks_part_num" "$_luks_part_start" \
      "$_luks_part_end" "$image_luks_part_size" "LUKS"
  elif [ -n "${image_lvm_rootfs+x}" ]; then
    # LVM
    lvm_part_num=3
    _lvm_part_start="$((image_boot_part_size + CONSTANT_CIDATA_PART_SIZE))MiB"
    _lvm_part_end="100%"

    create_disk_partition "$lvm_part_num" "$_lvm_part_start" \
      "$_lvm_part_end" "$image_lvm_part_size" "LVM" "lvm"
  else
    # No disk encryption
    root_part_num="3"
    _root_part_start="$((image_boot_part_size + CONSTANT_CIDATA_PART_SIZE))MiB"
    _root_part_end="100%"

    create_disk_partition "$root_part_num" "$_root_part_start" \
      "$_root_part_end" "$image_root_part_size" "Root"
  fi

  cat <<EOF >> "$run_script"
}
EOF
}


# 
# Partition the disk image for booting via UEFI
#
partition_uefi() {
  local _boot_part_start _boot_part_end _cidata_part_start _cidata_part_end
  local _esp_part_type _luks_part_start _luks_part_end
  local _lvm_part_start _lvm_part_end _uefi_part_start _uefi_part_end

  cat <<EOF >> "$run_script"

write_log "Partitioning disk image for UEFI"
{
EOF

  create_disk_label "gpt"

  uefi_part_num=1
  _uefi_part_start="0%"
  _uefi_part_end="${image_uefi_part_size}"

  case $esp_type in
    fat12 | fat16 )
      _esp_part_type="fat16" ;;
    fat32 )
      _esp_part_type="fat32" ;;
  esac

  create_disk_partition "$uefi_part_num" "$_uefi_part_start" \
    "$_uefi_part_end" "$image_uefi_part_size" "ESP" "esp" "$_esp_part_type"

  if [ -n "${image_encrypted+x}" ]; then
    # Disk encryption
    if [ -n "${needs_boot_partition+x}" ]; then
      # When using remote unlock with GRUB we need to create a separate boot
      # partition which will be unencrypted. This is not needed for Syslinux
      # as in that case the EFI partition contains the boot files.
      boot_part_num=2
      _boot_part_start="${_uefi_part_end}"
      _boot_part_end="$((_boot_part_start + image_boot_part_size))"

      create_disk_partition "$boot_part_num" "$_boot_part_start" \
        "$_boot_part_end" "$image_boot_part_size" "Boot" "boot"

      if [ "$image_class" = "physical" ]; then
        cidata_part_num=3
        _cidata_part_start="${_boot_part_end}"
        _cidata_part_end="$((_cidata_part_start + CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
          "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        luks_part_num=4
        _luks_part_start="${_cidata_part_end}"
        _luks_part_end="100%"
      else
        luks_part_num=3
        _luks_part_start="${_boot_part_end}"
        _luks_part_end="100%"
      fi

      create_disk_partition "$luks_part_num" "$_luks_part_start" \
        "$_luks_part_end" "$image_luks_part_size" "LUKS"
    else
      if [ "$image_class" = "physical" ]; then
        cidata_part_num=2
        _cidata_part_start="${_uefi_part_end}"
        _cidata_part_end="$((_cidata_part_start + CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
          "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        luks_part_num=3
        _luks_part_start="${_cidata_part_end}"
        _luks_part_end="100%"
      else
        luks_part_num=2
        _luks_part_start="${_uefi_part_end}"
        _luks_part_end="100%"
      fi

      create_disk_partition "$luks_part_num" "$_luks_part_start" \
        "$_luks_part_end" "$image_luks_part_size" "LUKS"
    fi
  elif [ -n "${image_lvm_rootfs+x}" ]; then
    # LVM
    if [ -n "${needs_boot_partition+x}" ]; then
      # When using Syslinux with LVM rootfs we need to create a separate
      # boot partition.
      boot_part_num=2
      _boot_part_start="${_uefi_part_end}"
      _boot_part_end="$((_boot_part_start + image_boot_part_size))"

      create_disk_partition "$boot_part_num" "$_boot_part_start" \
        "$_boot_part_end" "$image_boot_part_size" "Boot" "boot"

      if [ "$image_class" = "physical" ] && \
         [ -z "${image_without_cloud_init+x}" ]; then
        # Also create a seperate partition for cloud-init config
        cidata_part_num=3
        _cidata_part_start="${_boot_part_end}"
        _cidata_part_end="$((_cidata_part_start + CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
          "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        lvm_part_num=4
        _lvm_part_start="${_cidata_part_end}"
        _lvm_part_end="100%"
      else
        lvm_part_num=3
        _lvm_part_start="${_boot_part_end}"
        _lvm_part_end="100%"
      fi

      create_disk_partition "$lvm_part_num" "$_lvm_part_start" \
        "$_lvm_part_end" "$image_lvm_part_size" "LVM" "lvm"
    else
      # no separate boot partition
      if [ "$image_class" = "physical" ] && \
         [ -z "${image_without_cloud_init+x}" ]; then
        # Create a seperate partition for cloud-init config
        cidata_part_num=2
        _cidata_part_start="${_uefi_part_end}"
        _cidata_part_end="$((_cidata_part_start + CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
          "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        lvm_part_num=3
        _lvm_part_start="${_cidata_part_end}"
        _lvm_part_end="100%"
      else
        lvm_part_num=2
        _lvm_part_start="${_uefi_part_end}"
        _lvm_part_end="100%"
      fi

      create_disk_partition "$lvm_part_num" "$_lvm_part_start" \
        "$_lvm_part_end" "$image_lvm_part_size" "LVM" "lvm"
    fi
  else
    # No disk encryption, no LVM
    if [ -n "${needs_boot_partition+x}" ]; then
      # A separate boot partition is to be created.
      boot_part_num=2
      _boot_part_start="${_uefi_part_end}"
      _boot_part_end="$((_boot_part_start + image_boot_part_size))"

      create_disk_partition "$boot_part_num" "$_boot_part_start" \
        "$_boot_part_end" "$image_boot_part_size" "Boot"

      if [ "$image_class" = "physical" ]; then
        cidata_part_num=3
        _cidata_part_start="${_boot_part_end}"
        _cidata_part_end="$((_cidata_part_start + CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
          "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        root_part_num=4
        _root_part_start="${_cidata_part_end}"
        _root_part_end="100%"
      else
        root_part_num=3
        _root_part_start="${_boot_part_end}"
        _root_part_end="100%"
      fi

      create_disk_partition "$root_part_num" "$_root_part_start" \
        "$_root_part_end" "$image_root_part_size" "Root"
    else
      # No boot partition
      if [ "$image_class" = "physical" ]; then
        cidata_part_num=2
        _cidata_part_start="${_uefi_part_end}"
        _cidata_part_end="$((_cidata_part_start + CONSTANT_CIDATA_PART_SIZE))"

        create_disk_partition "$cidata_part_num" "$_cidata_part_start" \
          "$_cidata_part_end" "$CONSTANT_CIDATA_PART_SIZE" "cidata"

        root_part_num=3
        _root_part_start="${_cidata_part_end}"
        _root_part_end="100%"
      else
        root_part_num=2
        _root_part_start="${_uefi_part_end}"
        _root_part_end="100%"
      fi

      create_disk_partition "$root_part_num" "$_root_part_start" \
        "$_root_part_end" "$image_root_part_size" "Root"
    fi
  fi

  cat <<EOF >> "$run_script"
}
EOF
}


#
# Patch Grub to support specifying rootfs by label
#
patch_grub_for_label() {
  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"
# Debug
{
  cp /etc/grub.d/10_linux /etc/grub.d/10_linux-orig
	cp /usr/share/grub/grub-mkconfig_lib /usr/share/grub/grub-mkconfig_lib-orig
	cp /usr/sbin/grub-mkconfig /usr/sbin/grub-mkconfig-orig
}
EOF
  fi

  cat <<'EOF' >> "$run_script"

write_log "Temporarily installing patch program" 2
apk add --quiet patch >> $logfile

write_log "Patching /etc/grub.d/10_linux" 2
cat <<-'_SCRIPT_' | patch /etc/grub.d/10_linux >> $logfile
	--- /etc/grub.d/10_linux
	+++ /etc/grub.d/10_linux-label
	@@ -44,7 +44,8 @@
	 # the initrds that Linux uses don't like that.
	 case ${GRUB_DEVICE} in
	   /dev/loop/*|/dev/loop[0-9])
	-    GRUB_DEVICE=`losetup ${GRUB_DEVICE} | sed -e "s/^[^(]*(\([^)]\+\)).*/\1/"`
	+    # Work with both Busybox and util-linux versions of losetup
	+    GRUB_DEVICE=`losetup ${GRUB_DEVICE} | sed -e "s/^[^:]*: []0-9[\:]* [\(]*\([^)]\+\)[\)]*$/\1/"`
	   ;;
	 esac
	
	@@ -64,6 +65,10 @@
	   LINUX_ROOT_DEVICE=PARTUUID=${GRUB_DEVICE_PARTUUID}
	 else
	   LINUX_ROOT_DEVICE=UUID=${GRUB_DEVICE_UUID}
	+  GRUB_DEVICE_LABEL="$(blkid | grep "UUID=\"${GRUB_DEVICE_UUID}\"" | sed -e 's|^.* LABEL="||g' -e 's|".*||g' | head -1)"
	+  if [ "x${GRUB_ENABLE_LINUX_LABEL}" = "xtrue" ] ; then
	+    LINUX_ROOT_DEVICE=LABEL=${GRUB_DEVICE_LABEL}
	+  fi
	 fi
	
	 case x"$GRUB_FS" in
	_SCRIPT_

write_log "Patching /usr/share/grub/grub-mkconfig_lib" 2
cat <<-'_SCRIPT_' | patch /usr/share/grub/grub-mkconfig_lib >> $logfile
	--- grub-mkconfig_lib-stock
	+++ grub-mkconfig_lib-custom
	@@ -156,7 +156,9 @@
	   if [ "x$fs_hint" != x ]; then
	     echo "set root='$fs_hint'"
	   fi
	-  if fs_uuid="`"${grub_probe}" --device $@ --target=fs_uuid 2> /dev/null`" ; then
	+  if label="`${grub_probe} --device $@ --target=fs_label 2> /dev/null`" ; then
	+    echo "search --no-floppy --label --set=root ${label}"
	+  elif fs_uuid="`"${grub_probe}" --device $@ --target=fs_uuid 2> /dev/null`" ; then
	     hints="`"${grub_probe}" --device $@ --target=hints_string 2> /dev/null`" || hints=
	     echo "if [ x\$feature_platform_search_hint = xy ]; then"
	     echo "  search --no-floppy --fs-uuid --set=root ${hints} ${fs_uuid}"
	_SCRIPT_

write_log "Patching /usr/sbin/grub-mkconfig" 2
cat <<-'_SCRIPT_' | patch /usr/sbin/grub-mkconfig >> $logfile
	--- grub-mkconfig-stock
	+++ grub-mkconfig-custom
	@@ -135,10 +135,12 @@
	 GRUB_DEVICE="`${grub_probe} --target=device /`"
	 GRUB_DEVICE_UUID="`${grub_probe} --device ${GRUB_DEVICE} --target=fs_uuid 2> /dev/null`" || true
	 GRUB_DEVICE_PARTUUID="`${grub_probe} --device ${GRUB_DEVICE} --target=partuuid 2> /dev/null`" || true
	+GRUB_DEVICE_LABEL="`${grub_probe} --device ${GRUB_DEVICE} --target=fs_label 2> /dev/null`" || true
	 
	 # Device containing our /boot partition.  Usually the same as GRUB_DEVICE.
	 GRUB_DEVICE_BOOT="`${grub_probe} --target=device /boot`"
	 GRUB_DEVICE_BOOT_UUID="`${grub_probe} --device ${GRUB_DEVICE_BOOT} --target=fs_uuid 2> /dev/null`" || true
	+GRUB_DEVICE_BOOT_LABEL="`${grub_probe} --device ${GRUB_DEVICE_BOOT} --target=fs_label 2> /dev/null`" || true
	 
	 # Filesystem for the device containing our userland.  Used for stuff like
	 # choosing Hurd filesystem module.
	@@ -190,8 +192,10 @@
	 export GRUB_DEVICE \
	   GRUB_DEVICE_UUID \
	   GRUB_DEVICE_PARTUUID \
	+  GRUB_DEVICE_LABEL \
	   GRUB_DEVICE_BOOT \
	   GRUB_DEVICE_BOOT_UUID \
	+  GRUB_DEVICE_BOOT_LABEL \
	   GRUB_FS \
	   GRUB_FONT \
	   GRUB_PRELOAD_MODULES \
	@@ -226,6 +230,7 @@
	   GRUB_SERIAL_COMMAND \
	   GRUB_DISABLE_LINUX_UUID \
	   GRUB_DISABLE_LINUX_PARTUUID \
	+  GRUB_ENABLE_LINUX_LABEL \
	   GRUB_DISABLE_RECOVERY \
	   GRUB_VIDEO_BACKEND \
	   GRUB_GFXMODE \
	_SCRIPT_

write_log "Uninstalling patch program" 2
apk del --quiet patch >> $logfile
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"
# Debug
{
	write_debug_log "Diff 10_linux:" 2
  diff -aur /etc/grub.d/10_linux-orig /etc/grub.d/10_linux >> $logfile || true
  rm /etc/grub.d/10_linux-orig

  write_debug_log "Diff grub-mkconfig_lib:" 2
  diff -aur \
    /usr/share/grub/grub-mkconfig_lib-orig /usr/share/grub/grub-mkconfig_lib \\
    >> $logfile || true
  rm /usr/share/grub/grub-mkconfig_lib-orig

  write_debug_log "Diff grub-mkconfig:" 2
  diff -aur /usr/sbin/grub-mkconfig-orig /usr/sbin/grub-mkconfig \\
    >> $logfile || true
  rm /usr/sbin/grub-mkconfig-orig

}
EOF
  fi
}


#
# Prepare the main section of the run script
#
prep_runscript_main_section() {
  cat <<EOF >> "$run_script"

#############################################################################
##   Main Section
#############################################################################

# Ensure if any errors occur that various cleanup operations happen
trap error_cleanup EXIT

chroot_dir="$chroot_directory"
images_dir="$images_directory"
TMPDIR="/var/tmp"

image_filename="$filename_for_image"
logfile="$logs_output_file"

EOF

  if [ -n "${image_default_user_password+x}" ]; then
    cat <<EOF >> "$run_script"
default_user_password="$image_default_user_password"
EOF
  fi

  if [ -n "${image_encrypted+x}" ]; then
    cat <<EOF >> "$run_script"
encryption_passphrase="$image_encryption_passphrase"
EOF
  fi

  cat <<EOF >> "$run_script"

# Create empty logfile
:> \$logfile

EOF

if [ -n "${use_ramdisk+x}" ]; then
  cat <<EOF >> "$run_script"
ramdisk_dir="$ramdisk_directory"
image_full_filename="\$ramdisk_dir/\$image_filename"
EOF
else
  cat <<EOF >> "$run_script"
image_full_filename="\$images_dir/\$image_filename"
EOF
fi

cat <<EOF >> "$run_script"

check_for_required_packages
check_binfmt_packages $image_arch

mkdir -p \$images_dir

EOF
}


#
# Create the /etc/crypttab file
#
setup_crypttab() {
  local _crypttab_options="luks"

  if [ "$image_boot_device_media" = "sd" ] || \
     [ "$image_boot_device_media" = "ssd" ]; then
    # Enable discard to be triggered at intervals by fstrim via cron.
    _crypttab_options="$_crypttab_options,discard"
  fi

  cat <<EOF >> "$run_script"

write_log "Creating /etc/crypttab" 2
echo \\
  "${CONSTANT_LUKS_DEVICE_NAME} UUID=\${luks_part_uuid} /crypto_keyfile.bin $_crypttab_options" \\
  > /etc/crypttab
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

# Debug
{
  write_debug_log "/etc/crypttab contents:" 4
  cat /etc/crypttab >> /chroot.log
}
EOF
  fi
}


#
# Create Dropbear authorized_keys file
#
setup_dropbear_authorized_keys() {
  cat <<EOF >> "$run_script"

write_log "Setup Dropbear authorized_keys file"
{
  echo $ssh_public_key \\
    > /etc/dropbear/authorized_keys
  chown root:root /etc/dropbear/authorized_keys
  chmod 600 /etc/dropbear/authorized_keys
}
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

# Debug
{
  write_debug_log "Dropbear authorized_keys contents:" 2
  cat /etc/dropbear/authorized_keys >> "$logfile"
}
EOF
  fi
}


#
# Configure modules to be loaded upon boot
#
setup_etc_modules() {
  cat <<'EOF' >> "$run_script"

write_log "Setup /etc/modules"
{
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    cp /etc/modules /etc/modules-orig
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"

  cat <<-_SCRIPT_ > /etc/modules
	af_packet
EOF

  if [ "$image_class" = "physical" ] && \
     [ "$(expr "$image_physical_type" : '.*rpi.*')" -eq 0 ]; then
    # Physical machine except RPIs
    cat <<'EOF' >> "$run_script"
	button
EOF
  fi

  if [ -z "${image_disable_ipv6+x}" ]; then
    cat <<'EOF' >> "$run_script"
	ipv6
EOF
  fi

  if [ "$image_class" = "cloud" ] && \
     { [ "$image_cloud_type" = "aws" ] || \
       [ "$image_cloud_type" = "gce" ]; }; then
	  cat <<'EOF' >> "$run_script"
	nvme
EOF
  elif [ "$image_class" = "physical" ] && \
       [ "$(expr "$image_physical_type" : '.*rpi.*')" -eq 0 ] && \
       [ "$image_boot_device_type" = "nvme" ]; then
    # Physical machine except RPIs
    cat <<'EOF' >> "$run_script"
	nvme
EOF
  elif [ "$image_class" = "virtual" ] && \
       { [ "$image_vm_type" = "qemu" ] || \
         [ "$image_vm_type" = "virtualbox" ]; } && \
       [ "$image_boot_device_type" = "nvme" ]; then
    cat <<'EOF' >> "$run_script"
	nvme
EOF
  fi

  cat <<'EOF' >> "$run_script"
	rng-core
EOF

  if [ -n "${image_encrypted+x}" ]; then
    cat <<'EOF' >> "$run_script"

	# LUKS
	dm-crypt
EOF
  fi

  if [ -n "${image_encrypted+x}" ] && \
     [ -n "${remote_unlock_enabled+x}" ]; then
    # Add network module(s) need for remote encryption unlock
    case $image_class in
      physical )
        if [ "$image_physical_type" = "pc" ] && \
           [ -n "${remote_unlock_network_module}" ]; then
          cat <<EOF >> "$run_script"
	
	# For remote SSH unlock
	$remote_unlock_network_module
EOF
        else
          cat <<'EOF' >> "$run_script"
	
	# For remote SSH unlock
	e1000
EOF
        fi
        ;;
      virtual )
        if [ "$image_vm_type" = "vmware" ]; then
          cat <<'EOF' >> "$run_script"
	
	# For remote SSH unlock
	vmxnet3
EOF
        else
          cat <<'EOF' >> "$run_script"
	
	# For remote SSH unlock
	virtio_net
	virtio_pci
EOF
        fi
        ;;
    esac
  fi

###  cat <<'EOF' >> "$run_script"
###
###	# Used by rngd
###	jitterentropy_rng
###EOF

  if [ "$image_class" = "cloud" ]; then
    # Cloud machine
    cat <<'EOF' >> "$run_script"

	# Cloud-specific modules
	tiny-power-button
EOF

    case $image_cloud_type in
      azure | generic )
        cat <<'EOF' >> "$run_script"
	ptp_kvm
EOF
        ;;
    esac

    cat <<'EOF' >> "$run_script"
	###virtio-rng
EOF
  elif [ "$image_class" = "virtual" ]; then
    # Virtual machine
    case $image_vm_type in
      libvirtd | lxd | proxmox | qemu | generic )
        cat <<'EOF' >> "$run_script"

	# VM-specific modules
	tiny-power-button
	ptp_kvm
	virtio-rng
EOF
        ;;
      vmware )
        cat <<'EOF' >> "$run_script"

	# VM-specific modules
	ptp_vmw
EOF
        ;;
    esac

    # Add virtio_net moduile for all except Hyper-V and VMware
    case $image_vm_type in
      hyperv | vmware ) ;;
      * )
        cat <<'EOF' >> "$run_script"
	virtio_net
EOF
      ;;
    esac
  fi

  cat <<'EOF' >> "$run_script"
	_SCRIPT_
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    diff /etc/modules-orig /etc/modules >> /chroot.log || true
    rm /etc/modules-orig
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"
}
EOF
}


#
# Setup the LUKS device
#
setup_luks_device() {
  local _cipher_to_use

  if [ "$image_alpine_release" = "v3.13" ] && \
     [ "$image_bootloader" = "grub" ] && \
     [ -z "${image_no_grub_encryption+x}" ]; then
    # If the following apply:
    #  - using Alpine 3.13, AND
    #  - using Grub as bootloader, AND
    #  - GRUB LUKS encryption support is enabled
    # then only use LUKSv1 as version of Grub does not support booting from LUKSv2
    image_luks_version="1"
  elif [ "$image_bootloader" = "grub" ] && \
       [ -z "${image_no_grub_encryption+x}" ] && \
       [ "$image_encryption_cipher" != "adiantum" ]; then
    # If the following apply:
    #  - using Grub as bootloader, AND
    #  - GRUB LUKS encryption support is enabled
    #  - using standard cipher, not Adiantum (which Grub does not support), AND
    # then only use LUKSv1 as Grub has buggy support for booting from LUKSv2
    image_luks_version="1"
  else
    # Use LUKSv2 in all other situations
    image_luks_version="2"
  fi

  cat <<EOF >> "$run_script"

write_log "Setting up LUKS v${image_luks_version} device using ${image_encryption_cipher} cipher"
{
  luks_device="\${loop_device}p${luks_part_num}"
  write_log "Formatting partition as LUKS version ${image_luks_version}" 2
  echo "\$encryption_passphrase" | cryptsetup -q --verbose luksFormat \\
    --pbkdf pbkdf2 --type luks${image_luks_version} --label $CONSTANT_LUKS_LABEL \\
EOF

  if [ "$image_encryption_cipher" = "adiantum" ]; then
    cat <<EOF >> "$run_script"
    --cipher xchacha12,aes-adiantum-plain64 --hash sha256 --key-size 256 \\
EOF
	else
    cat <<EOF >> "$run_script"
    --cipher aes-xts-plain64 --hash sha256 --key-size 512 \\
EOF
  fi

  cat <<EOF >> "$run_script"
    "\$luks_device" >> "\$logfile" 2>&1
EOF

###      --offset 8 \

  if [ "$image_bootloader" = "grub" ] && \
     { [ -z "${image_experimental+x}" ] || \
       [ -z "${remote_unlock_enabled+x}" ]; } && \
     [ -z "${image_no_grub_encryption+x}" ] && \
     [ -z "${needs_boot_partition+x}" ]; then
    # When:
    #  - disk image is encrypted, AND
    #  - bootloader is Grub, AND
    #  - remote unlock is not enabled (as otherwise /boot is not encrypted), AND
    #  - Grub LUKS encryption support is not disabled, AND
    #  - /boot is not a separate partition
    # then create a keyfile - this will be placed in the initramfs
    # and used to unlock the rootfs - this prevents being prompted
    # for passphrase twice, once by Grub and then again by initramfs.
    cat <<EOF >> "$run_script"

  write_log "Creating keyfile for LUKS" 2
  dd bs=512 count=4 if=/dev/random of=crypto_keyfile.bin iflag=fullblock \\
    >> "\$logfile" 2>&1

  write_log "Adding keyfile to LUKS device" 2
  echo "\$encryption_passphrase" | \\
    cryptsetup luksAddKey "\$luks_device" ./crypto_keyfile.bin >> "\$logfile"

  write_log "Opening LUKS device" 2
  cryptsetup open --type luks$image_luks_version --key-file ./crypto_keyfile.bin \\
    "\$luks_device" $CONSTANT_LUKS_DEVICE_NAME
EOF
  else
    # Remote unlock enabled, use default passphrase to open
    cat <<EOF >> "$run_script"

  write_log "Opening LUKS device" 2
  echo "\$encryption_passphrase" | \\
    cryptsetup open --type luks$image_luks_version "\$luks_device" $CONSTANT_LUKS_DEVICE_NAME -
EOF
  fi

  cat <<'EOF' >> "$run_script"
  luks_part_uuid=$(get_uuid_from_device "$luks_device")
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_log "Show LUKS device details" 2
    cryptsetup luksDump "$luks_device" >> "$logfile"
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"
}
EOF
}


#
# Setup the LVM device
#
setup_lvm_device() {
  cat <<EOF >> "$run_script"

write_log "Setting up LVM device"
{
EOF

  if [ -n "${image_encrypted+x}" ]; then
    # LVM on top of LUKS
    cat <<EOF >> "$run_script"
  lvm_device="/dev/mapper/$CONSTANT_LUKS_DEVICE_NAME"
EOF
  else
    cat <<EOF >> "$run_script"
  lvm_device="\${loop_device}p${lvm_part_num}"
EOF
  fi

  cat <<'EOF' >> "$run_script"

  write_log "Creating LVM physical volume" 2
  pvcreate --verbose "$lvm_device" >> "$logfile" 2>&1
  _pv_size=$(pvdisplay --verbose 2>&1 | grep "PV Size" | sed -e 's/^.*PV Size[ ]*//' -e 's/\.[0-9]* MiB.*$//')
  write_debug_log "    Resultant PV size ${_pv_size}MiB"
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<'EOF' >> "$run_script"

  # Debug
  {
    write_debug_log "Physical volume info:"
    pvdisplay --verbose >> "$logfile" 2>&1
  }
EOF
  fi

  cat <<EOF >> "$run_script"

  write_log "Creating LVM volume group" 2
  vgcreate --verbose ${CONSTANT_LVM_VG_NAME} "\$lvm_device" >> "\$logfile" 2>&1
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<EOF >> "$run_script"

  # Debug
  {
    write_debug_log "Volume group info:"
    vgdisplay --verbose ${CONSTANT_LVM_VG_NAME} >> "\$logfile" 2>&1
  }
EOF
  fi

  cat <<EOF >> "$run_script"

  write_log "Creating $(calculate_lvm_root_lv_size)MiB LVM logical volume for rootfs" 2
  lvcreate --verbose -L $(calculate_lvm_root_lv_size)m ${CONSTANT_LVM_VG_NAME} -n ${CONSTANT_LVM_ROOT_LV_NAME} >> "\$logfile" 2>&1
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<EOF >> "$run_script"

  # Debug
  {
    write_debug_log "rootfs Logical Volume info:"
    lvs --verbose ${CONSTANT_LVM_VG_NAME}/${CONSTANT_LVM_ROOT_LV_NAME} >> "\$logfile" 2>&1

    write_debug_log "Volume group info:"
    vgdisplay --verbose ${CONSTANT_LVM_VG_NAME} >> "\$logfile" 2>&1
  }
EOF
  fi

  if [ -z "${needs_boot_partition+x}" ]; then
    cat <<EOF >> "$run_script"

  write_log "Creating $(calculate_lvm_boot_lv_size)MiB LVM logical volume for boot" 2
  lvcreate --verbose -L $(calculate_lvm_boot_lv_size)m ${CONSTANT_LVM_VG_NAME} -n ${CONSTANT_LVM_BOOT_LV_NAME} >> "\$logfile" 2>&1
EOF

    if [ -n "${debug_enabled+x}" ]; then
      cat <<EOF >> "$run_script"

  # Debug
  {
    write_debug_log "boot Logical Volume info:"
    lvs --verbose ${CONSTANT_LVM_VG_NAME}/${CONSTANT_LVM_BOOT_LV_NAME} >> "\$logfile" 2>&1

    write_debug_log "Volume group info:"
    vgdisplay --verbose ${CONSTANT_LVM_VG_NAME} >> "\$logfile" 2>&1
  }
EOF
    fi
  fi

  cat <<EOF >> "$run_script"

  write_log "Creating $(calculate_lvm_logs_lv_size)MiB LVM logical volume for logs" 2
  lvcreate --verbose -L $(calculate_lvm_logs_lv_size)m ${CONSTANT_LVM_VG_NAME} -n ${CONSTANT_LVM_LOGS_LV_NAME} >> "\$logfile" 2>&1
EOF

  if [ -n "${debug_enabled+x}" ]; then
    cat <<EOF >> "$run_script"

  # Debug
  {
    write_debug_log "logs Logical Volume info:"
    lvs --verbose ${CONSTANT_LVM_VG_NAME}/${CONSTANT_LVM_LOGS_LV_NAME} >> "\$logfile" 2>&1

    write_debug_log "Volume group info:"
    vgdisplay --verbose ${CONSTANT_LVM_VG_NAME} >> "\$logfile" 2>&1

    write_debug_log "lvscan output:"
    lvscan --verbose >> "\$logfile" 2>&1
  }
EOF
  fi

  cat <<'EOF' >> "$run_script"
}
EOF
}
