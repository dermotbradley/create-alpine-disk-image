#!/bin/sh
# shellcheck disable=SC2039

#############################################################################
##
##  mkinitfs-functions
##
##  Copyright 2021-2023 Dermot Bradley <dermot_bradley@yahoo.com>
##
##  Licensed via GPL version 2.0
##
#############################################################################


#
# Configure mkinitfs so that only the modules necessary for the relevant
# image type are placed in the initramfs file.
#
configure_mkinitfs() {
  local _optimise

  cat <<-'EOF' >> "$run_script"
	
	write_log "Configuring mkinitfs"
	{
	EOF

  if [ -n "$image_optimise" ]; then
    configure_mkinitfs_conf "optimise-"
  else
    configure_mkinitfs_conf
  fi

  configure_mkinitfs_feature_base
  if [ -n "$image_bootchart" ]; then
    configure_mkinitfs_feature_bootchart
  fi
  configure_mkinitfs_feature_keymap
  if [ -n "$luks_remote_unlock_enabled" ]; then
    configure_mkinitfs_feature_network
  fi
  if [ "$image_os_device_type" = "usb" ] || \
     { [ -z "$image_optimise" ] && \
       { [ "$image_keyboard_type" = "usb" ] || \
         [ "$image_keyboard_type" = "generic" ]; }; }; then
    # Either using USB for boot or else USB keyboard support with
    # non-optimised initramfs USB keyboard support (where this is defined
    # in usb.modules).
    configure_mkinitfs_feature_usb
  fi

  case $image_fs_type in
    btrfs )
      configure_mkinitfs_feature_btrfs ;;
    ext4 )
      configure_mkinitfs_feature_ext4 ;;
    f2fs )
      configure_mkinitfs_feature_f2fs ;;
    xfs )
      configure_mkinitfs_feature_xfs ;;
  esac

  if [ -n "$image_lvm_rootfs" ]; then
    configure_mkinitfs_feature_lvm
  fi

  case $image_encryption_type in
    both | luks )
      configure_mkinitfs_feature_cryptsetup ;;
  esac

  configure_mkinitfs_image_type_feature

  cat <<-'EOF' >> "$run_script"
	
	  write_log "Regenerating initramfs" 2
	  {
	    mkinitfs "\$_kernel_version" >> /chroot.log 2>&1
	  }
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-EOF >> "$run_script"
	
	  write_debug_log "Disk space usage after initramfs regenerated:" 2
	  df -k >> /chroot.log
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Configure /etc/mkinitfs/mkinitfs.conf
#
configure_mkinitfs_conf() {
  local _optimise=${1:-}

  local _features_list _cloud_features_list _virt_features_list

  cat <<-'EOF' >> "$run_script"
	  write_log "Setting up mkinitfs.conf" 2
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    cp /etc/mkinitfs/mkinitfs.conf /etc/mkinitfs/mkinitfs.conf-orig
	EOF
  fi

  _features_list="${_optimise:-}base keymap"
  if [ -n "$luks_remote_unlock_enabled" ]; then
    _features_list="$_features_list ${_optimise:-}network"
  fi

  if [ "$image_os_device_type" = "usb" ] || \
     { [ -z "$image_optimise" ] && \
       { [ "$image_keyboard_type" = "usb" ] || \
         [ "$image_keyboard_type" = "generic" ]; }; }; then
    # Either using USB for boot or else USB keyboard support with
    # non-optimised initramfs USB keyboard support (where this is defined
    # in usb.modules).
    _features_list="$_features_list ${_optimise:-}usb"
  fi

  # Add feature for relevant filesystem type
  case $image_fs_type in
    btrfs | ext4 | f2fs | xfs )
      _features_list="$_features_list ${_optimise:-}${image_fs_type}" ;;
    * )
      _features_list="$_features_list ${image_fs_type}" ;;
  esac

  if [ -n "$image_bootchart" ]; then
    _features_list="$_features_list ${_optimise:-}bootchart"
  fi

  if [ -n "$image_lvm_rootfs" ]; then
    _features_list="$_features_list ${_optimise:-}lvm"
  fi

  case $image_encryption_type in
    both | luks )
      case $image_bootloader in 
        grub )
          if { [ -z "$image_experimental" ] || \
               [ -z "$luks_remote_unlock_enabled" ]; } && \
             [ -z "$image_no_grub_luks_fde_encryption" ] && \
             [ "$image_create_boot_partition" != "true" ]; then
            # Cryptkey is used for unlock LUKS rootfs without 2nd password prompt.
            # It applies only when:
            #  - disk image is LUKS encrypted, AND
            #  - bootloader is Grub, AND
            #  - remote unlock is not enabled (as otherwise /boot is not encrypted), AND
            #  - Grub LUKS encryption support is not disabled AND
            #  - /boot is not a separate partition.
            _features_list="$_features_list cryptkey"
          fi
          ;;
      esac

      # cryptsetup is required in all rootfs encryption situations
      _features_list="$_features_list ${_optimise:-}cryptsetup"
      if [ -n "$image_experimental" ] && [ -n "$luks_remote_unlock_enabled" ]; then
        # enable SSH remote unlock functionality and also dhcp which it uses
        _features_list="$_features_list ${_optimise:-}dhcp ${_optimise:-}luks_remote_unlock"
      fi
      ;;
  esac


  case $image_class in
    cloud )
      _subclass_type="$image_cloud_type"
      ;;
    physical )
      _subclass_type="$image_physical_type"
      ;;
    virtual )
      _subclass_type="$image_vm_type"
      ;;
  esac
  _features_list="$_features_list $image_class-$_subclass_type"

  if [ -n "$debug_enabled" ]; then
    cat <<-EOF >> "$run_script"
	
	    write_debug_log "mkinitfs features list is: ${_features_list}" 2
	  }
	EOF
  fi

  cat <<-EOF >> "$run_script"
	
	  sed -i \\
	    -e "s|^features=\".*\"|features=\"${_features_list}\"|" \\
	    /etc/mkinitfs/mkinitfs.conf
	EOF

  if [ -n "$image_initramfs_compress" ]; then
    cat <<-EOF >> "$run_script"
	
	  write_log "Setting initramfs file compression to ${image_initramfs_compress}" 2
	  echo "initfscomp=${image_initramfs_compress}" >> /etc/mkinitfs/mkinitfs.conf
	EOF
  fi

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    diff /etc/mkinitfs/mkinitfs.conf-orig /etc/mkinitfs/mkinitfs.conf \
	      >> /chroot.log || true
	    rm /etc/mkinitfs/mkinitfs.conf-orig
	  }
	EOF
  fi
}


#
# Create/modify base mkinitfs feature files
#
configure_mkinitfs_feature_base() {
  cat <<-'EOF' >> "$run_script"
	
	  # Base
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimise-base.files

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-base.files" 2
	    {
	      echo "/bin/busybox"
	      echo "/bin/sh"
	      echo "/etc/mdev.conf"
	      echo "/etc/modprobe.d/aliases.conf"
	      echo "/etc/modprobe.d/i386.conf"
	      echo "/etc/modprobe.d/kms.conf"
	      echo "/lib/mdev"
	EOF

    case $image_alpine_release in
      v3.13 | v3.14 | v3.15 | v3.16 )
        # Use kmod/modprobe from kmod package
        cat <<-'EOF' >> "$run_script"
	      echo "/sbin/modprobe"
	EOF
        ;;
      * )
        # Rely on Busybox's modprobe
        : ;;
    esac

    cat <<-'EOF' >> "$run_script"
	      echo "/sbin/nlplug-findfs"
	    } > /etc/mkinitfs/features.d/optimise-base.files
	
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	    # Debug
	    {
	      write_debug_log "optimise-base.files contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-base.files >> /chroot.log
	    }
	
	EOF
    fi

    # optimise-base.modules

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-base.modules" 2
	EOF

    initramfs_entry_initialise "optimise-base"
    if [ -n "$image_hwrng" ] && [ "$image_class" = "physical" ]; then
      initramfs_entry_add "kernel/drivers/char/hw_random/rng-core.ko*"
    fi

    case $image_console_device_type in
      normal | normal_and_serial | generic )
        case $image_keyboard_type in
          usb | generic )
            # Need to add USB HID-related drivers to mkinitfs so that USB
            # keyboard can work in initramfs (i.e. for typing in Rescue Mode
            # or entering decryption passphrase for LUKS encryption)
            initramfs_entry_add "# USB keyboard-related modules"
            initramfs_entry_add "kernel/drivers/hid/hid-generic.ko*"
            initramfs_entry_add "kernel/drivers/hid/usbhid/usbhid.ko*"
            initramfs_entry_add "kernel/drivers/usb/host/ehci-pci.ko*"
            case $image_class in
              physical )
                # Extra vendor keyboards
                initramfs_entry_add "kernel/drivers/hid/hid-cherry.ko*"
                initramfs_entry_add "kernel/drivers/hid/hid-apple.ko*"
                initramfs_entry_add "kernel/drivers/hid/hid-kensington.ko*"
                initramfs_entry_add "kernel/drivers/hid/hid-lenovo.ko*"
                initramfs_entry_add "kernel/drivers/hid/hid-logitech.ko*"
                initramfs_entry_add "kernel/drivers/hid/hid-microsoft.ko*"
                ;;
            esac
            case $image_arch in
              aarch64 | armv7 )
                # Include OHCI module for Arm
                initramfs_entry_add "kernel/drivers/usb/host/ohci-pci.ko*" ;;
              x86 | x86_64 )
                # Include OHCI module by default, or where CPU vendor is
                # specified and is not Intel
                if [ -z "$image_cpu_vendor" ] || \
                   [ "$image_cpu_vendor" != "intel" ]; then
                  initramfs_entry_add "kernel/drivers/usb/host/ohci-pci.ko*"
                fi
                ;;
            esac
            case $image_arch in
              x86 | x86_64 )
                # Include UHCI module by default, or where CPU vendor is
                # specified and is Intel
                if [ -z "$image_cpu_vendor" ] || \
                   [ "$image_cpu_vendor" = "intel" ]; then
                  initramfs_entry_add "kernel/drivers/usb/host/uhci-hcd.ko*"
                fi
                ;;
            esac
            initramfs_entry_add "kernel/drivers/usb/host/xhci-pci.ko*"
            ;;
        esac

        case $image_keyboard_type in
          hyperv | generic )
            if [ "$image_class_subtype" = "azure" ] || \
               [ "$image_class_subtype" = "hyperv" ]; then
              # Need to add Hyper-V keyboard driver to mkinitfs so that
              # keyboard can work in initramfs (i.e. for typing in Rescue Mode
              # or entering decryption passphrase for LUKS encryption)
              initramfs_entry_add "# Hyper-V keyboard-related module"
              initramfs_entry_add "kernel/drivers/input/serio/hyperv-keyboard.ko*"
            fi
            ;;
        esac
        ;;
    esac

    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-base.modules contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-base.modules >> /chroot.log
	    }
	EOF
    fi

  else
    # base.files

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	    # Debug
	    {
	      write_debug_log "base.files contents:" 2
	      cat /etc/mkinitfs/features.d/base.files
	    }
	
	EOF
    fi

    # base.modules

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/base.modules" 2
	EOF

    initramfs_entry_initialise "base" "append"

    if [ -n "$image_hwrng" ] && [ "$image_class" = "physical" ]; then
      initramfs_entry_add "kernel/drivers/char/hw_random/*.ko*"
    fi

    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "base.modules contents:" 2
	      cat /etc/mkinitfs/features.d/base.modules >> /chroot.log
	    }
	EOF
    fi

  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify bootchart mkinitfs feature files
#
configure_mkinitfs_feature_bootchart() {
  cat <<-'EOF' >> "$run_script"
	
	  # Bootchart
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimise-bootchart.files

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-bootchart.files" 2
	    {
	      echo "/sbin/bootchartd"
	      echo "/usr/sbin/accton"
	    } > /etc/mkinitfs/features.d/optimise-bootchart.files
	
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	    # Debug
	    {
	      write_debug_log "optimise-bootchart.files contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-bootchart.files >> /chroot.log
	    }
	
	EOF
    fi
  else
    # bootchart.files

    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "bootchart.files contents:" 2
	      cat /etc/mkinitfs/features.d/bootchart.files >> /chroot.log
	    }
	
	EOF
    fi
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify btrfs mkinitfs feature files
#
configure_mkinitfs_feature_btrfs() {
  cat <<-'EOF' >> "$run_script"
	
	  # Btrfs
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimise-btrfs.files

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-btrfs.files" 2
	    {
	      echo "/sbin/btrfs"
	    } > /etc/mkinitfs/features.d/optimise-btrfs.files
	
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	    # Debug
	    {
	      write_debug_log "optimise-btrfs.files contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-btrfs.files >> /chroot.log
	    }
	
	EOF
    fi

    # optimise-btrfs.modules

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-btrfs.modules" 2
	EOF

    initramfs_entry_initialise "optimise-btrfs"
    case $image_arch in
      x86 | x86_64 )
        if [ -z "$image_cpu_vendor" ] || [ "$image_cpu_vendor" = "intel" ]; then
          initramfs_entry_add "kernel/arch/*/crypto/crc32c-intel.ko*"
        fi
        ;;
    esac
    initramfs_entry_add "kernel/crypto/xxhash_generic.ko*"
    initramfs_entry_add "kernel/fs/btrfs"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-btrfs.modules contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-btrfs.modules >> /chroot.log
	    }
	EOF
    fi

  else
    # btrfs.modules

    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "btrfs.modules contents:" 2
	      cat /etc/mkinitfs/features.d/btrfs.modules >> /chroot.log
	    }
	EOF

    fi

  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify cryptsetup mkinitfs feature files
#
configure_mkinitfs_feature_cryptsetup() {
  cat <<-'EOF' >> "$run_script"
	
	  # Cryptsetup
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimise-cryptsetup.files

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-cryptsetup.files" 2
	    {
	      echo "/sbin/cryptsetup"
	    } >> /etc/mkinitfs/features.d/optimise-cryptsetup.files
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-cryptsetup.files contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-cryptsetup.files >> /chroot.log
	    }
	EOF
    fi

    # optimise-cryptsetup.modules

    cat <<-'EOF' >> "$run_script"
	
	    write_log "Setting up features.d/optimise-cryptsetup.modules" 2
	EOF

    initramfs_entry_initialise "optimise-cryptsetup"
    case $image_arch in
      aarch64 )
        case $image_luks_cipher in
          adiantum )
            initramfs_entry_add "kernel/arch/arm64/crypto/chacha-neon.ko*"
            initramfs_entry_add "kernel/arch/arm64/crypto/nhpoly1305-neon.ko*"
            initramfs_entry_add "kernel/arch/arm64/crypto/poly1305-neon.ko*"
            ;;
          * )
            initramfs_entry_add "kernel/arch/arm64/crypto/aes-arm64.ko*"
            initramfs_entry_add "kernel/arch/arm64/crypto/aes-neon-blk.ko*"
            initramfs_entry_add "kernel/arch/arm64/crypto/aes-neon-bs.ko*"
            ;;
        esac
        case $image_class in
          cloud | virtual )
            # Add Arm Crypto Extension modules for ARM64 virtual servers
            initramfs_entry_add "kernel/arch/arm64/crypto/*-ce*.ko*" ;;
          physical )
            case $image_physical_type in
              arm-server )
                # Add Arm Crypto Extension modules for ARM64 physical servers
                initramfs_entry_add "kernel/arch/arm64/crypto/*-ce*.ko*" ;;
            esac
            ;;
        esac
        ;;
      armv7 )
        case $image_luks_cipher in
          adiantum )
            initramfs_entry_add "kernel/arch/arm/crypto/chacha-neon.ko*"
            initramfs_entry_add "kernel/arch/arm/crypto/poly1305-arm.ko*"
            ;;
          * )
            initramfs_entry_add "kernel/arch/arm/crypto/aes-arm.ko*"
            initramfs_entry_add "kernel/arch/arm/crypto/aes-arm-bs.ko*"
            ;;
        esac
        ;;
      x86 | x86_64 )
        case $image_luks_cipher in
          adiantum )
            initramfs_entry_add "kernel/crypto/chacha_generic.ko*"
            initramfs_entry_add "kernel/crypto/chacha_x86_64.ko*"
            initramfs_entry_add "kernel/crypto/nhpoly1305.ko*"
            ;;
          * )
            if [ -z "$image_cpu_vendor" ] || [ "$image_cpu_vendor" = "intel" ]; then
              initramfs_entry_add "kernel/arch/x86/crypto/aesni-intel.ko*"
            fi
            ;;
        esac
        ;;
    esac
    case $image_luks_cipher in
      adiantum )
        initramfs_entry_add "kernel/crypto/adiantum.ko*" ;;
    esac
    initramfs_entry_add "kernel/crypto/algif_skcipher.ko*"
    initramfs_entry_add "kernel/drivers/md/dm-crypt.ko*"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-cryptsetup.modules contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-cryptsetup.modules >> /chroot.log
	    }
	EOF
    fi
  else
    cat <<-'EOF' >> "$run_script"
	    :
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify ext4 mkinitfs feature files
#
configure_mkinitfs_feature_ext4() {
  cat <<-'EOF' >> "$run_script"
	
	  # Ext4
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimise-ext4.modules

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-ext4.modules" 2
	EOF

    initramfs_entry_initialise "optimise-ext4"
    case $image_arch in
      x86 | x86_64 )
        if [ -z "$image_cpu_vendor" ] || [ "$image_cpu_vendor" = "intel" ]; then
          initramfs_entry_add "kernel/arch/*/crypto/crc32c-intel.ko*"
        fi
        ;;
    esac
    initramfs_entry_add "kernel/crypto/crc32c*.ko*"
    initramfs_entry_add "kernel/fs/ext4"
    initramfs_entry_add "kernel/fs/jbd2"
    initramfs_entry_add "kernel/fs/mbcache"
    initramfs_entry_add "kernel/lib/crc16.ko*"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-ext4.modules contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-ext4.modules >> /chroot.log
	    }
	EOF
    fi

  else
    # ext4.modules

    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "ext4.modules contents:" 2
	      cat /etc/mkinitfs/features.d/ext4.modules >> /chroot.log
	    }
	EOF

    fi

  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify f2fs mkinitfs feature files
#
configure_mkinitfs_feature_f2fs() {
  cat <<-'EOF' >> "$run_script"
	
	  # F2FS
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimise-f2fs.modules

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-f2fs.modules" 2
	EOF

    initramfs_entry_initialise "optimise-f2fs"
    case $image_arch in
      x86 | x86_64 )
        if [ -z "$image_cpu_vendor" ] || [ "$image_cpu_vendor" = "intel" ]; then
          initramfs_entry_add "kernel/arch/*/crypto/crc32-pcmul*"
        fi
        ;;
    esac
    initramfs_entry_add "kernel/crypto/crc32_generic*"
    initramfs_entry_add "kernel/fs/f2fs"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-f2fs.modules contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-f2fs.modules >> /chroot.log
	    }
	EOF
    fi

  else
    # f2fs.modules

    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "f2fs.modules contents:" 2
	      cat /etc/mkinitfs/features.d/f2fs.modules >> /chroot.log
	    }
	EOF

    fi

  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify keymap mkinitfs feature files
#
configure_mkinitfs_feature_keymap() {
  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Keymap
	  {
	    # Debug
	    {
	      write_debug_log "keymap.files contents:" 2
	      cat /etc/mkinitfs/features.d/keymap.files >> /chroot.log
	    }
	  }
	EOF
  fi
}


#
# Create/modify lvm mkinitfs feature files
#
configure_mkinitfs_feature_lvm() {
  cat <<-'EOF' >> "$run_script"
	
	  # LVM
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimise-lvm.files
    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-lvm.files" 2
	    {
	      echo "/sbin/lvm"
	    } >> /etc/mkinitfs/features.d/optimise-lvm.files
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-lvm.files contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-lvm.files >> /chroot.log
	    }
	EOF
    fi

    # optimise-lvm.modules
    cat <<-'EOF' >> "$run_script"
	
	    write_log "Setting up features.d/optimise-lvm.modules" 2
	EOF

    initramfs_entry_initialise "optimise-lvm"
    initramfs_entry_add "kernel/drivers/md/dm-mod.ko*"
    initramfs_entry_add "kernel/drivers/md/dm-snapshot.ko*"
    initramfs_entry_add "kernel/drivers/md/dm-thin-pool.ko*"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-lvm.modules contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-lvm.modules >> /chroot.log
	    }
	EOF
    fi

  else
    # lvm.files & lvm.modules
    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "lvm.files contents:" 2
	      cat /etc/mkinitfs/features.d/lvm.files >> /chroot.log
	
	      write_debug_log "lvm.modules contents:" 2
	      cat /etc/mkinitfs/features.d/lvm.modules >> /chroot.log
	    }
	EOF
    fi
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify mmc mkinitfs feature files
#
configure_mkinitfs_feature_mmc() {
  cat <<-'EOF' >> "$run_script"
	
	  # MMC
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimise-mmc.modules
    cat <<-'EOF' >> "$run_script"
	
	    write_log "Setting up features.d/optimise-mmc.modules" 2
	EOF

    initramfs_entry_initialise "optimise-mmc"
    case $image_physical_type in
      pc )
        initramfs_entry_add "kernel/drivers/mmc" ;;
      rpi* )
        if [ "$image_physical_type" = "rpi4" ]; then
          # RPI4 only?
          initramfs_entry_add "kernel/drivers/mmc/host/mmc_spi.ko*"
          initramfs_entry_add "kernel/drivers/mmc/host/of_mmc_spi.ko*"
          initramfs_entry_add "kernel/drivers/mmc/host/sdhci-iproc.ko*"
        fi
        ;;
    esac
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-mmc.modules contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-mmc.modules >> /chroot.log
	    }
	EOF
    fi

  else
    # mmc.modules
    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "mmc.modules contents:" 2
	      cat /etc/mkinitfs/features.d/mmc.modules >> /chroot.log
	    }
	EOF
    fi
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify network mkinitfs feature files
#
configure_mkinitfs_feature_network() {
  cat <<-'EOF' >> "$run_script"
	
	  # Network
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimise-network.files
    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-network.files" 2
	    {
	EOF

    cat <<-'EOF' >> "$run_script"
	      echo "# This file is empty"
	    } > /etc/mkinitfs/features.d/optimise-network.files
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-network.files contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-network.files >> /chroot.log
	    }
	EOF
    fi

    # optimise-network.modules
    if [ -n "$luks_remote_unlock_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    write_log "Setting up features.d/optimise-network.modules" 2
	EOF

      initramfs_entry_initialise "optimise-network"

      if [ -z "$image_disable_ipv6" ]; then
        initramfs_entry_add "kernel/net/ipv6/ipv6.ko*"
      fi

      # Remote encryption unlocking over network
      if [ -n "$luks_remote_unlock_enabled" ]; then
        if [ -n "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" ]; then
          if [ -n "$image_ethernet_module" ]; then
            if is_in_comma_list "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" "$image_ethernet_module"; then
              convert_network_names_to_initramfs_entries "$image_ethernet_module"
              case $image_ethernet_module in
                r8169 )
                  initramfs_entry_add "kernel/drivers/net/phy/realtek.ko*" ;;
              esac
            else
              error_message "Ethernet driver '$image_ethernet_module' is not defined in CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS for '$image_class'!"
            fi
          elif [ -n "$CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER" ]; then
            if is_in_comma_list "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" "$CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER"; then
              convert_network_names_to_initramfs_entries "$CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER"
            else
              error_message "'$CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER' is not defined in CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS for '$image_class'!"
            fi
          else
            error_message "CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER is not defined for '$image_class'!"
          fi
        else
          error_message "CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS is not defined for '$image_class'!"
        fi
      fi

      initramfs_entry_finish

      if [ -n "$debug_enabled" ]; then
        cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-network.modules contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-network.modules >> /chroot.log
	    }
	EOF
      fi
    else
      cat <<-'EOF' >> "$run_script"
	    :
	EOF
    fi
  else
    # network.files & network.modules
    if [ -n "$luks_remote_unlock_enabled" ]; then

      cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/network.modules" 2
	EOF

      if [ -z "$image_disable_ipv6" ]; then
        initramfs_entry_initialise "network" "append"
        initramfs_entry_add "kernel/net/ipv6/ipv6.ko*"
        initramfs_entry_finish
      fi
    else
      cat <<-'EOF' >> "$run_script"
	    :
	EOF
    fi

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "network.files contents:" 2
	      cat /etc/mkinitfs/features.d/network.files >> /chroot.log
	
	      write_debug_log "network.modules contents:" 2
	      cat /etc/mkinitfs/features.d/network.modules >> /chroot.log
	    }
	EOF
    fi
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify nvme mkinitfs feature files
#
configure_mkinitfs_feature_nvme() {
  cat <<-'EOF' >> "$run_script"
	
	   # NVME
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimise-nvme.modules
    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-nvme.modules" 2
	EOF

    initramfs_entry_initialise "optimise-nvme"
    initramfs_entry_add "kernel/drivers/nvme/host/nvme.ko*"
    initramfs_entry_add "kernel/drivers/pci/controller/vmd.ko*"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-nvme.modules contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-nvme.modules >> /chroot.log
	    }
	EOF
    fi

  else
    # nvme.modules
    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "nvme.modules contents:" 2
	      cat /etc/mkinitfs/features.d/nvme.modules >> /chroot.log
	    }
	EOF
    fi

  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify scsi mkinitfs feature files
#
configure_mkinitfs_feature_scsi() {
  cat <<-'EOF' >> "$run_script"
	
	  # SCSI
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimised-scsi.modules
    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-scsi.modules" 2
	EOF

    initramfs_entry_initialise "optimise-scsi"

    case $image_physical_type in
      arm-server | pc )
        case $image_os_device_type in
          sata | scsi )
            initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*" ;;
          usb )
            initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
            initramfs_entry_add "kernel/drivers/scsi/ses.ko*"
            ;;
        esac
        ;;
      rpi* )
        if [ "$image_os_device_type" = "usb" ]; then
          initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
          initramfs_entry_add "kernel/drivers/scsi/ses.ko*"
        fi
        ;;
    esac
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-scsi.modules contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-scsi.modules >> /chroot.log
	    }
	EOF
    fi

  else
    # scsi.modules
    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "scsi.modules contents:" 2
	      cat /etc/mkinitfs/features.d/scsi.modules >> /chroot.log
	    }
	EOF
    fi

  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify usb mkinitfs feature files
#
configure_mkinitfs_feature_usb() {
  cat <<-'EOF' >> "$run_script"
	
	  # USB
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimise-usb.modules
    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-usb.modules" 2
	EOF

    initramfs_entry_initialise "optimise-usb"

    # OS device
    case $image_class in
      physical )
        # Boot/root filesystem stored on USB device
        case $image_os_device_type in
          usb )
            initramfs_entry_add "kernel/drivers/usb/storage/uas.ko*"
            initramfs_entry_add "kernel/drivers/usb/storage/usb-storage.ko*"
            ;;
        esac
        case $image_physical_type in
          rpi* )
            initramfs_entry_add "kernel/fs/fat"
            initramfs_entry_add "kernel/fs/nls"
            ;;
        esac
        ;;
    esac
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-usb.modules contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-usb.modules >> /chroot.log
	    }
	EOF
    fi

  else
    # usb.modules
    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "usb.modules contents:" 2
	      cat /etc/mkinitfs/features.d/usb.modules >> /chroot.log
	    }
	EOF
    fi

  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify virthost mkinitfs feature files
#
configure_mkinitfs_feature_virthost() {
  cat <<-'EOF' >> "$run_script"
	
	  # VirtHost
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimised-virthost.modules
    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-virthost.modules" 2
	EOF

    initramfs_entry_initialise "optimise-virthost"
    initramfs_entry_add "kernel/drivers/vhost/vhost.ko*"
    initramfs_entry_add "kernel/drivers/vhost/vhost_net.ko*"
    initramfs_entry_add "kernel/drivers/vhost/vhost_scsi.ko*"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-virthost.modules contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-virthost.modules >> /chroot.log
	    }
	EOF
    fi
  else
    # virthost.modules
    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/virthost.modules" 2
	EOF

    initramfs_entry_initialise "virthost"
    initramfs_entry_add "kernel/drivers/vhost/*.ko*"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "virthost.modules contents:" 2
	      cat /etc/mkinitfs/features.d/virthost.modules >> /chroot.log
	    }
	EOF
    fi
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify xfs mkinitfs feature files
#
configure_mkinitfs_feature_xfs() {
  cat <<-'EOF' >> "$run_script"
	
	  # XFS
	  {
	EOF

  if [ -n "$image_optimise" ]; then
    # optimise-xfs.files
    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-xfs.files" 2
	    {
	      echo "/sbin/xfs_repair"
	    } > /etc/mkinitfs/features.d/optimise-xfs.files
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-xfs.files contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-xfs.files >> /chroot.log
	    }
	EOF
    fi

    # optimise-xfs.modules
    cat <<-'EOF' >> "$run_script"
	
	    write_log "Setting up features.d/optimise-xfs.modules" 2
	EOF

    initramfs_entry_initialise "optimise-xfs"
    case $image_arch in
      x86 | x86_64 )
        if [ -z "$image_cpu_vendor" ] || [ "$image_cpu_vendor" = "intel" ]; then
          initramfs_entry_add "kernel/arch/*/crypto/crc32c-intel.ko*"
        fi
        ;;
    esac
    initramfs_entry_add "kernel/crypto/crc32c*.ko*"
    initramfs_entry_add "kernel/fs/xfs/xfs.ko*"
    initramfs_entry_add "kernel/lib/libcrc32c.ko*"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "optimise-xfs.modules contents:" 2
	      cat /etc/mkinitfs/features.d/optimise-xfs.modules >> /chroot.log
	    }
	EOF
    fi

  else
    # xfs.files and xfs.modules
    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    {
	      # Debug
	      write_debug_log "xfs.files contents:" 2
	      cat /etc/mkinitfs/features.d/xfs.files >> /chroot.log
	
	      # Debug
	      write_debug_log "xfs.modules contents:" 2
	      cat /etc/mkinitfs/features.d/xfs.modules >> /chroot.log
	    }
	EOF
    fi

  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create mkinitfs feature file for cloud/physical/virtual
#
configure_mkinitfs_image_type_feature() {
  local _driver_path _list _list_item

  cat <<-EOF >> "$run_script"
	
	  {
	    write_log "Setting up features.d/${image_class}-${image_class_subtype}.modules" 2
	EOF

  initramfs_entry_initialise "${image_class}-${image_class_subtype}"

  # ACPI Button
  case $image_acpi_power_method in
    button )
      initramfs_entry_add "kernel/drivers/acpi/button.ko*" ;;

    generic )
      if is_in_comma_list "CADI_SUPPORTED_ACPI_BUTTONS" "button"; then
        initramfs_entry_add "kernel/drivers/acpi/button.ko*"
      fi
      if is_in_comma_list "CADI_SUPPORTED_ACPI_BUTTONS" "tiny-power-button"; then
        initramfs_entry_add "kernel/drivers/acpi/tiny-power-button.ko*"
      fi
      if is_in_comma_list "CADI_SUPPORTED_ACPI_BUTTONS" "gpio"; then
        case $image_arch in
          aarch64 )
            initramfs_entry_add "kernel/drivers/gpio/gpio-pl061.ko*" ;;
        esac
      fi
      ;;

    gpio )
      initramfs_entry_add "kernel/drivers/gpio/gpio-pl061.ko*" ;;

    tiny-power-button )
      initramfs_entry_add "kernel/drivers/acpi/tiny-power-button.ko*" ;;
  esac

  # Crypto devices
  if [ -n "$CADI_SUPPORTED_CRYPTO_DEVICES" ]; then
    # Check every crypto device listed
    _list="$CADI_SUPPORTED_CRYPTO_DEVICES"
    while true; do
      _list_item="$(first_entry_in_comma_list "$_list")"
      case $_list_item in
        ccp )
          initramfs_entry_add "kernel/drivers/crypto/ccp" ;;
        virtio )
          initramfs_entry_add "kernel/drivers/crypto/virtio" ;;
        * )
          error_message "Unknown crypto device type: $_list_item!"
          ;;
      esac
      if [ "${_list%,*}" = "$_list" ]; then
        # No more entries
        break
      else
        _list="${_list#$_list_item,}"
      fi
    done
  fi

  # RNGs
  if [ -n "$CADI_SUPPORTED_RNGS" ]; then
    # Check every RNG device listed
    _list="$CADI_SUPPORTED_RNGS"
    while true; do
      _list_item="$(first_entry_in_comma_list "$_list")"
      case $_list_item in
        amd )
          if [ -z "$image_cpu_vendor" ] || \
             [ "$image_cpu_vendor" = "amd" ]; then
            initramfs_entry_add "kernel/drivers/char/hw_random/amd-rng.ko*"
          fi
          ;;
        intel )
          if [ -z "$image_cpu_vendor" ] || \
             [ "$image_cpu_vendor" = "intel" ]; then
            initramfs_entry_add "kernel/drivers/char/hw_random/intel-rng.ko*"
          fi
          ;;
        virtio )
          initramfs_entry_add "kernel/drivers/char/hw_random/virtio-rng.ko*"
          ;;
        * )
          error_message "Unknown RNG type: $_list_item!"
          ;;
      esac
      if [ "${_list%,*}" = "$_list" ]; then
        # No more entries
        break
      else
        _list="${_list#$_list_item,}"
      fi
    done
  fi

  # Console / Display / KMS
  case $image_console_device_type in
    hypervisor )
      if [ -n "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES" ] && \
         is_in_comma_list "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES" "hypervisor"; then
        initramfs_entry_add "kernel/drivers/char/virtio_console.ko*"
      else
        error_message "Virtio console is not supported by $class_type_description!"
      fi
      ;;

    none | serial )
      : ;;

    * )
      # normal, normal_and_serial, or generic

      if [ -n "$image_enable_graphics" ] && \
         [ "$image_enable_graphics" = "true" ]; then
        # Graphic driver(s) is/are required

        case $image_console_output_type in
          generic )
            # Need all relevant DRM driver(s)
            if [ -n "$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS" ]; then
              # Add every graphics driver listed (except "generic")
              _list="$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS"
              while true; do
                _list_item="$(first_entry_in_comma_list "$_list")"
                case $_list_item in
                  generic )
                    # Skip this entry
                    : ;;
                  * )
                    _driver_path="$(get_graphics_driver_initfs_path "$_list_item")"
                    if [ -n "$_driver_path" ]; then
                      initramfs_entry_add "$_driver_path"
                    else
                      error_message "Unknown graphics driver: $_list_item!"
                    fi
                    ;;
                esac

                if [ "${_list%,*}" = "$_list" ]; then
                  # No more entries
                  break
                else
                  _list="${_list#$_list_item,}"
                fi
              done
            else
              error_message "Adding graphic drivers to initramfs but CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS is not defined!"
            fi
            ;;

          graphics )
            # Need DRM (or fbdev) driver
            if [ -n "$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS" ]; then
              #  List of supported graphics drivers is defined
              if [ -n "$image_graphics_driver" ]; then
                # Override default graphics driver
                if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS" "$image_graphics_driver"; then
                  if [ "$image_graphics_driver" = "generic" ]; then
                    # Add every graphics driver listed (except "generic")
                    _list="$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS"
                    while true; do
                      _list_item="$(first_entry_in_comma_list "$_list")"
                      case $_list_item in
                        generic )
                          # Skip this entry
                          : ;;
                        * )
                          _driver_path="$(get_graphics_driver_initfs_path "$_list_item")"
                          if [ -n "$_driver_path" ]; then
                            initramfs_entry_add "$_driver_path"
                          else
                            error_message "Unknown graphics driver: $_list_item!"
                          fi
                          ;;
                      esac

                      if [ "${_list%,*}" = "$_list" ]; then
                        # No more entries
                        break
                      else
                        _list="${_list#$_list_item,}"
                      fi
                    done
                  else
                    _driver_path="$(get_graphics_driver_initfs_path "$image_graphics_driver")"
                    if [ -z "$_driver_path" ]; then
                      error_message "Unknown graphics driver: $image_graphics_driver!"
                    else
                      initramfs_entry_add "$_driver_path"
                    fi
                  fi
                else
                  error_message "Specified graphic driver '$image_graphics_driver' is not supported by $class_type_description!"
                fi
              elif [ -n "$CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER" ]; then
                # Use the default graphics driver
                if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS" "$CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER"; then
                  if [ "$CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER" = "generic" ]; then
                    # Add every graphics driver listed (except "generic")
                    _list="$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS"
                    while true; do
                      _list_item="$(first_entry_in_comma_list "$_list")"
                      case $_list_item in
                        generic )
                          # Skip this entry
                          : ;;
                        * )
                          _driver_path="$(get_graphics_driver_initfs_path "$_list_item")"
                          if [ -n "$_driver_path" ]; then
                            initramfs_entry_add "$_driver_path"
                          else
                            error_message "Unknown graphics driver: $_list_item!"
                          fi
                          ;;
                      esac

                      if [ "${_list%,*}" = "$_list" ]; then
                        # No more entries
                        break
                      else
                        _list="${_list#$_list_item,}"
                      fi
                    done
                  else
                    _driver_path="$(get_graphics_driver_initfs_path "$CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER")"
                    if [ -z "$_driver_path" ]; then
                      error_message "Unknown graphics driver: $CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER!"
                    else
                      initramfs_entry_add "$_driver_path"
                    fi
                  fi
                else
                  error_message "Wanted to add default graphic driver '$CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER' to initramfs but it is not defined in CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER!"
                fi
              else
                # No default graphics driver is defined
                error_message "Wanted to add default graphic driver to initramfs but CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER is not defined!"
              fi
            else
              #  No list of supported graphics drivers is defined
              error_message "Wanted to add graphic driver to initramfs but CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS is not defined!"
            fi
            ;;
        esac
      else
        # Text console
        if [ "$image_console_device_type" = "generic" ] && \
           [ -n "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES" ] && \
           is_in_comma_list "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES" "hypervisor"; then
          initramfs_entry_add "kernel/drivers/char/virtio_console.ko*"
        fi
      fi
      ;;
  esac

  # Network - only used for remote encryption unlock
  if [ -n "$luks_remote_unlock_enabled" ]; then
    if [ -n "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" ]; then
      if [ -n "$CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER" ] && \
         is_in_comma_list "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" "$CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER"; then
        case $CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER in
          hyperv )
            initramfs_entry_add "kernel/drivers/net/hyperv/hv_netvsc.ko*" ;;
          virtio-net )
            initramfs_entry_add "kernel/drivers/net/virtio_net.ko*" ;;
          vmxnet3 )
            initramfs_entry_add "kernel/drivers/net/vmxnet3" ;;
        esac
      else
        # Add every network driver supported
        _list="$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS"
        while true; do
          _list_item="$(first_entry_in_comma_list "$_list")"
          case $_list_item in
            hyperv )
              initramfs_entry_add "kernel/drivers/net/hyperv/hv_netvsc.ko*" ;;
            virtio-net )
              initramfs_entry_add "kernel/drivers/net/virtio_net.ko*" ;;
            vmxnet3 )
              initramfs_entry_add "kernel/drivers/net/vmxnet3" ;;
          esac
          if [ "${_list%,*}" = "$_list" ]; then
            # No more entries
            break
          else
            _list="${_list#$_list_item,}"
          fi
        done
      fi
    else
      error_message "Unable to determine network driver to add to initramfs for remote encryption unlocking support!"
    fi
  fi

  # Storage
  if [ -z "$image_os_device_type" ]; then
    # Automatically select storage driver(s)

    if [ -n "$CADI_DEFAULT_OS_DEVICE_TYPE" ] && \
       [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ] && \
       is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" "$CADI_DEFAULT_OS_DEVICE_TYPE"; then
      case $CADI_DEFAULT_OS_DEVICE_TYPE in
        generic )
          initramfs_entry_add "kernel/drivers/scsi/hv_storvsc.ko*"
          initramfs_entry_add "kernel/drivers/nvme/host/nvme.ko*"
          initramfs_entry_add "kernel/drivers/message/fusion/mptsas.ko*"
          # Device-type specific
          case $image_class in
            cloud | virtual )
              initramfs_entry_add "kernel/drivers/block/virtio_blk.ko*"
              initramfs_entry_add "kernel/drivers/scsi/virtio_scsi.ko*"
              ;;
            physical )
              case $image_physical_type in
                rpi* )
                  initramfs_entry_add "kernel/drivers/mmc/host/mmc_spi.ko*"
                  initramfs_entry_add "kernel/drivers/mmc/host/of_mmc_spi.ko*"
                  initramfs_entry_add "kernel/drivers/mmc/host/sdhci-iproc.ko*"
                  initramfs_entry_add "kernel/fs/fat"
                  initramfs_entry_add "kernel/fs/nls"
                  ;;
                * )
                  initramfs_entry_add "kernel/drivers/mmc/host/sdhci.ko*" ;;
              esac
              ;;
          esac
          initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
          ;;
        hyperv )
          initramfs_entry_add "kernel/drivers/scsi/hv_storvsc.ko*" ;;
        nvme )
          initramfs_entry_add "kernel/drivers/nvme/host/nvme.ko*" ;;
        pvscsi )
          # VMware's VMDK file provides no way to indicate PVSCSI is used, can only
          # indicate "lsi_logic" and then later switch the VM to use PVSCSI.
          initramfs_entry_add "kernel/drivers/message/fusion/mptsas.ko*"
          initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
          ;;
        virtio-blk )
          initramfs_entry_add "kernel/drivers/block/virtio_blk.ko*" ;;
        virtio-scsi )
          initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
          initramfs_entry_add "kernel/drivers/scsi/virtio_scsi.ko*"
          ;;
      esac
    elif [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ]; then
      # Add every storage driver supported
      _list="$CADI_SUPPORTED_OS_DEVICE_TYPES"
      while true; do
        _list_item="$(first_entry_in_comma_list "$_list")"
        case $_list_item in
          generic )
            initramfs_entry_add "kernel/drivers/scsi/hv_storvsc.ko*"
            initramfs_entry_add "kernel/drivers/nvme/host/nvme.ko*"
            initramfs_entry_add "kernel/drivers/message/fusion/mptsas.ko*"
            # Device-type specific
            case $image_class in
              cloud | virtual )
                initramfs_entry_add "kernel/drivers/block/virtio_blk.ko*"
                initramfs_entry_add "kernel/drivers/scsi/virtio_scsi.ko*"
                ;;
              physical )
                case $image_physical_type in
                  rpi* )
                    initramfs_entry_add "kernel/drivers/mmc/host/mmc_spi.ko*"
                    initramfs_entry_add "kernel/drivers/mmc/host/of_mmc_spi.ko*"
                    initramfs_entry_add "kernel/drivers/mmc/host/sdhci-iproc.ko*"
                    initramfs_entry_add "kernel/fs/fat"
                    initramfs_entry_add "kernel/fs/nls"
                    ;;
                  * )
                    initramfs_entry_add "kernel/drivers/mmc/host/sdhci.ko*" ;;
                esac
                ;;
            esac
            initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
            ;;
          hyperv )
            initramfs_entry_add "kernel/drivers/scsi/hv_storvsc.ko*" ;;
          nvme )
            initramfs_entry_add "kernel/drivers/nvme/host/nvme.ko*" ;;
          pvscsi )
            # VMware's VMDK file provides no way to indicate PVSCSI is used, can only
            # indicate "lsi_logic" and then later switch the VM to use PVSCSI.
            initramfs_entry_add "kernel/drivers/message/fusion/mptsas.ko*"
            initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
            ;;
          sata | scsi | usb )
            initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
            ;;
          sd )
            initramfs_entry_add "kernel/drivers/mmc/host/sdhci.ko*" ;;
          virtio-blk )
            initramfs_entry_add "kernel/drivers/block/virtio_blk.ko*" ;;
          virtio-scsi )
            initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
            initramfs_entry_add "kernel/drivers/scsi/virtio_scsi.ko*"
            ;;
        esac
        if [ "${_list%,*}" = "$_list" ]; then
          # No more entries
          break
        else
          _list="${_list#$_list_item,}"
        fi
      done
    else
      error_message "Unable to determine storage driver to add to initramfs for booting!"
    fi
  elif [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ] && \
       is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" "$image_os_device_type"; then
    case $image_os_device_type in
      generic )
        # Check every storage device listed
        _list="$CADI_SUPPORTED_OS_DEVICE_TYPES"
        while true; do
          _list_item="$(first_entry_in_comma_list "$_list")"
          case $_list_item in
            hyperv )
              initramfs_entry_add "kernel/drivers/scsi/hv_storvsc.ko*" ;;
            nvme )
              initramfs_entry_add "kernel/drivers/nvme/host/nvme.ko*"
              if [ "$image_class" = "physical" ]; then
                initramfs_entry_add "kernel/drivers/pci/controller/vmd.ko*"
              fi
              ;;
            pvscsi )
              # VMware's VMDK file provides no way to indicate PVSCSI is used, can only
              # indicate "lsi_logic" and then later switch the VM to use PVSCSI.
              initramfs_entry_add "kernel/drivers/message/fusion/mptsas.ko*"
              initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
              ;;
            sata )
              initramfs_entry_add "kernel/drivers/ata/ahci.ko*"
              initramfs_entry_add "kernel/drivers/ata/ahci_platform.ko*"
              initramfs_entry_add "kernel/drivers/ata/libahci.ko*"
              initramfs_entry_add "kernel/drivers/ata/libahci_platform.ko*"
              initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
              ;;
            scsi )
              initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*" ;;
            sd )
              case $image_class in
                physical )
                  case $image_physical_type in
                    rpi* )
                      initramfs_entry_add "kernel/drivers/mmc/host/mmc_spi.ko*"
                      initramfs_entry_add "kernel/drivers/mmc/host/of_mmc_spi.ko*"
                      initramfs_entry_add "kernel/drivers/mmc/host/sdhci-iproc.ko*"
                      initramfs_entry_add "kernel/fs/fat"
                      initramfs_entry_add "kernel/fs/nls"
                      ;;
                    * )
                      initramfs_entry_add "kernel/drivers/mmc/host/sdhci.ko*" ;;
                  esac
                  ;;
              esac
              ;;
            usb )
              initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
              initramfs_entry_add "kernel/drivers/scsi/ses.ko*"
              initramfs_entry_add "kernel/drivers/usb/storage/uas.ko*"
              initramfs_entry_add "kernel/drivers/usb/storage/usb-storage.ko*"
              ;;
            virtio-blk )
              initramfs_entry_add "kernel/drivers/block/virtio_blk.ko*" ;;
            virtio-scsi )
              initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
              initramfs_entry_add "kernel/drivers/scsi/virtio_scsi.ko*"
              ;;
          esac
          if [ "${_list%,*}" = "$_list" ]; then
            # No more entries
            break
          else
            _list="${_list#$_list_item,}"
          fi
        done
        ;;

      hyperv )
        initramfs_entry_add "kernel/drivers/scsi/hv_storvsc.ko*" ;;

      nvme )
        initramfs_entry_add "kernel/drivers/nvme/host/nvme.ko*"
        if [ "$image_class" = "physical" ]; then
          initramfs_entry_add "kernel/drivers/pci/controller/vmd.ko*"
        fi
        ;;

      pvscsi )
        # VMware's VMDK file provides no way to indicate PVSCSI is used, can only
        # indicate "lsi_logic" and then later switch the VM to use PVSCSI.
        initramfs_entry_add "kernel/drivers/message/fusion/mptsas.ko*"
        initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
        ;;

      sata )
        initramfs_entry_add "kernel/drivers/ata/ahci.ko*"
        initramfs_entry_add "kernel/drivers/ata/ahci_platform.ko*"
        initramfs_entry_add "kernel/drivers/ata/libahci.ko*"
        initramfs_entry_add "kernel/drivers/ata/libahci_platform.ko*"
        initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
        ;;

      scsi )
        initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*" ;;

      sd )
        case $image_class in
          physical )
            case $image_physical_type in
              rpi* )
                initramfs_entry_add "kernel/drivers/mmc/host/mmc_spi.ko*"
                initramfs_entry_add "kernel/drivers/mmc/host/of_mmc_spi.ko*"
                initramfs_entry_add "kernel/drivers/mmc/host/sdhci-iproc.ko*"
                ;;
              * )
                initramfs_entry_add "kernel/drivers/mmc/host/sdhci.ko*" ;;
            esac
            ;;
          * )
            initramfs_entry_add "kernel/drivers/mmc/host/sdhci.ko*" ;;
        esac
        ;;

      usb )
        initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
        initramfs_entry_add "kernel/drivers/scsi/ses.ko*"
        initramfs_entry_add "kernel/drivers/usb/storage/uas.ko*"
        initramfs_entry_add "kernel/drivers/usb/storage/usb-storage.ko*"
        case $image_class in
          physical )
            case $image_physical_type in
              rpi* )
                initramfs_entry_add "kernel/fs/fat"
                initramfs_entry_add "kernel/fs/nls"
                ;;
            esac
            ;;
        esac
        ;;

      virtio-blk )
        initramfs_entry_add "kernel/drivers/block/virtio_blk.ko*" ;;

      virtio-scsi )
        initramfs_entry_add "kernel/drivers/scsi/sd_mod.ko*"
        initramfs_entry_add "kernel/drivers/scsi/virtio_scsi.ko*"
        ;;
    esac
  fi

  # Add additional required modules to initramfs
  if [ -n "$CADI_ADDITIONAL_INITRAMFS_MODULES" ]; then
    _list="$CADI_ADDITIONAL_INITRAMFS_MODULES"
    while true; do
      _list_item="$(first_entry_in_comma_list "$_list")"
      initramfs_entry_add "\\\$(find_module_full_path \"$_list_item\")"
      if [ "${_list%,*}" = "$_list" ]; then
        # No more entries
        break
      else
        _list="${_list#$_list_item,}"
      fi
    done
  fi

  initramfs_entry_finish

  if [ -n "$debug_enabled" ]; then
    cat <<-EOF >> "$run_script"
	
	    # Debug
	    {
	      write_debug_log "${image_class}-${image_class_subtype}.modules contents:" 2
	      cat /etc/mkinitfs/features.d/${image_class}-${image_class_subtype}.modules >> /chroot.log
	    }
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Given a network driver name will return the required path
# to it to be used in mkinitfs feature files.
#
convert_network_name_to_module_path() {
  _network_name="$1"

  local _network_module_path

  case $_network_name in
    alx )
      _network_module_path="kernel/drivers/net/ethernet/atheros/alx" ;;
    e1000 | e1000e | i40e | ice | igb | igbvf | igc | ixgb | ixgbe | ixgbevf )
      _network_module_path="kernel/drivers/net/ethernet/intel/${_network_name}" ;;
    ena )
      _network_module_path="kernel/drivers/net/ethernet/amazon/ena" ;;
    gve )
      _network_module_path="kernel/drivers/net/ethernet/google/gve" ;;
    hyperv )
      _network_module_path="kernel/drivers/net/hyperv/hv_netvsc.ko*" ;;
    intel )
      _network_module_path="kernel/drivers/net/ethernet/intel" ;;
    mana )
      _network_module_path="kernel/drivers/net/ethernet/microsoft/mana" ;;
    mellanox )
      _network_module_path="kernel/drivers/net/ethernet/mellanox" ;;
    mii )
      _network_module_path="kernel/drivers/net/mii.ko*" ;;
    mlx4_en )
      _network_module_path="kernel/drivers/net/ethernet/mellanox/mlx4" ;;
    mlx5_core )
      _network_module_path="kernel/drivers/net/ethernet/mellanox/mlx5" ;;
    nvidia )
      _network_module_path="kernel/drivers/net/ethernet/nvidia" ;;
    r8169 )
      _network_module_path="kernel/drivers/net/ethernet/realtek/r8169.ko*" ;;
    realtek )
      _network_module_path="kernel/drivers/net/ethernet/realtek" ;;
    tg3 )
      _network_module_path="kernel/drivers/net/ethernet/broadcom/tg3.ko*" ;;
    virtio-net )
      _network_module_path="kernel/drivers/net/virtio_net.ko*" ;;
    vmxnet3 )
      _network_module_path="kernel/drivers/net/vmxnet3" ;;
  esac

  echo "$_network_module_path"
}


#
# For the specified network drivers determine the module paths
# and add them to  mkinitfs feature file.
#
convert_network_names_to_initramfs_entries() {
  _network_module_names="$1"

  local _list _list_item

  if [ "$_network_module_names" = "generic" ]; then
    _list="$(all_entries_in_comma_list_except "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" "generic")"
  else
    _list="$_network_module_names"
  fi
  while true; do
    _list_item="$(first_entry_in_comma_list "$_list")"
    case $_list_item in
      generic )
        : ;;
      * )
        initramfs_entry_add "$(convert_network_name_to_module_path "${_list_item}")"
        case $_list_item in
          r8169 | realtek )
            initramfs_entry_add "kernel/drivers/net/phy/realtek.ko*" ;;
        esac
        ;;
    esac
    if [ "${_list%,*}" = "$_list" ]; then
      # No more entries
      break
    else
      _list="${_list#$_list_item,}"
    fi
  done

  case $image_class in
    physical )
      initramfs_entry_add "$(convert_network_name_to_module_path "mii")" ;;
  esac
}


#
# Given a graphics driver name will return the required path
# to it to be used in mkinitfs feature files.
#
get_graphics_driver_initfs_path() {
  _gfx_driver="$1"

  local _gfx_path

  case $_gfx_driver in
    amd )
      case $image_alpine_release in
        v3.13 | v3.14 )
          _gfx_path="kernel/drivers/video/fbdev/aty" ;;
        * )
          _gfx_path="kernel/drivers/gpu/drm/amd" ;;
      esac
      ;;

    bochs )
      case $image_alpine_release in
        v3.13 | v3.14 )
          _gfx_path="kernel/drivers/gpu/drm/bochs/bochs-drm.ko*" ;;
        * )
          _gfx_path="kernel/drivers/gpu/drm/tiny/bochs.ko*" ;;
      esac
      ;;

    hyperv )
      case $image_alpine_release in
        v3.13 | v3.14 )
          _gfx_path="kernel/drivers/video/fbdev/hyperv_fb.ko*" ;;
        * )
          _gfx_path="kernel/drivers/gpu/drm/hyperv/hyperv_drm.ko*" ;;
      esac
      ;;

    i915 )
      case $image_alpine_release in
        v3.13 | v3.14 )
          _gfx_path="kernel/drivers/video/fbdev/intelfb*" ;;
        * )
          _gfx_path="kernel/drivers/gpu/drm/i915" ;;
      esac
      ;;

    nouveau )
      case $image_alpine_release in
        v3.13 | v3.14 )
          _gfx_path="kernel/drivers/video/fbdev/nvidia" ;;
        * )
          _gfx_path="kernel/drivers/gpu/drm/nouveau" ;;
      esac
      ;;

    qxl )
      _path="kernel/drivers/gpu/drm/qxl/qxl.ko*" ;;

    radeon )
      case $image_alpine_release in
        v3.13 | v3.14 )
          _gfx_path="kernel/drivers/video/fbdev/aty/radeonfb.ko*" ;;
        * )
          _gfx_path="kernel/drivers/gpu/drm/radeon" ;;
      esac
      ;;

    simpledrm )
      _gfx_path="kernel/drivers/gpu/drm/tiny/simpledrm.ko*" ;;

    virtio-gpu )
      _gfx_path="kernel/drivers/gpu/drm/virtio" ;;

    vmwgfx )
      _gfx_path="kernel/drivers/gpu/drm/vmwgfx" ;;
  esac

  echo "$_gfx_path"
}
