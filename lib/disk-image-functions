#!/bin/sh
# shellcheck disable=SC1117,SC2039

#############################################################################
##
##  disk-image-functions
##
##  Copyright 2021-2023 Dermot Bradley <dermot_bradley@yahoo.com>
##
##  Licensed via GPL version 2.0
##
#############################################################################


#
# Additional OS configuration
#
additional_os_configuration() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Doing additional OS configuration"
	{
	EOF

  if [ -z "$image_barebones" ]; then
    case $image_alpine_release in
      v3.13 | v3.14 | v3.15 | v3.16 | v3.17 )
        cat <<-'EOF' >> "$run_script"
	  # FIXUP: stop update-ca-certificates displaying a warning
	  sed -i \
	    -e 's|/etc/ssl/certs|/etc/ssl/certs 2>/dev/null|' \
	    /etc/ca-certificates/update.d/certhash
	
	EOF
        ;;
      * )
        # Fix not required in recent Alpine releases
        : ;;
    esac
  fi

  case $image_auth_control in
    doas | both )
      cat <<-'EOF' >> "$run_script"
	  write_log "Configure doas"
	  {
	EOF

      if [ -n "$debug_enabled" ]; then
        cat <<-'EOF' >> "$run_script"
	    # Debug
	    {
	      cp /etc/doas.conf /etc/doas.conf-orig
	    }
	
	EOF
      fi

      cat <<-'EOF' >> "$run_script"
    write_log "Adding doas configuration for root user" 2
    cat <<-_SCRIPT_ >> /etc/doas.conf
	
	# Allow root to run doas (i.e. "doas -u <user> <command>")
	permit nopass root
	_SCRIPT_
    
    write_log "Enabling doas configuration for wheel group" 2
    sed -i -E -e 's/^[#][ ]*(permit persist :wheel)$/\1/g' /etc/doas.conf
EOF

      if [ -n "$debug_enabled" ]; then
        cat <<-'EOF' >> "$run_script"
	    
	    # Debug
	    {
	      diff /etc/doas.conf-orig /etc/doas.conf >> /chroot.log || true
	      rm /etc/doas.conf-orig
	    }
	EOF
      fi

      cat <<-'EOF' >> "$run_script"
	  }
	EOF
      ;;
  esac

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Append specific cmdline settings
#
add_cmdline_settings() {
  local _cmdline_additions

  case $image_acpi_power_method in
    tiny-power-button )
      # Using tiny-power-button but Busybox init doesn't handle the usual
      # signal this sends, so specify USR2 which Busybox accepts for
      # "poweroff" situations.
      _cmdline_additions="tiny_power_button.power_signal=12" ;;
  esac

  case $image_class in
    physical )
      : ;;
    * )
      # For non-physical machines always ensure that the console output is visible
      _cmdline_additions="$_cmdline_additions consoleblank=0" ;;
  esac

  if [ -n "$CADI_DEFAULT_CLOCKSOURCE" ]; then
    if [ -n "$CADI_SUPPORTED_CLOCKSOURCES" ] && \
       is_in_comma_list "$CADI_DEFAULT_CLOCKSOURCE" "$CADI_SUPPORTED_CLOCKSOURCES"; then
      case $CADI_DEFAULT_CLOCKSOURCE in
        hyperv )
          _cmdline_additions="$_cmdline_additions clocksource=hyperv_clocksource_tsc_page" ;;
        kvm )
          _cmdline_additions="$_cmdline_additions clocksource=kvm-clock" ;;
      esac
    fi
  fi

  if [ -z "$debug_enabled" ]; then
    if [ -z "$CADI_CMDLINE_QUIET" ] || [ "$CADI_CMDLINE_QUIET" = "true" ]; then
      _cmdline_additions="$_cmdline_additions quiet"
    fi
  fi

  if [ -n "$_cmdline_additions" ]; then
    echo " $_cmdline_additions"
  fi
}


#
# Basic OS configuration
#
basic_os_configuration() {
  local _color_prompt_file _login_banner

  cat <<-'EOF' >> "$run_script"
	
	write_log "Doing basic OS configuration"
	{
	  write_log "Setting the login and MOTD messages" 2
	  {
	    printf '\nWelcome\n\n' > /etc/issue
	EOF

  case $image_class in
    cloud )
      _login_banner="Alpine $image_arch $image_cloud_type Cloud server"
      ;;
    physical )
      case $image_physical_type in
        arm-server )
          _login_banner="Alpine ARM server" ;;
        pc )
          _login_banner="Alpine $image_arch PC server" ;;
        rpi* )
          _login_banner="Alpine $image_arch Raspberry Pi server" ;;
      esac
      ;;
    virtual )
      _login_banner="Alpine $image_arch $image_vm_type VM server"
      ;;
  esac

  cat <<-EOF >> "$run_script"
	    printf '\n\n%s\n\n' "$_login_banner" > /etc/motd
	  }
	EOF

  cat <<-'EOF' >> "$run_script"
	
	  write_log "Setting the keymap to '\$keymap'" 2
	  setup-keymap \$keymap >> "/chroot.log" 2>&1
	EOF

  # https://gitlab.alpinelinux.org/alpine/aports/-/merge_requests/46718
  case $image_alpine_release in
    v3.13 | v3.14 | v3.15 | v3.16 | v3.17 )
      _locale_file="locale.sh" ;;
    v3.18 )
      _locale_file="20locale.sh" ;;
    * )
      _locale_file="50-cloud-init-locale.sh" ;;
  esac
  cat <<-EOF >> "$run_script"
	
	  locale_file="$_locale_file"
	
	  if [ -e "\\\$locale_file" ]; then
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	    # Debug
	    {
	      cp /etc/profile.d/\${locale_file} /etc/profile.d/\${locale_file}-orig
	    }
	
	EOF
  fi

  cat <<-EOF >> "$run_script"
	    write_log "Setting locale to \\\$locale" 2
	    sed -i -E -e "s/^(export LANG=)C.UTF-8/\1\\\$locale/" \\
	      /etc/profile.d/\\\${locale_file}
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      diff /etc/profile.d/\${locale_file}-orig /etc/profile.d/\${locale_file} \\
	        >> /chroot.log || true
	      rm /etc/profile.d/\${locale_file}-orig
	    }
	EOF
  fi

  cat <<-EOF >> "$run_script"
	  else
	    write_log "Creating profile file to set locale to \\\$locale" 2
	    {
	      echo "# Created by create-alpine-disk-image"
	      echo "#"
	      echo "export LANG=\\\$locale"
	    } > /etc/profile.d/\\\${locale_file}
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    {
	      cat /etc/profile.d/\${locale_file} >> /chroot.log || true
	    }
	EOF
  fi

  cat <<-EOF >> "$run_script"
	  fi
	EOF


  if [ -n "$debug_enabled" ]; then
      cat <<-EOF >> "$run_script"
	
	  # Debug
	  {
	    cp /etc/rc.conf /etc/rc.conf-orig
	  }
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	
	  write_log "Set OpenRC to log init.d start/stop sequences" 2
	  sed -i -e 's|[#]rc_logger=.*|rc_logger="YES"|g' /etc/rc.conf
	
	  write_log "Configure /etc/init.d/bootmisc to keep previous copy of dmesg logfile" 2
	  sed -i -e 's|[#]previous_dmesg=.*|previous_dmesg=yes|g' /etc/conf.d/bootmisc
	EOF

  case $image_alpine_release in
    v3.13 | v3.14 | v3.15 )
      cat <<-'EOF' >> "$run_script"
	
	  write_log "Create dummy dmesg logfile to workaround openrc bug" 2
	  touch /var/log/dmesg
	EOF
      ;;
  esac

  case $image_alpine_release in
    v3.13 | v3.14 | v3.15 | v3.16 | v3.17 )
      cat <<-'EOF' >> "$run_script"
	
	  write_log "Fixup rc.conf so that keyboards and screens use Unicode" 2
	  sed -i -e 's/^#unicode="NO"/unicode="YES"/' /etc/rc.conf
	EOF
      ;;
    * )
      # Unicode is default from Edge/v3.18 onwards
      : ;;
  esac

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    diff /etc/rc.conf-orig /etc/rc.conf >> /chroot.log || true
	    rm /etc/rc.conf-orig
	  }
	EOF
  fi

  case $image_alpine_release in
    v3.13 )
      _color_prompt_file="color_prompt" ;;
    * )
      _color_prompt_file="color_prompt.sh.disabled" ;;
  esac

  cat <<-EOF >> "$run_script"
	
	  write_log "Enable colour shell prompt" 2
	  cp /etc/profile.d/${_color_prompt_file} /etc/profile.d/color_prompt.sh
	
	EOF

  if [ "$image_tmp_on_tmpfs" != "true" ]; then
    case $image_alpine_release in
      v3.13 | v3.14 | v3.15 )
        : ;;
      * )
        # From Alpine 3.16 onwards /tmp is not automatically wiped at boot
        cat <<-'EOF' >> "$run_script"
	  write_log "Ensuring /tmp is wiped at boot" 2
	  sed -i -e 's/^wipe_tmp=.*/wipe_tmp="YES"/g' /etc/conf.d/bootmisc
	
	EOF
      ;;
    esac
  fi

  # Enable mdevd or eudev where appropriate
  case $image_alpine_release in
    v3.13 | v3.14 | v3.15 | v3.16 )
      case $image_cloud_software in
        cloud-init )
          # Nothing to do, setup-cloud-init will enable udev
          : ;;
        none )
          case $image_device_management_type in
            mdev )
              # Nothing to do, already enabled
              : ;;
            udev )
              cat <<-EOF >> "$run_script"	
	  write_log "Enable udev init.d services" 2
	  {
	    setup-udev  >> /chroot.log 2>&1 || true
	  }
	EOF
              ;;
          esac
          ;;
        tiny-cloud )
          # tiny-cloud takes care of this itself
          : ;;
      esac
      ;;
    * )
      case $image_cloud_software in
        cloud-init | none )
          cat <<-EOF >> "$run_script"
	  write_log "Enable $image_device_management_type init.d services" 2
	  {
	    setup-devd $image_device_management_type >> /chroot.log 2>&1 || true
	  }
	EOF
          ;;
        tiny-cloud )
          # tiny-cloud takes care of this itself
          : ;;
      esac
      ;;
  esac

  if [ "$image_class" != "virtual" ] || [ "$image_vm_type" != "vmware" ]; then
    cat <<-EOF >> "$run_script"
	
	  rmdir /media/floppy
	EOF
  fi

  cat <<-EOF >> "$run_script"
	}
	EOF
}


#
# Calculate size of the resultant disk image taking into account
# whether bootloader/ESP, boot and cloud-init partitions are needed.
#
calculate_image_size() {
  local _boot_part_size _image_total_size _reserved_disk_size _swap_part_size

  if [ -n "$debug_sizing_enabled" ]; then
    echo "[calculate_image_size] determining image size" >> "$sizing_debug"
  fi

  if [ "$image_encryption_type" = "both" ] || [ "$image_encryption_type" = "luks" ]; then
    # LUKS (including LVM-inside-LUKS)

    if [ -n "$debug_sizing_enabled" ]; then
      echo "[calculate_image_size] image contains LUKS partition, determining LUKS partition size" >> "$sizing_debug"
    fi

    _image_total_size=$(( $(calculate_luks_part_size) ))

    if [ -n "$debug_sizing_enabled" ]; then
      echo "[calculate_image_size] size for LUKS partition is $_image_total_size MiB" >> "$sizing_debug"
    fi
  elif [ -n "$image_lvm_rootfs" ]; then
    # LVM

    if [ -n "$debug_sizing_enabled" ]; then
      echo "[calculate_image_size] image contains LVM partition, determining LVM partition size" >> "$sizing_debug"
    fi

    _image_total_size=$(( $(calculate_lvm_part_size) ))

    if [ -n "$debug_sizing_enabled" ]; then
      echo "[calculate_image_size] size for LVM partition is $_image_total_size MiB" >> "$sizing_debug"

    fi
  else
    # Neither LUKS nor LVM

    if [ -n "$debug_sizing_enabled" ]; then
      echo "[calculate_image_size] determining rootfs partition size" >> "$sizing_debug"
    fi

    _image_total_size=$(calculate_root_part_size)

    if [ -n "$debug_sizing_enabled" ]; then
      echo "[calculate_image_size] size for root partition is $_image_total_size MiB" >> "$sizing_debug"
    fi
  fi


  if [ "$image_class" = "physical" ] && \
     [ "$image_cloud_software" = "cloud-init" ]; then
    if [ -n "$debug_sizing_enabled" ]; then
      echo "[calculate_image_size] image also contains CIDATA partition" >> "$sizing_debug"
    fi

    _image_total_size="$(( _image_total_size + CADI_CIDATA_PART_SIZE ))"

    if [ -n "$debug_sizing_enabled" ]; then
      echo "[calculate_image_size] adding on $CADI_CIDATA_PART_SIZE MiB CIDATA partition, giving $_image_total_size MiB" >> "$sizing_debug"
    fi
  fi

  case $image_swap_boot_partition in
    true )
      # Swap partition to account for
      if [ -n "$debug_sizing_enabled" ]; then
        echo "[calculate_image_size] image also contains swap partition" >> "$sizing_debug"
      fi

      _swap_part_size=$(calculate_swap_part_size)
      _image_total_size="$(( _image_total_size + _swap_part_size ))"

      if [ -n "$debug_sizing_enabled" ]; then
        echo "[calculate_image_size] adding on $_swap_part_size MiB Swap partition, giving $_image_total_size MiB" >> "$sizing_debug"
      fi
      ;;
  esac

  case $image_create_boot_partition in
    true )
      # Separate boot partition to account for
      if [ -n "$debug_sizing_enabled" ]; then
        echo "[calculate_image_size] image also contains boot partition" >> "$sizing_debug"
      fi

      _boot_part_size=$(calculate_boot_part_size)
      _image_total_size="$(( _image_total_size + _boot_part_size ))"

      if [ -n "$debug_sizing_enabled" ]; then
        echo "[calculate_image_size] adding on $_boot_part_size MiB Boot partition, giving $_image_total_size MiB" >> "$sizing_debug"
      fi
      ;;
  esac

  case $image_boot_type in
    bios )
      # Account for 1MiB boot sector
      _reserved_disk_size=1

      _image_total_size="$(( _image_total_size + _reserved_disk_size ))"
      if [ -n "$debug_sizing_enabled" ]; then
        echo "[calculate_image_size] adding on ${_reserved_disk_size}MiB for boot sector, giving $_image_total_size MiB" >> "$sizing_debug"
      fi
      ;;
    rpi )
      # Account for 1MiB boot sector
      _reserved_disk_size=1

      _image_total_size="$(( _image_total_size + _reserved_disk_size ))"
      if [ -n "$debug_sizing_enabled" ]; then
        echo "[calculate_image_size] adding on ${_reserved_disk_size}MiB for boot sector, giving $_image_total_size MiB" >> "$sizing_debug"
      fi
      ;;
    secure-uefi | uefi )
      # Account for GPT reserved space at start of device
      case $image_os_device_sector_size in
        512 )
          # with GPT 34 512-byte sectors are reserved (so 17K)
          _reserved_disk_size=1 ;;
        4096 )
          # with GPT 6 4K sectors are reserved (so 24K)
          _reserved_disk_size=1 ;;
      esac

      # Account for ESP partition
      if [ -n "$debug_sizing_enabled" ]; then
        echo "[calculate_image_size] image also contains ESP partition" >> "$sizing_debug"
      fi

      _image_total_size="$(( _image_total_size + _reserved_disk_size + $(calculate_uefi_part_size) ))"

      if [ -n "$debug_sizing_enabled" ]; then
        echo "[calculate_image_size] adding on ${_reserved_disk_size}MiB GPT overhead and $(calculate_uefi_part_size)MiB ESP partition, giving $_image_total_size MiB" >> "$sizing_debug"
      fi
      ;;
    unpartitioned )
      if [ -n "$debug_sizing_enabled" ]; then
        echo "[calculate_image_size] size unchanged for unpartitioned disk, giving $_image_total_size MiB" >> "$sizing_debug"
      fi
      ;;
  esac

  if [ -n "$debug_sizing_enabled" ]; then
    echo "[calculate_image_size] total image size of $_image_total_size MiB" >> "$sizing_debug"
  fi

  echo "$_image_total_size"
}


#
# Configure whatever software is used to manage auto-configuration
#
configure_autoconfiguration_software() {
  case $image_cloud_software in
    cloud-init )
      configure_cloud_init ;;
    none )
      configure_non_autoconfiguration ;;
    tiny-cloud )
      configure_tiny_cloud ;;
  esac
}


#
# Define the base options for the cmdline list used by the bootloader
#
configure_base_cmdline_values() {
  # Increase the kernel message buffer so all messages during boot are retained
  base_cmdline="log_buf_len=32768 rootfstype=$image_fs_type"

  case $image_fs_type in
    btrfs | ext4 )
      case $image_os_device_media in
        flash | sdcard | ssd )
          case $image_alpine_release in
            v3.13 | v3.14 | v3.15 | v3.16 )
              # For older Alpine releases add commit mount option for rootfs
              # when on flash device as this is *not* read from /etc/fstab by
              # initramfs' init when it mounts rootfs and later during boot
              # the /etc/init.d/root script does not use options from
              # /etc/fstab when remounting rootfs.
              base_cmdline="$base_cmdline rootflags=commit=300" ;;
            * )
              : ;;
          esac
          ;;
      esac
      ;;
  esac

  case $image_console_type in
    hypervisor )
      # Do not add a "console=" entry for the virtio console device
      : ;;
    normal )
      base_cmdline="$base_cmdline console=$image_console_name" ;;
    normal_and_serial )
      base_cmdline="$base_cmdline console=${image_serial_console_name},${image_serial_console_port_speed} console=$image_console_name" ;;
    serial )
      base_cmdline="$base_cmdline console=${image_serial_console_name},${image_serial_console_port_speed}" ;;
  esac

  # IPv6
  if [ -n "$image_disable_ipv6" ]; then
    base_cmdline="$base_cmdline ipv6.disable=1"
  fi

  # Bootchart
  if [ -n "$image_bootchart" ]; then
    base_cmdline="$base_cmdline chart rootflags=rw"
  fi

  # ZSWAP
  if [ -n "$image_disable_zswap" ]; then
    base_cmdline="$base_cmdline zswap.enabled=1"
  fi

  # LUKS
  case $image_encryption_type in
    both | luks )
      base_cmdline="$base_cmdline \\\$(define_cmdline_for_luks_encryption)" ;;
  esac

  base_cmdline="${base_cmdline}$(add_cmdline_settings)"

  case $image_console_type in
    hypervisor | none | serial )
      case $image_boot_type in
        bios )
          base_cmdline="$base_cmdline nomodeset" ;;
        esac
        ;;
    * )
      if [ "$image_console_output_type" = "text" ]; then
        case $image_boot_type in
          bios )
            base_cmdline="$base_cmdline nomodeset"

            if [ -n "$image_graphics_vendor" ]; then
              case $image_graphics_vendor in
                intel )
                  base_cmdline="$base_cmdline i915.modeset=0" ;;
                nvidia )
                  base_cmdline="$base_cmdline nouveau.modeset=0" ;;
              esac
            else
              base_cmdline="$base_cmdline i915.modeset=0 nouveau.modeset=0"
            fi
            ;;
        esac
      fi
      ;;
  esac

  if [ -n "$image_extra_cmdline_options" ]; then
    # Add any additionally specified cmdline options
    base_cmdline="$base_cmdline $image_extra_cmdline_options"
  fi
}


#
# Configure whichever tool is used to create/manage initramfs
#
configure_initramfs_tool() {
  case $image_initramfs_tool in
    booster )
      configure_booster ;;
    dracut )
      configure_dracut ;;
    mkinitfs )
      configure_mkinitfs ;;
  esac
}


#
# Convert RAW disk image to another format
#
convert_raw_disk_image() {
  local _compression_tool _convert_cli _new_format _new_format_options

  if [ -n "$CADI_DISK_IMAGE_FORMAT" ]; then
    case $CADI_DISK_IMAGE_FORMAT in
      qcow2 | vdi | vmdk )
        _new_format="$CADI_DISK_IMAGE_FORMAT"
        if [ -n "$CADI_DISK_IMAGE_FORMAT_OPTIONS" ]; then
          _new_format_options="$CADI_DISK_IMAGE_FORMAT_OPTIONS"
        fi
    esac

    if [ -n "$_new_format" ]; then
      _convert_cli="-f raw -O $_new_format"
      if [ -n "$_new_format_options" ]; then
        _convert_cli="$_convert_cli $_new_format_options"
      fi

      cat <<-EOF >> "$run_script"
	
	write_log "Converting image from RAW format to ${_new_format} format"
	new_filename="\$(basename -s img \$image_filename)$_new_format"
	qemu-img convert $_convert_cli \$images_dir/\$image_filename \\
	  \$images_dir/"\$new_filename" >> "\$logfile"
	rm \$images_dir/\$image_filename
	EOF

      if [ -n "$CADI_DISK_IMAGE_COMPRESSION" ]; then
        _compression_tool="$CADI_DISK_IMAGE_COMPRESSION"

        cat <<-EOF >> "$run_script"
	
	write_log "Compressing image using ${_compression_tool}"
	compression_tool="$_compression_tool"
	\$compression_tool \$images_dir/"\$new_filename" \\
	  >> "\$logfile"
	EOF
      fi
    fi
  fi
}


#
# Basic settings and checks
#
basic_settings() {
  # Chroot directory
  : "${chroot_directory:=$CADI_DEFAULT_CHROOT_DIRECTORY}"

  # Images directory
  : "${images_directory:=$CADI_DEFAULT_IMAGES_DIRECTORY}"

  # Whether to use ramdisk
  if [ -n "$use_ramdisk" ] && [ -z "$ramdisk_directory" ]; then
    # If ramdisk directory not specified then assume default
    ramdisk_directory=$CADI_DEFAULT_RAMDISK_DIRECTORY
  fi

  # Alpine repo mirror site
  : "${alpine_mirror_site:=$CADI_DEFAULT_MIRROR_SITE}"

  # Override default root partition size
  if [ -n "$override_rootfs_size" ]; then
    general_rootfs_size=$override_rootfs_size
  fi


  # Alpine Release
  : "${image_alpine_release:=$CADI_DEFAULT_ALPINE_RELEASE}"

  # Machine type defaults to QEMU VM
  if [ -z "$image_class" ]; then
    image_class="virtual"
    image_vm_type="qemu"
  fi

  # Kernel type
  : "${image_kernel_type:=normal}"

  # Whether /tmp is on disk or tmpfs
  : "${image_tmp_on_tmpfs:=true}"
}


#
# Perform some initial validation checks
#
do_generic_validation_checks() {
  # Kernel type
  case $image_kernel_type in
    edge )
      case $image_alpine_release in
        v3.13 | v3.14 )
          error_message "There is no edge kernel package for Alpine $image_alpine_release!" ;;
        v3.15 )
          # Both linux-edge and linux-edge4virt packages exist
          : ;;
        * )
          # linux-edge4virt package no longer exists so linux-edge will be used instead
          : ;;
      esac
      ;;
  esac

  if [ -n "$image_ntp_servers" ] && [ "$image_class" != "physical" ]; then
    error_message "NTP servers can only be specified for physical servers, other machine type obtain this information either from defaults for their hypervisor/cloud provider or from user-data!"
  fi

  # UTMP
  if [ -n "$image_enable_utmp" ] && [ "$image_enable_utmp" = "true" ]; then
    case $image_alpine_release in
      v3.13 | v3.14 | v3.15 )
        error_message "UTMP does not function in this Alpine release!" ;;
    esac
  fi

  if [ -n "$image_disable_cloud_provider_cli" ] && [ "$image_class" != "cloud" ]; then
    error_message "The 'disable-cloud-provider-cli' option only applies for cloud disk images!"
  fi
}


#
# After type of cloud/VM/physical machine settings have been determined
# perform further validation checks.
#
do_specific_validation_checks() {
  # Default assumption is to use cloud-init for configuration
  if [ -n "$image_barebones" ] && \
     is_in_comma_list "none" "$CADI_SUPPORTED_CONFIGURATION_TOOLS"; then
    image_cloud_software="none"
  elif [ -n "$image_barebones" ]; then
    error_message "Unable to use barebones with '$class_type_description'!"
  elif [ -z "$image_cloud_software" ]; then
    if [ -n "$CADI_DEFAULT_CONFIGURATION_TOOL" ] && \
       is_in_comma_list "$CADI_DEFAULT_CONFIGURATION_TOOL" "$CADI_SUPPORTED_CONFIGURATION_TOOLS"; then
      image_cloud_software="$CADI_DEFAULT_CONFIGURATION_TOOL"
    elif [ -n "$CADI_SUPPORTED_CONFIGURATION_TOOLS" ] && \
         is_in_comma_list "cloud-init" "$CADI_SUPPORTED_CONFIGURATION_TOOLS"; then
      image_cloud_software="cloud-init"
    elif [ -n "$CADI_SUPPORTED_CONFIGURATION_TOOLS" ] && \
         is_in_comma_list "tiny-cloud" "$CADI_SUPPORTED_CONFIGURATION_TOOLS"; then
      image_cloud_software="tiny-cloud"
    else
      image_cloud_software="none"
    fi
  else
    # Check that the specified configuration software is supported by
    # the particular cloud/hypervisor/machine.
    if [ -n "$CADI_SUPPORTED_CONFIGURATION_TOOLS" ] && \
         is_in_comma_list "$image_cloud_software" "$CADI_SUPPORTED_CONFIGURATION_TOOLS"; then
      # selected configuration software is supported
      :
    else
      error_message "configuration software '$image_cloud_software' is not supported for $class_type_description!"
    fi
  fi

  # Cloud-init
  if [ "$image_cloud_software" = "cloud-init" ]; then
    if [ -n "$CADI_SUPPORTED_CLOUD_INIT_DATASOURCES" ]; then
      image_cloud_init_datasources="$CADI_SUPPORTED_CLOUD_INIT_DATASOURCES"
    fi

    if [ -n "$image_cloud_init_seed_define" ]; then
      case $image_cloud_init_seed_define in
        cmdline | config )
          if [ -z "$image_cloud_init_seed_url" ]; then
            error_message "'--cloud-init-seed-url' also needs to be specified!"
          fi
          ;;
        dhcp | none )
          : ;;
      esac
    elif [ -n "$image_cloud_init_seed_url" ]; then
      error_message "When defining a cloud-init seed URL you also need to specify '--cloud-init-seed-define' accordingly!"
    fi
  else
    # Not cloud-init
    if [ -n "$image_cloud_init_seed_define" ]; then
      error_message "'--cloud-init-seed-define' only applies when cloud-init is being used!"
    elif [ -n "$image_cloud_init_seed_url" ]; then
      error_message "'--cloud-init-seed-url' only applies when cloud-init is being used!"
    else
      image_cloud_init_seed_define="none"
    fi
  fi

  # Barebones
  if [ -n "$image_barebones" ]; then
    if [ -n "$image_cloud_software" ] && [ "$image_cloud_software" != "none" ]; then
      error_message "'--barebones' implies '--no-cloud-configuration'!"
    fi
    if [ -n "$image_device_management" ] && [ "$image_device_management" != "mdev" ]; then
      error_message "'--barebones' implies '--device-management mdev'!"
    fi
    if [ -n "$image_optimise" ] && [ "$image_optimise" != "true" ]; then
      error_message "'--barebones' implies '--optimise'!"
    fi
    if [ -n "$image_enable_utmp" ] && [ "$image_enable_utmp" = "true" ]; then
      error_message "'--barebones' implies no UTMP!"
    fi
  fi

  # NTP
  if [ -n "$image_ntp_use" ]; then
    case $image_ntp_use in
      ptp )
        if [ "$image_class" = "physical" ] && [ "$image_ntp_use" = "ptp" ]; then
          error_message "PTP host sync can not be specified for physical servers!"
        fi
        if [ "$image_cloud_software" = "cloud-init" ]; then
          case $image_alpine_release in
            v3.13 | v3.14 | v3.15 | v3.16 | v3.17 | v3.18 | edge )
              error_message "PTP host clock sync support is not present in this Alpine release." ;;
            edge-special )
              : ;;
          esac
        fi
        ;;
    esac
  fi
}


#
# Boot type/Partitioning type/Bootloader/etc settings
#
default_boot_related_settings() {
  # Boot type: BIOS / Hybrid / RPI / Secure UEFI / UEFI etc
  if [ -z "$image_boot_type" ]; then
    # If boot type has not been explicitly specified then use default for
    # the particular arch and cloud/physical/virtual type
    if [ -n "$CADI_DEFAULT_BOOT_TYPE" ]; then
      image_boot_type="$CADI_DEFAULT_BOOT_TYPE"
    elif is_in_comma_list "hybrid" "$CADI_SUPPORTED_BOOT_TYPES"; then
      image_boot_type="hybrid"
    elif is_in_comma_list "bios" "$CADI_SUPPORTED_BOOT_TYPES"; then
      image_boot_type="bios"
    elif is_in_comma_list "uefi" "$CADI_SUPPORTED_BOOT_TYPES"; then
      image_boot_type="uefi"
    elif is_in_comma_list "rpi" "$CADI_SUPPORTED_BOOT_TYPES"; then
      image_boot_type="rpi"
    else
      error_message "Unable to determine boot type to use!"
    fi
  else
    if is_in_comma_list "$image_boot_type" "$CADI_SUPPORTED_BOOT_TYPES"; then
      # Specified boot_type is supported by particular arch and
      # cloud/physical/virtual type
      :
    else
      error_message "Boot type '$image_boot_type' is not supported by $class_type_description!"
    fi
  fi

  # Boot partitioning type: GPT / Hybrid / MBR / Unpartitioned
  if [ -z "$image_os_partitioning_type" ]; then
    # If partitioning type has not been explicitly specified then use default
    # for the particular boot type
    case $image_boot_type in
      bios )
        if [ -n "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" ] && \
           { [ "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" = "unpartitioned" ] || \
             [ "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" = "mbr" ]; }; then
          image_os_partitioning_type="$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE"
        elif is_in_comma_list "mbr" "$CADI_SUPPORTED_DISK_IMAGE_PARTITIONING_TYPES"; then
          image_os_partitioning_type="mbr"
        elif is_in_comma_list "unpartitioned" "$CADI_SUPPORTED_DISK_IMAGE_PARTITIONING_TYPES"; then
          image_os_partitioning_type="unpartitioned"
        else
          error_message "No supported partitioning type for $image_boot_type booting!"
        fi
        ;;
      hybrid )
        if [ -n "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" ] && \
           { [ "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" = "gpt" ] || \
             [ "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" = "mbr" ]; }; then
          image_os_partitioning_type="hybrid"
        elif is_in_comma_list "gpt" "$CADI_SUPPORTED_DISK_IMAGE_PARTITIONING_TYPES" || \
             is_in_comma_list "mbr" "$CADI_SUPPORTED_DISK_IMAGE_PARTITIONING_TYPES"; then
          image_os_partitioning_type="hybrid"
        else
          error_message "No supported partitioning type for $image_boot_type booting!"
        fi
        ;;
      secure-uefi | uefi )
        if [ -n "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" ] && \
           [ "$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE" = "gpt" ]; then
          image_os_partitioning_type="$CADI_DEFAULT_DISK_IMAGE_PARTITIONING_TYPE"
        elif is_in_comma_list "gpt" "$CADI_SUPPORTED_DISK_IMAGE_PARTITIONING_TYPES"; then
          image_os_partitioning_type="gpt"
        else
          error_message "No supported partitioning type for $image_boot_type booting!"
        fi
        ;;
    esac
  elif [ -n "$image_os_partitioning_type" ]; then
    if is_in_comma_list "$image_os_partitioning_type" "$CADI_SUPPORTED_BOOT_TYPES"; then
      # Specified partitioning type is supported by particular boot type
      :
    else
      error_message "Partitioning type '$image_boot_type' is not supported for $image_boot_type booting!"
    fi
  else
    error_message "Invalid partitioning type specified!"
  fi

  # Bootloader: Grub / Limine / RPI / Syslinux / UKI etc
  if [ -z "$image_bootloader" ]; then
    # If bootloader has not been explicitly specified then use default for
    # the particular arch and cloud/physical/virtual type
    if [ -n "$CADI_DEFAULT_BOOTLOADER" ]; then
      case $image_boot_type in
        bios )
          if is_in_comma_list "$CADI_DEFAULT_BOOTLOADER" "$CADI_SUPPORTED_BOOTLOADERS_BIOS"; then
            image_bootloader="$CADI_DEFAULT_BOOTLOADER"
          elif is_in_comma_list "grub" "$CADI_SUPPORTED_BOOTLOADERS_BIOS"; then
            image_bootloader="grub"
          elif is_in_comma_list "syslinux" "$CADI_SUPPORTED_BOOTLOADERS_BIOS"; then
            image_bootloader="syslinux"
          elif is_in_comma_list "limine" "$CADI_SUPPORTED_BOOTLOADERS_BIOS"; then
            image_bootloader="limine"
          else
            error_message "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        hybrid )
          if is_in_comma_list "$CADI_DEFAULT_BOOTLOADER" "$CADI_SUPPORTED_BOOTLOADERS_HYBRID"; then
            image_bootloader="$CADI_DEFAULT_BOOTLOADER"
          elif is_in_comma_list "grub" "$CADI_SUPPORTED_BOOTLOADERS_HYBRID"; then
            image_bootloader="grub"
          elif is_in_comma_list "limine" "$CADI_SUPPORTED_BOOTLOADERS_HYBRID"; then
            image_bootloader="limine"
          else
            error_message "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        rpi )
          if is_in_comma_list "$CADI_DEFAULT_BOOTLOADER" "$CADI_SUPPORTED_BOOTLOADERS_RPI"; then
            image_bootloader="$CADI_DEFAULT_BOOTLOADER"
          elif is_in_comma_list "rpi" "$CADI_SUPPORTED_BOOTLOADERS_RPI"; then
            image_bootloader="rpi"
          else
            error_message "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        secure-uefi )
          if is_in_comma_list "$CADI_DEFAULT_BOOTLOADER" "$CADI_SUPPORTED_BOOTLOADERS_UEFI"; then
            image_bootloader="$CADI_DEFAULT_BOOTLOADER"
          elif is_in_comma_list "grub" "$CADI_SUPPORTED_BOOTLOADERS_UEFI"; then
            image_bootloader="grub"
          else
            error_message "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        uefi )
          if is_in_comma_list "$CADI_DEFAULT_BOOTLOADER" "$CADI_SUPPORTED_BOOTLOADERS_UEFI"; then
            image_bootloader="$CADI_DEFAULT_BOOTLOADER"
          elif is_in_comma_list "uki" "$CADI_SUPPORTED_BOOTLOADERS_UEFI" && \
               [ -n "$image_experimental" ]; then
            image_bootloader="uki"
            if [ -n "$image_uki_bootstub" ]; then
              case $image_uki_bootstub in
                gummiboot | stubby )
                  : ;;
                * )
                  error_message "Unknown UKI EFI bootstub '$image_uki_bootstub'!" ;;
              esac
            else
              image_uki_bootstub="$CADI_DEFAULT_UKI_BOOTSTUB"
            fi
          elif is_in_comma_list "grub" "$CADI_SUPPORTED_BOOTLOADERS_UEFI"; then
            image_bootloader="grub"
          elif is_in_comma_list "limine" "$CADI_SUPPORTED_BOOTLOADERS_UEFI"; then
            image_bootloader="limine"
          else
            error_message "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
      esac
    elif [ -n "$CADI_SUPPORTED_BOOT_TYPES" ]; then
      case $image_boot_type in
        bios )
          if is_in_comma_list "grub" "$CADI_SUPPORTED_BOOTLOADERS_BIOS"; then
            image_bootloader="grub"
          elif is_in_comma_list "syslinux" "$CADI_SUPPORTED_BOOTLOADERS_BIOS"; then
            image_bootloader="syslinux"
          elif is_in_comma_list "limine" "$CADI_SUPPORTED_BOOTLOADERS_BIOS"; then
            image_bootloader="limine"
          else
            error_message "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        hybrid )
          if is_in_comma_list "grub" "$CADI_SUPPORTED_BOOTLOADERS_HYBRID"; then
            image_bootloader="grub"
          elif is_in_comma_list "limine" "$CADI_SUPPORTED_BOOTLOADERS_HYBRID"; then
            image_bootloader="limine"
          else
            error_message "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        rpi )
          if is_in_comma_list "rpi" "$CADI_SUPPORTED_BOOTLOADERS_RPI"; then
            image_bootloader="rpi"
          else
            error_message "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        secure-uefi )
          if is_in_comma_list "grub" "$CADI_SUPPORTED_BOOTLOADERS_UEFI"; then
            image_bootloader="grub"
          else
            error_message "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
        uefi )
          if is_in_comma_list "uki" "$CADI_SUPPORTED_BOOTLOADERS_UEFI" && \
             [ -n "$image_experimental" ]; then
            image_bootloader="uki"
            if [ -n "$image_uki_bootstub" ]; then
              case $image_uki_bootstub in
                gummiboot | stubby )
                  : ;;
                * )
                  error_message "Unknown UKI EFI bootstub '$image_uki_bootstub'!" ;;
              esac
            else
              image_uki_bootstub="$CADI_DEFAULT_UKI_BOOTSTUB"
            fi
          elif is_in_comma_list "grub" "$CADI_SUPPORTED_BOOTLOADERS_UEFI"; then
            image_bootloader="grub"
          elif is_in_comma_list "limine" "$CADI_SUPPORTED_BOOTLOADERS_UEFI"; then
            image_bootloader="limine"
          else
            error_message "Unable to determine $image_boot_type bootloader to use!"
          fi
          ;;
      esac
    else
      error_message "Unable to determine $image_boot_type bootloader to use!"
    fi
  elif [ -n "$image_bootloader" ]; then
    case $image_boot_type in
      bios )
        if is_in_comma_list "$image_bootloader" "$CADI_SUPPORTED_BOOTLOADERS_BIOS"; then
          :
        else
          error_message "Bootloader '$image_bootloader' is not a valid bootloader to use for $image_boot_type booting!"
        fi
        ;;
      hybrid )
        if is_in_comma_list "$image_bootloader" "$CADI_SUPPORTED_BOOTLOADERS_HYBRID"; then
          :
        else
          error_message "Bootloader '$image_bootloader' is not a valid bootloader to use for $image_boot_type booting!"
        fi
        ;;
      rpi )
        if is_in_comma_list "$image_bootloader" "$CADI_SUPPORTED_BOOTLOADERS_RPI"; then
          :
        else
          error_message "Bootloader '$image_bootloader' is not a valid bootloader to use for $image_boot_type booting!"
        fi
        ;;
      secure-uefi )
        if is_in_comma_list "$image_bootloader" "$CADI_SUPPORTED_BOOTLOADERS_UEFI"; then
          :
        else
          error_message "Bootloader '$image_bootloader' is not a valid bootloader to use for $image_boot_type booting!"
        fi
        ;;
      uefi )
        if is_in_comma_list "$image_bootloader" "$CADI_SUPPORTED_BOOTLOADERS_UEFI"; then
          if [ "$image_bootloader" = "uki" ] && \
             [ -z "$image_experimental" ]; then
            error_message "$image_bootloader bootloader support is an experimental option!"
          else
            case $image_bootloader in
              uki )
                if [ -n "$image_uki_bootstub" ]; then
                  case $image_uki_bootstub in
                    gummiboot | stubby )
                      : ;;
                    * )
                      error_message "Unknown UKI EFI bootstub '$image_uki_bootstub'!" ;;
                  esac
                else
                  image_uki_bootstub="$CADI_DEFAULT_UKI_BOOTSTUB"
                fi
                ;;
              * )
                # Specified bootloader is supported by particular arch and
                # cloud/physical/virtual type
                : ;;
            esac
          fi
        else
          error_message "Bootloader '$image_bootloader' is not a valid bootloader to use for $image_boot_type booting!"
        fi
        ;;
    esac
  else
    error_message "Invalid bootloader specified!"
  fi

  # Boot device logical sector size (in bytes): 512 bytes / 4K
  : "${image_os_device_sector_size:=512}"

  # Check whether the particular boot method works with 4K sector devices.
  case $image_boot_type in
    bios | rpi )
      if [ "$image_os_device_sector_size" = 4096 ]; then
        error_message "4K sector size is not supported for BIOS/MBR booting!"
      fi
      ;;
  esac

  # Whether to refer to boot filesystem by UUID or device name
  if [ -z "$image_boot_reference" ]; then
    if [ -n "$CADI_DEFAULT_BOOT_REFERENCE" ] && \
       [ -n "$CADI_SUPPORTED_BOOT_REFERENCES" ] && \
       is_in_comma_list "$CADI_DEFAULT_BOOT_REFERENCE" "$CADI_SUPPORTED_BOOT_REFERENCES"; then
      image_boot_reference="$CADI_DEFAULT_BOOT_REFERENCE"
    else
      error_message "Unable to determine whether to use UUID or device name to refer to boot filesystem!"
    fi
  elif [ -n "$CADI_SUPPORTED_BOOT_REFERENCES" ] && \
       is_in_comma_list "$image_boot_reference" "$CADI_SUPPORTED_BOOT_REFERENCES"; then
    :
  else
    error_message "Boot reference '$image_boot_reference' is not supported by $class_type_description!"
  fi

  # OS Boot device type: nvme / sata / scsi / sd / usb / virtio-blk / virtio-scsi
  if [ -z "$image_os_device_type" ]; then
    # Automatically decide OS boot device type
    if [ -n "$CADI_DEFAULT_OS_DEVICE_TYPE" ] && \
       [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ] && \
       is_in_comma_list "$CADI_DEFAULT_OS_DEVICE_TYPE" "$CADI_SUPPORTED_OS_DEVICE_TYPES"; then
      image_os_device_type="$CADI_DEFAULT_OS_DEVICE_TYPE"
    elif [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ] && \
         is_in_comma_list "virtio-blk" "$CADI_SUPPORTED_OS_DEVICE_TYPES"; then
      image_os_device_type="virtio-blk"
    elif [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ] && \
         is_in_comma_list "virtio-scsi" "$CADI_SUPPORTED_OS_DEVICE_TYPES"; then
      image_os_device_type="virtio-scsi"
    elif [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ] && \
         is_in_comma_list "nvme" "$CADI_SUPPORTED_OS_DEVICE_TYPES"; then
      image_os_device_type="nvme"
    elif [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ] && \
         is_in_comma_list "sata" "$CADI_SUPPORTED_OS_DEVICE_TYPES"; then
      image_os_device_type="sata"
    elif [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ] && \
         is_in_comma_list "scsi" "$CADI_SUPPORTED_OS_DEVICE_TYPES"; then
      image_os_device_type="scsi"
    elif [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ] && \
         is_in_comma_list "usb" "$CADI_SUPPORTED_OS_DEVICE_TYPES"; then
      image_os_device_type="usb"
    elif [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ] && \
         is_in_comma_list "sd" "$CADI_SUPPORTED_OS_DEVICE_TYPES"; then
      image_os_device_type="sd"
    else
      error_message "Unable to determine OS device type to use for $class_type_description!"
    fi
  elif [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ] && \
       is_in_comma_list "$image_os_device_type" "$CADI_SUPPORTED_OS_DEVICE_TYPES"; then
    # Boot device type specified is fine
    :
  else
      error_message "Specified OS device type '$image_os_device_type' is not valid for $class_type_description!"
  fi

  # OS Boot device media: disk / flash / sdcard / ssd
  if [ -z "$image_os_device_media" ]; then
    # Automatically decide OS boot device media
    if [ -n "$CADI_SUPPORTED_OS_DEVICE_MEDIAS" ]; then
      case $image_os_device_type in
        nvme )
          if is_in_comma_list "ssd" "$CADI_SUPPORTED_OS_DEVICE_MEDIAS"; then
            image_os_device_media="ssd"
          else
            error_message "Unable to determine OS device media to use for $class_type_description with $image_os_device_type storage device!"
          fi
          ;;
        sd )
          if is_in_comma_list "sdcard" "$CADI_SUPPORTED_OS_DEVICE_MEDIAS"; then
            image_os_device_media="sdcard"
          else
            error_message "Unable to determine OS device media to use for $class_type_description with $image_os_device_type storage device!"
          fi
          ;;
        usb )
          if is_in_comma_list "flash" "$CADI_SUPPORTED_OS_DEVICE_MEDIAS"; then
            image_os_device_media="flash"
          else
            error_message "Unable to determine OS device media to use for $class_type_description with $image_os_device_type storage device!"
          fi
          ;;
        * )
          if is_in_comma_list "disk" "$CADI_SUPPORTED_OS_DEVICE_MEDIAS"; then
            image_os_device_media="disk"
          else
            error_message "Unable to determine OS device media to use for $class_type_description with $image_os_device_type storage device!"
          fi
          ;;
      esac
    else
      error_message "Unable to determine OS device media to use as no storage medias defined for $class_type_description with $image_os_device_type storage device!"
    fi
  elif [ -n "$CADI_SUPPORTED_OS_DEVICE_MEDIAS" ] && \
       is_in_comma_list "$image_os_device_media" "$CADI_SUPPORTED_OS_DEVICE_MEDIAS"; then
    case $image_os_device_type in
      nvme )
        if [ "$image_os_device_media" != "ssd" ]; then
          error_message "OS device media $image_os_device_media is not valid for $image_os_device_type storage device!"
        fi
        ;;
      sd )
        if [ "$image_os_device_media" != "sdcard" ]; then
          error_message "OS device media $image_os_device_media is not valid for $image_os_device_type storage device!"
        fi
        ;;
      usb )
        if [ "$image_os_device_media" != "flash" ]; then
          error_message "OS device media $image_os_device_media is not valid for $image_os_device_type storage device!"
        fi
        ;;
      * )
        if [ "$image_os_device_media" != "disk" ] && \
           [ "$image_os_device_media" != "ssd" ]; then
          error_message "Specified OS device media $image_os_device_media is not valid for $image_os_device_type storage device!"
        fi
        ;;
    esac
  else
      error_message "Specified OS device media '$image_os_device_media' is not valid for $class_type_description!"
  fi

  # Filesystem type: btrfs/  f2fs / ext4 / xfs
  if [ -z "$image_fs_type" ]; then
    # If filesystem type has not been explicitly specified then use default
    # or one of the supported alternative filesystems for the particular
    # cloud/physical/virtual type
    if [ -n "$CADI_DEFAULT_OS_FILESYSTEM" ] && \
       is_in_comma_list "$CADI_DEFAULT_OS_FILESYSTEM" "$CADI_SUPPORTED_OS_FILESYSTEMS"; then
      image_fs_type="$CADI_DEFAULT_OS_FILESYSTEM"
    elif is_in_comma_list "ext4" "$CADI_SUPPORTED_OS_FILESYSTEMS"; then
      image_fs_type="ext4"
    elif is_in_comma_list "xfs" "$CADI_SUPPORTED_OS_FILESYSTEMS"; then
      image_fs_type="xfs"
    elif [ -n "$image_experimental" ] && \
         is_in_comma_list "btrfs" "$CADI_SUPPORTED_OS_FILESYSTEMS"; then
      image_fs_type="btrfs"
    elif [ -n "$image_experimental" ] && \
         is_in_comma_list "f2fs" "$CADI_SUPPORTED_OS_FILESYSTEMS"; then
      image_fs_type="f2fs"
    else
      error_messages "Unable to determine filesystem type to use!"
    fi
  elif [ -n "$image_fs_type" ]; then
    if is_in_comma_list "$image_fs_type" "$CADI_SUPPORTED_OS_FILESYSTEMS"; then
      if [ -z "$image_experimental" ] && \
         { [ "$image_fs_type" = "btrfs" ] || \
           [ "$image_fs_type" = "f2fs" ]; }; then
        error_message "Support for '$image_fs_type' filesystem type is experimental!"
      else
        # Specified boot_type is supported by particular
        # cloud/physical/virtual type
        :
      fi
    else
      error_message "Boot type '$image_fs_type' ia not supported by $class_type_description!"
    fi
  else
    error_message "Invalid filesystem type specified!"
  fi

  if [ "$image_class" != "virtual" ] || \
     { [ "$image_vm_type" != "firecracker" ] && \
       [ "$image_vm_type" != "qemu-microvm" ]; }; then
    # Verify that specific bootloader can boot from specific filesystem type
    check_bootloader_supports_fs
  fi

  # Storage encryption: fscrypt / luks / both
  if [ -z "$image_encryption_type" ]; then
    image_encryption_type="none"
  elif [ -n "$CADI_SUPPORTED_OS_LUKS_ENCRYPTION" ] && \
       [ "$CADI_SUPPORTED_OS_LUKS_ENCRYPTION" = "false" ] && \
       { [ "$image_encryption_type" = "luks" ] || \
         [ "$image_encryption_type" = "both" ]; }; then
    error_message "LUKS encryption is not supported by $class_type_description!"
  else
    case $image_encryption_type in
      both | fscrypt )
        case $image_fs_type in
          ext4 | f2fs )
            : ;;
          * )
            error_message "Filesystem type $image_fs_type does not support fscrypt encryption!" ;;
        esac
        ;;
    esac

    case $image_encryption_type in
      both | luks )
        if [ -n "$remote_luks_unlock_enabled" ] && \
           [ "$image_class" = "cloud" ]; then
          error_message "Remote unlocking of encrypted rootfs is not supported in cloud!"
        fi
        ;;
    esac
  fi

  case $image_encryption_type in
    both | luks )
      decide_luks_version ;;
  esac

  # Decide whether a separate boot partition is required
  if [ -z "$image_create_boot_partition" ]; then
    if [ -n "$CADI_BOOT_PARTITION_REQUIRED" ]; then
      case $CADI_BOOT_PARTITION_REQUIRED in
        true )
          if [ "$image_boot_type" = "unpartitioned" ]; then
            error_message "Contradiction in settings, a separate /boot partition is required but disk is unpartitioned!"
          elif [ -n "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" ] && \
             [ "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" = "true" ]; then
            image_create_boot_partition=true
          elif [ -n "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" ]; then
            error_message "Contradiction in settings, a separate /boot partition is required but not supported by $class_type_description!"
          else
            image_create_boot_partition=false
          fi
          ;;
        * )
          image_create_boot_partition=false ;;
      esac
    else
      case $image_bootloader in
        grub )
          case $image_encryption_type in
            both | luks )
              # When GRUB is bootloader a separate boot partition is required if
              # using an LUKS encrypted rootfs:
              #   - with remote unlock OR
              #   - with Adiantum encryption (GRUB's LUKS module does not support this)
              if { [ -n "$image_experimental" ] && \
                   [ -n "$remote_luks_unlock_enabled" ]; } || \
                 [ "$image_luks_cipher" = "adiantum" ]; then
                if [ "$image_boot_type" = "unpartitioned" ]; then
                  error_message "Contradiction in settings, a separate /boot partition is required but not supported by $class_type_description!"
                elif [ -n "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" ] && \
                   [ "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" = "true" ]; then
                  image_create_boot_partition=true
                else
                  error "A separate /boot partition is required but is not clear if supported by $class_type_description!"
                fi
              else
                image_create_boot_partition=false
              fi
              ;;
          esac
          if [ "$image_create_boot_partition" = "true" ]; then
            # By creating a separate boot partition this means that GRUB should
            # not enable its own FDE encryption support as that would make no
            # sense (why have separate yet both encrypted boot and rootfs?).
            image_no_grub_luks_fde_encryption=true
          fi
          ;;
        uki )
          # UKI is UEFI only so no need for a separate /boot
          image_create_boot_partition=false ;;
        limine | syslinux )
          if [ "$image_encryption_type" = "both" ] || \
             [ "$image_encryption_type" = "luks" ] || \
             [ -n "$image_lvm_rootfs" ]; then
            # When Syslinux is bootloader a separate boot partition is required
            # with LUKS encrypted rootfs or LVM rootfs
            if [ "$image_boot_type" = "unpartitioned" ]; then
              error "A separate /boot partition is required but is not clear if supported by $class_type_description!"
            else
              image_create_boot_partition=true
            fi
          fi
          ;;
      esac
    fi
  elif [ "$image_create_boot_partition" = "true" ]; then
    if [ "$image_boot_type" = "unpartitioned" ]; then
      error_message "A separate /boot partition was spcified but disk is unpartitioning!"
    elif [ -n "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" ] && \
       [ "$CADI_SUPPORTED_OS_SEPARATE_BOOT_PARTITION" = "true" ]; then
    # Separate /boot is supported
      image_create_boot_partition=true
    else
      error_message "A separate /boot partition is not supported by $class_type_description!"
    fi
  else
    image_create_boot_partition=false
  fi

  # Swapfile
  : "${image_swap_file_size:=0}"
  if [ "$image_swap_file_size" != "0" ]; then
    image_create_swap_file=true
  else
    image_create_swap_file=false
  fi

  # Swap partition
  : "${image_swap_partition_size:=0}"
  if [ "$image_swap_partition_size" != "0" ] && \
     [ "$image_boot_type" != "unpartitioned" ]; then
    if [ -n "$CADI_SUPPORTED_OS_BOOT_DISK_SWAP" ] && \
       [ "$CADI_SUPPORTED_OS_BOOT_DISK_SWAP" = "true" ]; then
      image_create_swap_partition=true
    else
      image_create_swap_partition=false
    fi
  elif [ "$image_swap_partition_size" != "0" ]; then
    error_message "Disk is unpartitioned and so cannot create a swap partition!"
  else
    image_create_swap_partition=false
  fi
}


#
# Console related settings
#
default_console_related_settings() {
  # Console type
  if [ -z "$image_console_type" ]; then
    # Automatically determine console type
    if [ -n "$CADI_DEFAULT_CONSOLE_DEVICE_TYPE" ] && \
       [ -n "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES" ] && \
       is_in_comma_list "$CADI_DEFAULT_CONSOLE_DEVICE_TYPE" "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES"; then
      image_console_type="$CADI_DEFAULT_CONSOLE_DEVICE_TYPE"
    elif [ -n "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES" ]; then
      if is_in_comma_list "normal_and_serial" "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES"; then
        image_console_type="normal_and_serial"
      elif is_in_comma_list "normal" "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES"; then
        image_console_type="normal"
      elif is_in_comma_list "serial" "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES"; then
        image_console_type="serial"
      elif is_in_comma_list "hypervisor" "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES"; then
        image_console_type="hypervisor"
      elif is_in_comma_list "none" "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES"; then
        image_console_type="none"
      else
        error_message "Unable to automatically determine console type for '$class_type_description'!"
      fi
    else
      error_message "Unable to automatically determine console type for '$class_type_description'!"
    fi
  elif [ -n "$image_console_type" ] && \
       [ -n "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES" ] && \
       is_in_comma_list "$image_console_type" "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES"; then
    :
  else
    error_message "Console type '$image_console_type' is not supported for '$class_type_description'!"
  fi

  # Console output type
  case $image_console_type in
    hypervisor | serial )
      image_console_output_type="text" ;;
    none )
      image_console_output_type="none" ;;
    * )
      if [ "$image_enable_graphics" != "true" ]; then
        image_console_output_type="text"
      else
        # Automatically decide whether to use "generic" (i.e. all drivers)
        # or only a specific graphics driver(s) for console.
        if [ -n "$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE" ] && \
           [ "$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE" = "text" ] && \
           [ -n "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" ] && \
           is_in_comma_list "text" "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" && \
           [ "$image_boot_type" = "bios" ]; then
          # Text mode can only be used for BIOS based systems
          image_console_output_type="text"
        elif [ -n "$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE" ] && \
             [ "$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE" = "generic" ] && \
             [ -n "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" ] && \
             is_in_comma_list "generic" "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES"; then
          image_console_output_type="generic"
        elif [ -n "$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE" ] && \
             [ "$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE" = "graphics" ] && \
             [ -n "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" ] && \
             is_in_comma_list "graphics" "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES"; then
          image_console_output_type="graphics"
        elif [ -n "$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE" ] && \
             [ "$CADI_DEFAULT_CONSOLE_OUTPUT_TYPE" = "none" ] && \
             [ -n "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" ] && \
             is_in_comma_list "none" "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES"; then
          image_console_output_type="none"
        elif [ -n "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" ] && \
             is_in_comma_list "text" "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" && \
             [ "$image_boot_type" = "bios" ]; then
          # Text mode can only be used for BIOS based systems
          image_console_output_type="text"
        elif [ -n "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" ] && \
             is_in_comma_list "generic" "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES"; then
          image_console_output_type="generic"
        elif [ -n "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES" ] && \
             is_in_comma_list "graphics" "$CADI_SUPPORTED_CONSOLE_OUTPUT_TYPES"; then
          image_console_output_type="graphics"
        else
          error_message "Cannot determine whether to use generic, graphics, or text based console for $class_type_description!"
        fi
      fi
      ;;
  esac

  # Console keyboard
  case $image_console_type in
    hypervisor | serial )
      if [ -n "$image_keyboard_type" ]; then
        error_message "Keyboard type '$image_keyboard_type' makes no sense for a $image_console_type console!"
      else
        image_keyboard_type="none"
      fi
      ;;
    * )
      if [ -z "$image_keyboard_type" ]; then
        # Automatically determine keyboard type
        if [ -n "$CADI_DEFAULT_CONSOLE_KEYBOARD_TYPE" ] && \
           [ -n "$CADI_SUPPORTED_CONSOLE_KEYBOARD_TYPES" ]; then
          image_keyboard_type="$CADI_DEFAULT_CONSOLE_KEYBOARD_TYPE"
        elif [ -n "$CADI_SUPPORTED_CONSOLE_KEYBOARD_TYPES" ]; then
          image_keyboard_type="$(first_entry_in_comma_list "$CADI_SUPPORTED_CONSOLE_KEYBOARD_TYPES")"
        else
          case $image_arch in
            aarch64 | armv7 )
              # Arm-based machines normally use USB keyboards
              image_keyboard_type="${image_keyboard_type:-usb}" ;;
            * )
              image_keyboard_type="both" ;;
          esac
        fi
      elif [ -n "$image_keyboard_type" ] && \
           [ -n "$CADI_SUPPORTED_CONSOLE_KEYBOARD_TYPES" ] && \
           is_in_comma_list "$image_keyboard_type" "$CADI_SUPPORTED_CONSOLE_KEYBOARD_TYPES"; then
        # Use specified keyboard type
        :
      else
        error_message "Keyboard type '$image_keyboard_type' is not supported for $class_type_description!"
      fi
      ;;
  esac

  # Serial config
  case $image_console_type in
    normal_and_serial | serial )
      : "${image_serial_console_port_number:=$CADI_SUPPORTED_SERIAL_CONSOLE_PORT_NUMBER}"
      image_serial_console_name="${CADI_SUPPORTED_SERIAL_CONSOLE_PORT_BASE_NAME}${image_serial_console_port_number}"
      ;;
  esac

  # Console device name
  case $image_console_type in
    normal | normal_and_serial )
      image_console_name="tty0" ;;
    hypervisor )
      image_console_name="hvc0" ;;
    serial )
      image_console_name=$image_serial_console_name
      ;;
  esac
}


#
# NTP related settings
#
default_ntp_related_settings() {
  if [ -n "$CADI_DEFAULT_NTP_METHOD" ]; then
    case $CADI_DEFAULT_NTP_METHOD in
      none )
        image_ntp_method="none" ;;

      pools )
        image_ntp_method="pools" ;;

      ptp )
        if [ "$image_cloud_software" = "cloud-init" ] && \
           [ "$image_class" != "physical" ]; then
          case $image_alpine_release in
            v3.13 | v3.14 | v3.15 | v3.16 | v3.17 | v3.18 | edge)
              # PTP not supported, fallback to another option
              if is_in_comma_list "servers" "$CADI_SUPPORTED_NTP_METHODS" && \
                 { [ -n "$image_ntp_servers" ] || \
                   [ -n "$CADI_NTP_SERVERS" ] || \
                   [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
                   [ -n "$CADI_NTP_IPV6_SERVERS" ]; }; then
                image_ntp_method="servers"
              elif is_in_comma_list "pools" "$CADI_SUPPORTED_NTP_METHODS"; then
                image_ntp_method="pools"
              else
                image_ntp_method="unknown"
              fi
              ;;
            edge-special )
              image_ntp_method="ptp" ;;
          esac
        elif [ "$image_cloud_software" != "cloud-init" ] && \
             [ "$image_ntp_daemon" = "chrony" ] && \
             [ "$image_class" != "physical" ]; then
          image_ntp_method="ptp"
        else
          # PTP not supported, fallback to another option
          if is_in_comma_list "servers" "$CADI_SUPPORTED_NTP_METHODS" && \
             { [ -n "$image_ntp_servers" ] || \
               [ -n "$CADI_NTP_SERVERS" ] || \
               [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
               [ -n "$CADI_NTP_IPV6_SERVERS" ]; }; then
            image_ntp_method="servers"
          elif is_in_comma_list "pools" "$CADI_SUPPORTED_NTP_METHODS"; then
            image_ntp_method="pools"
          else
            image_ntp_method="unknown"
          fi
        fi
        ;;

      servers )
        if [ -n "$image_ntp_servers" ] || \
           [ -n "$CADI_NTP_SERVERS" ] || \
           [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
           [ -n "$CADI_NTP_IPV6_SERVERS" ]; then
          image_ntp_method="servers"
        elif is_in_comma_list "pools" "$CADI_SUPPORTED_NTP_METHODS" && \
             [ -n "$CADI_NTP_POOLS" ]; then
          image_ntp_method="pools"
        else
          image_ntp_method="unknown"
        fi
        ;;

      servers_and_pools )
        if { [ -n "$image_ntp_servers" ] || \
             [ -n "$CADI_NTP_SERVERS" ] || \
             [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
             [ -n "$CADI_NTP_IPV6_SERVERS" ]; } && \
           { is_in_comma_list "pools" "$CADI_SUPPORTED_NTP_METHODS" && \
             [ -n "$CADI_NTP_POOLS" ]; }; then
          image_ntp_method="servers_and_pools"
        elif { [ -n "$image_ntp_servers" ] || \
               [ -n "$CADI_NTP_SERVERS" ] || \
               [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
               [ -n "$CADI_NTP_IPV6_SERVERS" ]; } && \
             { ! is_in_comma_list "pools" "$CADI_SUPPORTED_NTP_METHODS" || \
               [ -z "$CADI_NTP_POOLS" ]; }; then
          image_ntp_method="servers"
        elif is_in_comma_list "pools" "$CADI_SUPPORTED_NTP_METHODS" && \
             [ -n "$CADI_NTP_POOLS" ]; then
          image_ntp_method="pools"
        else
          image_ntp_method="unknown"
        fi
        ;;
    esac
  elif is_in_comma_list "ptp" "$CADI_SUPPORTED_NTP_METHODS"; then
    image_ntp_method="ptp"
  elif is_in_comma_list "servers_and_pools" "$CADI_SUPPORTED_NTP_METHODS" && \
       { [ -n "$image_ntp_servers" ] || \
         [ -n "$CADI_NTP_SERVERS" ] || \
         [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
         [ -n "$CADI_NTP_IPV6_SERVERS" ]; } && \
       is_in_comma_list "pools" "$CADI_SUPPORTED_NTP_METHODS"; then
    image_ntp_method="servers_and_pools"
  elif is_in_comma_list "servers" "$CADI_SUPPORTED_NTP_METHODS" && \
       { [ -n "$image_ntp_servers" ] || \
         [ -n "$CADI_NTP_SERVERS" ] || \
         [ -n "$CADI_NTP_IPV4_SERVERS" ] || \
         [ -n "$CADI_NTP_IPV6_SERVERS" ]; }; then
    image_ntp_method="servers"
  elif is_in_comma_list "pools" "$CADI_SUPPORTED_NTP_METHODS"; then
    image_ntp_method="pools"
  else
    image_ntp_method="unknown"
  fi


  case $image_ntp_method in
    pools )
      if [ -n "$CADI_NTP_POOLS" ]; then
        image_ntp_pools_list="$CADI_NTP_POOLS"
      else
        image_ntp_pools_list="$CADI_GENERAL_NTP_POOLS"
      fi
      image_ntp_pools_options="iburst"
      ;;

    ptp )
      if [ -n "$CADI_PTP_DEVICE_NAME" ]; then
        image_chrony_phc_device="$CADI_PTP_DEVICE_NAME"
      else
        image_chrony_phc_device="/dev/ptp0"
      fi
      if [ -n "$CADI_PTP_DPOLL" ]; then
        image_chrony_phc_dpoll="$CADI_PTP_DPOLL"
      fi
      if [ -n "$CADI_PTP_OFFSET" ]; then
        image_chrony_phc_offset="$CADI_PTP_OFFSET"
      fi
      if [ -n "$CADI_PTP_POLL" ]; then
        image_chrony_phc_poll="$CADI_PTP_POLL"
      fi
      if [ -n "$CADI_PTP_STRATUM" ]; then
        image_chrony_phc_stratum="$CADI_PTP_STRATUM"
      fi
      ;;

    servers )
      if [ -n "$image_ntp_servers" ]; then
        image_ntp_servers_list="$image_ntp_servers"
      else
        if [ -n "$CADI_NTP_IPV4_SERVERS" ] || [ -n "$CADI_NTP_IPV6_SERVERS" ]; then
          if [ -z "$image_disable_ipv4" ] && [ -n "$CADI_NTP_IPV4_SERVERS" ]; then
            image_ntp_servers_list="$CADI_NTP_IPV4_SERVERS"
          fi
          if [ -z "$image_disable_ipv6" ] && [ -n "$CADI_NTP_IPV6_SERVERS" ]; then
            image_ntp_servers_list="$CADI_NTP_IPV6_SERVERS"
          fi
        fi
	if [ -n "$CADI_NTP_SERVERS" ]; then
          if [ -n "$image_ntp_servers_list" ]; then
            image_ntp_servers_list="$image_ntp_servers_list $CADI_NTP_SERVERS"
          else
            image_ntp_servers_list="$CADI_NTP_SERVERS"
          fi
        fi
      fi
      if [ -n "$CADI_NTP_SERVERS_OPTIONS" ]; then
        image_ntp_servers_options="$CADI_NTP_SERVERS_OPTIONS"
      else
        image_ntp_servers_options="$CADI_GENERAL_NTP_SERVERS_OPTIONS"
      fi
      ;;

    servers_and_pools )
      if [ -n "$image_ntp_servers" ]; then
        image_ntp_servers_list="$image_ntp_servers"
      else
        if [ -n "$CADI_NTP_IPV4_SERVERS" ] || [ -n "$CADI_NTP_IPV6_SERVERS" ]; then
          if [ -z "$image_disable_ipv4" ] && [ -n "$CADI_NTP_IPV4_SERVERS" ]; then
            image_ntp_servers_list="$CADI_NTP_IPV4_SERVERS"
          fi
          if [ -z "$image_disable_ipv6" ] && [ -n "$CADI_NTP_IPV6_SERVERS" ]; then
            image_ntp_servers_list="$CADI_NTP_IPV6_SERVERS"
          fi
        fi
	if [ -n "$CADI_NTP_SERVERS" ]; then
          if [ -n "$image_ntp_servers_list" ]; then
            image_ntp_servers_list="$image_ntp_servers_list $CADI_NTP_SERVERS"
          else
            image_ntp_servers_list="$CADI_NTP_SERVERS"
          fi
        fi
      fi
      if [ -n "$CADI_NTP_SERVERS_OPTIONS" ]; then
        image_ntp_servers_options="$CADI_NTP_SERVERS_OPTIONS"
      else
        image_ntp_servers_options="$CADI_GENERAL_NTP_SERVERS_OPTIONS"
      fi

      if [ -n "$CADI_NTP_POOLS" ]; then
        image_ntp_pools_list="$CADI_NTP_POOLS"
        image_ntp_pools_options="iburst"
      fi
      ;;

    none | unknown )
      : ;;

    * )
      error_message "Not a valid NTP method: '$image_ntp_method'!"
      ;;
  esac

  if [ "$image_ntp_daemon" = "chrony" ]; then
    if [ -n "$CADI_CHRONY_INITSTEPSLEW_THRESHOLD" ]; then
      image_chrony_initstepslew_threshold="$CADI_CHRONY_INITSTEPSLEW_THRESHOLD"
      case $image_ntp_method in
        pools )
          image_chrony_initstepslew_hosts=$image_ntp_pools_list ;;

        servers | servers_and_pools )
          image_chrony_initstepslew_hosts=$image_ntp_servers_list ;;
      esac
    fi
    if [ -n "$CADI_CHRONY_MAKESTEP_THRESHOLD" ]; then
      image_chrony_makestep_threshold="$CADI_CHRONY_MAKESTEP_THRESHOLD"
    fi
    if [ -n "$CADI_CHRONY_MAKESTEP_LIMIT" ]; then
      image_chrony_makestep_limit="$CADI_CHRONY_MAKESTEP_LIMIT"
    fi
  fi
}


#
# Partition sizing related settings
#
partition_sizing_related() {
  local _base_bootfs_size _base_rootfs_size _bootfs_extra_space
  local _bootloader_files_size _bootloader_packages_size
  local _cloud_cli_packages_size _config_software_packages_size
  local _hypervisor_agent_packages_size _kernel_rootfs_files_size
  local _packages_additional_size _packages_extra_size
  local _packages_optional_size _sbom_packages_size

  # Set the ESP partition filesystem type now that the boot method is known
  case $image_boot_type in
    hybrid | secure-uefi | uefi )
      if [ -z "$image_esp_type" ]; then
        case $image_bootloader in
          uki )
            image_esp_type="${image_esp_type:=$CADI_DEFAULT_UKI_ESP_TYPE}" ;;
          * )
            image_esp_type="${image_esp_type:=$CADI_DEFAULT_ESP_TYPE}"
            ;;
        esac
      fi
      ;;
  esac

  if [ "$image_create_boot_partition" = "true" ] && \
     [ -n "$boot_part_size" ]; then
    # Explicitly set the size of the /boot partition
    image_boot_part_size="${boot_part_size}"
  fi


  # Sort out partition sizing
  #---------------------------

  # Bootloader related sizing
  case $image_bootloader in
    grub | limine | rpi | syslinux )
      eval _bootloader_files_size='$'CADI_BOOTLOADER_"$(echo "$image_bootloader" | tr 'a-z' 'A-Z')"_BOOT_FILES_SIZE
      eval _bootloader_packages_size='$'CADI_BOOTLOADER_"$(echo "$image_bootloader" | tr 'a-z' 'A-Z')"_PACKAGES_SIZE
      ;;
  esac
  : "${_bootloader_files_size:=0}"
  : "${_bootloader_packages_size:=0}"

  # Additional kernel driver packages specific to the cloud/virtual/physical
  # machine type
  eval _driver_packages_list='$'CADI_"$(echo "$image_class" | tr 'a-z' 'A-Z')"_DRIVER_PACKAGES_LIST
  eval _driver_packages_size='$'CADI_"$(echo "$image_class" | tr 'a-z' 'A-Z')"_DRIVER_PACKAGES_SIZE
  eval _driver_packages_notpresentin='$'CADI_"$(echo "$image_class" | tr 'a-z' 'A-Z')"_DRIVER_PACKAGES_NOTPRESENTIN
  if [ -n "$_driver_packages_list" ]; then
    if [ -n "$_driver_packages_notpresentin" ] && \
       ! is_in_comma_list "$image_alpine_release" "$_driver_packages_notpresentin"; then
      # Packages are not available for this release of Alpine
      _driver_packages_list=""
    elif [ -z "$_driver_packages_size" ]; then
      error_message "Kernel driver packages for $class_type_description defined but no installed size defined for them!"
    else
      _driver_packages_list="$(echo $_driver_packages_list | tr ',' ' ')"
    fi
  fi

  # Additional packages specific to the cloud/virtual/physical machine type
  if [ -n "$CADI_PACKAGES_ADDITIONAL" ]; then
    if [ -n "$CADI_PACKAGES_ADDITIONAL_SIZE" ]; then
      packages_additional="$(echo "$CADI_PACKAGES_ADDITIONAL" | tr ',' ' ')"
      _packages_additional_size=$CADI_PACKAGES_ADDITIONAL_SIZE
    else
      error_message "Additional packages for $class_type_description defined but no installed size defined for them!"
    fi
  fi
  : "${_packages_additional_size:=0}"

  if [ -z "$image_barebones" ]; then
    # Agent packages such as Hyper-V / QEMU Agent / Virtualbox Guest / VMware
    # Agent which are not installed for barebones machines
    if [ -n "$CADI_HYPERVISOR_AGENT_PACKAGES" ]; then
      if [ -n "$CADI_HYPERVISOR_AGENT_PACKAGES_SIZE" ]; then
        hypervisor_agent_packages="$(echo "$CADI_HYPERVISOR_AGENT_PACKAGES" | tr ',' ' ')"
        _hypervisor_agent_packages_size=$CADI_HYPERVISOR_AGENT_PACKAGES_SIZE
      else
        error_message "Agent packages defined but no installed size defined for them!"
      fi
    fi

    # CLI packages specific to the cloud/virtual/physical machine type
    # which are not installed for barebones machines
    if [ -n "$CADI_CLOUD_CLI_PACKAGES" ]; then
      if [ -n "$CADI_CLOUD_CLI_PACKAGES_NOTPRESENTIN" ] && \
         ! is_in_comma_list "$image_alpine_release" "$CADI_CLOUD_CLI_PACKAGES_NOTPRESENTIN"; then
        # Package is not available for this release of Alpine
        :
      elif [ -z "$CADI_CLOUD_CLI_PACKAGES_SIZE" ]; then
        error_message "CLI packages for $class_type_description defined but no installed size defined for them!"
      else
        cloud_cli_packages="$(echo "$CADI_CLOUD_CLI_PACKAGES" | tr ',' ' ')"
        _cloud_cli_packages_size=$CADI_CLOUD_CLI_PACKAGES_SIZE
      fi
    fi

    # Extra packages specific to the cloud/virtual/physical machine type
    # which are not installed for barebones machines
    if [ -n "$CADI_PACKAGES_EXTRA" ]; then
      if [ -n "$CADI_PACKAGES_EXTRA_SIZE" ]; then
        packages_extra="$(echo "$CADI_PACKAGES_EXTRA" | tr ',' ' ')"
        _packages_extra_size=$CADI_PACKAGES_EXTRA_SIZE
      else
        error_message "Extra packages for $class_type_description defined but no installed size defined for them!"
      fi
    fi

    # Optional packages specific to the cloud/virtual/physical machine type
    # which are not installed for barebones machines
    if [ -n "$CADI_PACKAGES_OPTIONAL" ]; then
      if [ -n "$CADI_PACKAGES_OPTIONAL_SIZE" ]; then
        packages_optional="$(echo "$CADI_PACKAGES_OPTIONAL" | tr ',' ' ')"
        _packages_optional_size=$CADI_PACKAGES_OPTIONAL_SIZE
      else
        error_message "Optional packages for $class_type_description defined but no installed size defined for them!"
      fi
    fi
  fi
  : "${_hypervisor_agent_packages_size:=0}"
  : "${_cloud_cli_packages_size:=0}"
  : "${_packages_extra_size:=0}"
  : "${_packages_optional_size:=0}"

  # ESP partition sizing
  #----------------------
  case $image_boot_type in
    secure-uefi | uefi )
      case $image_bootloader in
        uki )
          general_uefi_part_size=${esp_part_size:-$CADI_DEFAULT_UKI_ESP_PART_SIZE} ;;
        * )
          case $image_esp_type in
            fat32 )
              # FAT32 is handled the same way for Cloud/PhysicalVirtual
              # in the cli-functions code
              : ;;
            * )
              general_uefi_part_size=${esp_part_size:-$CADI_DEFAULT_ESP_PART_SIZE} ;;
          esac
          ;;
      esac
      if [ -n "$debug_sizing_enabled" ]; then
        echo "[partition_sizing_related] size for ESP partition is: $general_uefi_part_size MiB" \
          >> "$sizing_debug"
      fi
      ;;
  esac

  # Bootfs sizing
  #---------------

  # This accounts for System.map, config, kernel, DTB files,
  # initramfs, and microcode in /boot
  eval _base_bootfs_size="$((CADI_BOOTFS_KERNEL_$(get_kernel_type | tr 'a-z' 'A-Z')_FILES_SIZE + CADI_INITRAMFS_SIZE + CADI_MICROCODE_SIZE))"

  _bootfs_extra_space=0

  if [ -n "$debug_sizing_enabled" ]; then
    {
      echo "[partition_sizing_related] base size of bootfs is: $_base_bootfs_size MiB"
      if [ "$image_boot_type" != "unpartitioned" ]; then
        echo "[partition_sizing_related] size of bootloader files in bootfs is: $_bootloader_files_size MiB"
      fi
      echo "[partition_sizing_related] extra free space for bootfs is: $_bootfs_extra_space MiB"
    } >> "$sizing_debug"
  fi

  # Add on size of bootloader-specific installed files to bootfs size
  general_bootfs_size=$((_base_bootfs_size + _bootfs_extra_space))
  if [ "$image_boot_type" != "unpartitioned" ]; then
    general_bootfs_size=$((general_bootfs_size + _bootloader_files_size))
  fi

  if [ -n "$debug_sizing_enabled" ]; then
    echo "[partition_sizing_related] total size for bootfs is: $general_bootfs_size MiB" \
      >> "$sizing_debug"
  fi

  # Rootfs sizing
  #---------------

  _base_rootfs_size=$CADI_ROOTFS_SIZE
  case $image_kernel_type in
    edge | normal )
      eval _kernel_rootfs_files_size='$'CADI_ROOTFS_KERNEL_"$(get_kernel_type | tr 'a-z' 'A-Z')"_FILES_SIZE ;;
  esac

  : "${general_rootfs_size:=$_base_rootfs_size}"

  case $image_cloud_software in
    cloud-init )
      _config_software_packages_size=$CADI_CLOUDINIT_PACKAGES_SIZE ;;
    tiny-cloud )
      _config_software_packages_size=$CADI_TINYCLOUD_PACKAGES_SIZE ;;
  esac
  : "${_config_software_packages_size:=0}"

  if [ -n "$debug_sizing_enabled" ]; then
    {
      echo "[partition_sizing_related] base size for rootfs is: $general_rootfs_size MiB"
      echo "[partition_sizing_related] size of kernel package files is: $_kernel_rootfs_files_size MiB"
      echo "[partition_sizing_related] size of bootloader packages is: $_bootloader_packages_size MiB"
      echo "[partition_sizing_related] size of configuration software packages is: $_config_software_packages_size MiB"
      case $image_class in
        cloud )
          echo "[partition_sizing_related] size of Cloud Provider CLI packages is: $_cloud_cli_packages_size MiB" ;;
        virtual )
          echo "[partition_sizing_related] size of VM Hypervisor agent packages is: $_hypervisor_agent_packages_size MiB" ;;
      esac
      echo "[partition_sizing_related] size of additional packages is: $_packages_additional_size MiB"
      echo "[partition_sizing_related] size of extra packages is: $_packages_extra_size MiB"
      echo "[partition_sizing_related] size of optional packages is: $_packages_optional_size MiB"
    } >> "$sizing_debug"
  fi

  # Add on size of kernel, bootloader-specific, cloud config software,
  # hypervisor-specific packages, Cloud CLI package, additional packages,
  # optional packages & extra packages to rootfs size
  general_rootfs_size=$((general_rootfs_size + _kernel_rootfs_files_size + _bootloader_packages_size + _config_software_packages_size + _packages_additional_size + _packages_extra_size + _packages_optional_size))
  case $image_class in
    cloud )
      general_rootfs_size=$((general_rootfs_size + _cloud_cli_packages_size)) ;;
    virtual )
      general_rootfs_size=$((general_rootfs_size + _hypervisor_agent_packages_size)) ;;
  esac

  if [ -n "$debug_sizing_enabled" ]; then
    echo "[partition_sizing_related] size of user-specified additional packages is: $image_additional_packages_size MiB" \
      >> "$sizing_debug"
  fi

  # Add on size of user-specified additional packages to rootfs size
  general_rootfs_size=$((general_rootfs_size + image_additional_packages_size ))

  if [ -n "$debug_sizing_enabled" ]; then
    echo "[partition_sizing_related] total size for rootfs is: $general_rootfs_size MiB" \
      >> "$sizing_debug"
  fi
}


#
# Settings shared between Cloud/Physical/Virtual machines
#
default_settings() {
  local _base_bootfs_size _bootfs_extra_space _base_rootfs_size
  local _bootloader_files_size _bootloader_packages_size
  local _config_software_packages_size
  local _kernel_rootfs_files_size _sbom_packages_size

  do_generic_validation_checks

  source_additional_definitions_files

  do_specific_validation_checks

  # APK static version
  if [ -z "$apk_static_checksum" ]; then
    eval apk_static_checksum='$'"CADI_APK_STATIC_$(echo "$image_arch" | tr 'a-z' 'A-Z')_CHECKSUM"
  fi
  : "${apk_static_version:=$CADI_APK_STATIC_VERSION}"
  : "${apk_static_url:=$CADI_APK_STATIC_URL}"

  # Set disk image filename
  filename_for_image="${filename_for_image:-./alpine-$image_alpine_release-$image_arch-$image_class-$image_class_subtype.img}"


  # If graphics is not specifically enabled then disable it
  : "${image_enable_graphics:=false}"


  # NTP use
  if [ -z "$image_ntp_use" ]; then
    case $image_ntp_use in
      none )
        if [ -n "$CADI_SUPPORTED_NTP_METHODS" ] && \
           is_in_comma_list "none" "$CADI_SUPPORTED_NTP_METHODS"; then
          image_ntp_daemon="none"
          unset image_ntp_pools
          unset image_ntp_servers
        else
          error_message "Not using a NTP is not supported!"
        fi
        ;;

      ptp )
        if [ -n "$CADI_SUPPORTED_NTP_METHODS" ] && \
           is_in_comma_list "ptp" "$CADI_SUPPORTED_NTP_METHODS"; then
          image_ntp_daemon="chrony"
          unset image_ntp_pools
          unset image_ntp_servers
        else
          error_message "PTP is not supported!"
        fi
        ;;
    esac
  fi

  # Cron daemon, DHCP client, NTP daemon, SSH server, Syslog server,
  # user/group management software, UTMP.
  if [ -n "$image_barebones" ]; then
    : "${image_cron_daemon:=busybox}"
    if [ -n "$CADI_DHCP_CLIENT" ]; then
      : "${image_dhcp_client:=$CADI_DHCP_CLIENT}"
    else
      : "${image_dhcp_client:=udhcpc}"
    fi
    : "${image_login_package:=busybox}"
    : "${image_ntp_daemon:=busybox}"
    : "${image_ssh_server:=dropbear}"
    : "${image_syslog_server:=busybox}"
    : "${image_user_management:=busybox}"

    image_device_management_type=mdev

    case $image_arch in
      x86 | x86_64 )
        case $image_boot_type in
          bios | none | rpi )
            : ;;
          * )
            # Override setting as UEFI requires graphics
            image_enable_graphics=true ;;
        esac
        ;;
    esac
  else
    if [ -n "$CADI_HYPERVISOR_AGENT_PACKAGES" ]; then
      case $image_class in
        virtual )
          if [ -n "$CADI_DEFAULT_NTP_METHOD" ] && \
             [ "$CADI_DEFAULT_NTP_METHOD" = "none" ]
             is_in_comma_list "none" "$CADI_SUPPORTED_NTP_METHODS" && \
             [ -z "$image_ntp_use" ]; then
            case $image_class_subtype in
              virtualbox )
                # For these hypervisors the agent manages timesync
                image_ntp_daemon="none"
                ;;
            esac
          fi
          ;;
      esac
    fi

    : ${image_cron_daemon:=$CADI_DEFAULT_CRON_DAEMON}
    if [ -n "$CADI_DHCP_CLIENT" ]; then
      : ${image_dhcp_client:=$CADI_DHCP_CLIENT}
    else
      : "${image_dhcp_client:=$CADI_DEFAULT_DHCP_CLIENT}"
    fi
    : ${image_login_package:=$CADI_DEFAULT_LOGIN_PACKAGE}
    if [ -n "$image_ntp_use" ] && \
       [ "$image_ntp_use" = "none" ]; then
      image_ntp_daemon="none"
    else
      : ${image_ntp_daemon:=$CADI_GLOBAL_DEFAULT_NTP_DAEMON}
    fi
    : ${image_ssh_server:=$CADI_DEFAULT_SSH_SERVER}
    : ${image_syslog_server:=$CADI_DEFAULT_SYSLOG_SERVER}
    : ${image_user_management:=$CADI_DEFAULT_USER_MANAGEMENT_PACKAGE}
  fi

  : "${image_enable_utmp:=false}"

  # ACPI poweroff
  #---------------
  if [ -z "$image_acpi_power_method" ]; then
    if [ -n "$CADI_DEFAULT_ACPI_BUTTON" ] && \
       is_in_comma_list "$CADI_DEFAULT_ACPI_BUTTON" "$CADI_SUPPORTED_ACPI_BUTTONS"; then
      image_acpi_power_method="$CADI_DEFAULT_ACPI_BUTTON"
    elif [ -n "$CADI_SUPPORTED_ACPI_BUTTONS" ]; then
      image_acpi_power_method="$(first_entry_in_comma_list "$CADI_SUPPORTED_ACPI_BUTTONS")"
    else
      image_acpi_power_method="button"
    fi
  fi

  # Timezone
  #----------
  case $image_cloud_software in
    cloud-init | none )
      : "${image_timezone:=$CADI_GLOBAL_DEFAULT_TIMEZONE}" ;;
  esac

  default_boot_related_settings
  default_console_related_settings

  case $image_ntp_daemon in
    none )
      : ;;
    * )
      default_ntp_related_settings ;;
  esac

  # Calculate additional disk space required for optional packages
  image_sbom=${image_sbom:-false}
  if [ "$image_sbom" = "true" ]; then
    _sbom_packages_size="${CADI_SBOM_PACKAGE_SIZE:-0}"
    if [ "$_sbom_packages_size" = "0" ]; then
      error_message "SBOM package is not available!"
    fi
    image_additional_packages_size=$((image_additional_packages_size + _sbom_packages_size))
  fi

  partition_sizing_related
}


#
# Define list of packages in addition to base Alpine
#
define_additional_packages() {
  local _initial_pkgs

  case $image_auth_control in
    doas )
      _initial_pkgs="doas" ;;
    sudo )
      _initial_pkgs="sudo" ;;
    both )
      _initial_pkgs="doas sudo" ;;
  esac

  # Busybox's cpio sometimes has problems with mkinitfs
  _initial_pkgs="$_initial_pkgs cpio"

  if [ -n "$image_barebones" ]; then
    # Barebone packages
    :
  else
    _initial_pkgs="$_initial_pkgs ca-certificates htop kbd-bkeymaps logrotate"
    _initial_pkgs="$_initial_pkgs musl-locales sshguard"
    if [ -n "$debug_enabled" ]; then
      _initial_pkgs="$_initial_pkgs hwinfo lshw"
    elif [ "$image_class" = "physical" ]; then
      _initial_pkgs="$_initial_pkgs hwinfo"
    fi

    # Acct
    case $image_alpine_release in
      v3.13 | v3.14 | v3.15 )
        # These releases do not have suitable acct package
        : ;;
      * )
        _initial_pkgs="$_initial_pkgs acct" ;;
    esac

    # busybox/shadow/util-linux for login
    case $image_login_package in
      busybox )
        : ;;
      shadow )
        _initial_pkgs="$_initial_pkgs shadow-login" ;;
      util-linux )
        _initial_pkgs="$_initial_pkgs util-linux-login" ;;
    esac

    # PAM support
    if [ -n "$image_enable_pam" ]; then
      _initial_pkgs="$_initial_pkgs linux-pam"
    fi

    # busybox or shadow for user/group management
    case $image_user_management in
      busybox )
        : ;;
      shadow )
        _initial_pkgs="$_initial_pkgs shadow" ;;
    esac

    # UTMP
    if [ "$image_enable_utmp" = "true" ]; then
      _initial_pkgs="$_initial_pkgs procps utmps"
    fi
  fi

  case $image_encryption_type in
    both )
      _initial_pkgs="$_initial_pkgs cryptsetup fscrypt"
      if [ -n "$image_experimental" ] && \
         [ -n "$remote_luks_unlock_enabled" ]; then
          _initial_pkgs="$_initial_pkgs dropbear-convert dropbear-unlockdisk"
      fi
      ;;
    fscrypt )
      _initial_pkgs="$_initial_pkgs fscrypt" ;;
    luks )
      _initial_pkgs="$_initial_pkgs cryptsetup"
      if [ -n "$image_experimental" ] && \
         [ -n "$remote_luks_unlock_enabled" ]; then
          _initial_pkgs="$_initial_pkgs dropbear-convert dropbear-unlockdisk"
      fi
      ;;
  esac

  if [ -n "$image_lvm_rootfs" ]; then
    _initial_pkgs="$_initial_pkgs lvm2"
  fi

  if [ "$image_encryption_type" = "both" ] || [ "$image_encryption_type" = "luks" ] || \
     [ -n "$image_lvm_rootfs" ]; then
    _initial_pkgs="$_initial_pkgs device-mapper"
  fi

  if [ -z "$image_barebones" ]; then
    case $image_firewall in
      iptables )
        _initial_pkgs="$_initial_pkgs iptables"
        if [ -z "$image_disable_ipv6" ]; then
          case $image_alpine_release in
            v3.13 | v3.14 | v3.15 | v3.16 | v3.17 | v3.18 )
              _initial_pkgs="$_initial_pkgs ip6tables" ;;
            * )
              # There is no ip6tables sub-package anymore
              : ;;
          esac
        fi
        ;;
      nftables )
        _initial_pkgs="$_initial_pkgs nftables" ;;
    esac
  fi

  case $image_fs_type in
    btrfs )
      _initial_pkgs="$_initial_pkgs btrfs-progs btrfs-progs-extra" ;;
    ext4 )
      if [ -n "$image_barebones" ]; then
        _initial_pkgs="$_initial_pkgs e2fsprogs"
      else
        _initial_pkgs="$_initial_pkgs e2fsprogs-extra"
      fi
      ;;
    f2fs )
      _initial_pkgs="$_initial_pkgs f2fs-tools" ;;
    xfs )
      _initial_pkgs="$_initial_pkgs xfsprogs xfsprogs-extra" ;;
  esac

  # Cron
  case $image_cron_daemon in
    busybox )
      : ;;
  esac

  # DHCP client
  case $image_dhcp_client in
    dhclient )
      _initial_pkgs="$_initial_pkgs dhclient" ;;
    dhcpcd )
      _initial_pkgs="$_initial_pkgs dhcpcd" ;;
    udhcpc )
      : ;;
  esac

  # NTP
  case $image_ntp_daemon in
    busybox | none )
      : ;;
    chrony )
      _initial_pkgs="$_initial_pkgs chrony" ;;
  esac

  # SSH
  case $image_ssh_server in
    dropbear )
      _initial_pkgs="$_initial_pkgs dropbear"
      if [ -z "$image_barebones" ]; then
        _initial_pkgs="$_initial_pkgs openssh-sftp-server"
      fi
      ;;
    openssh )
      if [ -n "$image_enable_pam" ]; then
        _initial_pkgs="$_initial_pkgs openssh-server-pam"
      else
        _initial_pkgs="$_initial_pkgs openssh-server"
      fi
      ;;
    tinyssh )
      _initial_pkgs="$_initial_pkgs tinyssh"
      if [ -z "$image_barebones" ]; then
        _initial_pkgs="$_initial_pkgs openssh-sftp-server"
      fi
      ;;
  esac

  # Syslog
  case $image_syslog_server in
    busybox )
      : ;;
    rsyslog )
      _initial_pkgs="$_initial_pkgs rsyslog" ;;
  esac

  if [ "$image_sbom" = "true" ]; then
    _initial_pkgs="${_initial_pkgs} syft"
  fi

  echo "$_initial_pkgs"
}


#
# Define list of packages related to machine characteristics
#
define_machine_specific_packages() {
  local _machine_specific_packages

  # Packages always installed
  case $image_class in
    cloud )
      _machine_specific_packages="$(define_cloud_machine_packages)" ;;
    physical )
      _machine_specific_packages="$(define_physical_machine_packages)" ;;
    virtual )
      _machine_specific_packages="$(define_virtual_machine_packages)" ;;
  esac

  echo "$_machine_specific_packages"
}


#
# Define list of os-related configuration software packages
#
define_os_config_software_packages() {
  local _os_config_software_pkgs

  # cloud-init / tiny-cloud / neither related packages
  case $image_cloud_software in
    cloud-init )
      _os_config_software_pkgs="$(define_cloud_init_packages)" ;;
    none )
      _os_config_software_pkgs="$(define_non_cloud_init_machine_packages)" ;;
    tiny-cloud )
      _os_config_software_pkgs="$(define_tiny_cloud_packages)" ;;
  esac

  # Decide whether to use mdev, mdevd, or eudev
  case $image_cloud_software in
    cloud-init | none )
      case $image_device_management_type in
        mdev )
          _os_config_software_pkgs="$_os_config_software_pkgs busybox" ;;
        mdevd )
          _os_config_software_pkgs="$_os_config_software_pkgs mdevd" ;;
        udev )
          _os_config_software_pkgs="$_os_config_software_pkgs eudev" ;;
      esac
      ;;
    tiny-cloud )
      # Tiny-Cloud defines its own mdev/mdevd/eudev dependancies accordingly
      : ;;
  esac

  echo "$_os_config_software_pkgs"
}


#
# Delete unnecessary users & groups
#
delete_users_groups() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Delete unnecessary users and groups"
	{
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	  # Debug
	  {
	    cp /etc/group /etc/group-orig
	    cp /etc/passwd /etc/passwd-orig
	    cp /etc/shadow /etc/shadow-orig
	EOF

    case $image_device_management_type in
      udev )
        cat <<-'EOF' >> "$run_script"
	
	    cp /lib/udev/rules.d/50-udev-default.rules \
	      /lib/udev/rules.d/50-udev-default.rules-orig
	EOF
      ;;
    esac

    cat <<-'EOF' >> "$run_script"
	  }
	
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	  write_log "Delete unnecessary users" 2
	  {
	    _unreq_users_list="cyrus ftp games guest halt man news ntp operator"
	    _unreq_users_list="\$_unreq_users_list postmaster shutdown smmsp squid"
	    _unreq_users_list="\$_unreq_users_list sync vpopmail xfs"
	
	    for _unrequired_user in \$_unreq_users_list
	    do
	      write_debug_log "Delete user '\$_unrequired_user'" 4
	      deluser \$_unrequired_user 2> /dev/null
	    done
	  }
	
	  write_log "Delete unnecessary groups" 2
	  {
	    _unreq_groups_list="abuild cdrw"
	
	    for _unrequired_group in \$_unreq_groups_list
	    do
	      write_debug_log "Delete group '\$_unrequired_group'" 4
	      delgroup \$_unrequired_group
	    done
	EOF

  case $image_device_management_type in
    udev )
      cat <<-'EOF' >> "$run_script"
	
	    write_log "Remove references to deleted groups from udev rules" 4
	    {
	      write_debug_log "Rewrite any wrapped lines into single lines" 6
	      sed -i -e ':x;/\\$/{N;s/\\\n//g;bx;}' -e 's/ [ ]*/ /g' \
	        /lib/udev/rules.d/50-udev-default.rules
	      for _unrequired_group in \$_unreq_groups_list
	      do
	        write_debug_log "Remove group \$_unrequired_group references" 6
	        sed -i -e "/^.*GROUP=\"\$_unrequired_group\".*$/d" \
	          /lib/udev/rules.d/50-udev-default.rules
	      done
	    }
	EOF
      ;;
  esac

  cat <<-'EOF' >> "$run_script"
	  }
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  {
	    write_debug_log "Users differences:" 2
	    diff /etc/passwd-orig /etc/passwd >> /chroot.log || true
	
	    write_debug_log "Users differences:" 2
	    diff /etc/shadow-orig /etc/shadow >> /chroot.log || true
	
	    write_debug_log "Groups differences:" 2
	    diff /etc/group-orig /etc/group >> /chroot.log || true
	
	    rm /etc/group-orig /etc/passwd-orig /etc/shadow-orig
	EOF

    case $image_device_management_type in
      udev )
        cat <<-'EOF' >> "$run_script"
	
	    write_debug_log "50-udev-default.rules differences:" 2
	    diff /lib/udev/rules.d/50-udev-default.rules-orig \
	      /lib/udev/rules.d/50-udev-default.rules >> /chroot.log || true
	    rm /lib/udev/rules.d/50-udev-default.rules-orig
	EOF
        ;;
    esac

    cat <<-'EOF' >> "$run_script"
	  }
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Returns the full path to the initramfs file taking into account
# the initramfs generator tool in use.
#
get_initramfs_filename() {
  local _filename _prefix

  case $image_initramfs_tool in
    booster )
      _prefix="booster" ;;
    dracut )
      _prefix="initramfs" ;;
    mkinitfs )
      _prefix="initramfs" ;;
  esac

  _filename="${_prefix}-$(get_kernel_type)"

  echo "$_filename"
}


#
# Install base Alpine system
#
install_alpine_base() {
  local _base_packages _bootloader_packages

  _base_packages="alpine-base"
  case $image_boot_type in
    secure-uefi | uefi )
      _base_packages="$_base_packages efivar"
      # Needed for fsck.vfat (for ESP partition)
      _base_packages="$_base_packages dosfstools"
  esac
  case $image_boot_type in
    secure-uefi )
      _base_packages="$_base_packages efi-mkkeys mokutil secureboot-hook" ;;
  esac

  # Add the appropriate package for ifup / ifdown utilities
  case $image_ifupdown_package in
    busybox )
      _base_packages="$_base_packages busybox-ifupdown" ;;
    ifupdown )
      _base_packages="$_base_packages ifupdown" ;;
    ifupdown-ng )
      _base_packages="$_base_packages ifupdown-ng" ;;
    * )
      _base_packages="$_base_packages ifupdown-ng" ;;
  esac

  # Add the appropriate package for managing initramfs
  case $image_initramfs_tool in
    booster )
      _base_packages="$_base_packages booster" ;;
    dracut )
      _base_packages="$_base_packages dracut" ;;
    mkinitfs )
      _base_packages="$_base_packages mkinitfs" ;;
  esac

  # Define bootloader-related packages
  case $image_bootloader in
    grub )
      _bootloader_packages="grub"
      case $image_boot_type in
        secure-uefi | uefi )
          _bootloader_packages="$_bootloader_packages grub-efi" ;;
        * )
          _bootloader_packages="$_bootloader_packages grub-bios" ;;
      esac
      ;;
    limine )
      case $image_boot_type in
        secure-uefi | uefi )
          case $image_arch in
            aarch64 )
              _bootloader_packages="limine-aarch64" ;;
            x86_64 )
              _bootloader_packages="limine-x86_64" ;;
          esac
          _bootloader_packages="$_bootloader_packages limine-efi-updater"
          if [ "$image_boot_type" = "secure-uefi" ]; then
            _bootloader_packages="$_bootloader_packages limine-enroll-config"
          fi
          ;;
        * )
          _bootloader_packages="limine-deploy limine-sys" ;;
      esac
      ;;
    rpi )
      _bootloader_packages="dosfstools raspberrypi-bootloader-cutdown"
      case $image_alpine_release in
        v3.13 | v3.14 | v3.15 )
          # Prior to 3.16/Edge raspberrypi-common does not exist and so
          # raspberrypi-bootloader must also be installed.
          _bootloader_packages="$_bootloader_packages raspberrypi-bootloader" ;;
      esac
      ;;
    syslinux )
      _bootloader_packages="syslinux" ;;
    uki )
      _bootloader_packages="secureboot-hook"
      case $image_uki_bootstub in
        gummiboot )
          _bootloader_packages="$_bootloader_packages gummiboot" ;;
        stubby )
          _bootloader_packages="$_bootloader_packages stubbyboot-efistub" ;;
      esac
      ;;
    * )
      _bootloader_packages="none" ;;
  esac
  if [ "$_bootloader_packages" != "none" ]; then
    _base_packages="$_base_packages $_bootloader_packages"
  fi

  cat <<-EOF >> "$run_script"
	
	write_log "Bootloader packages to be installed are: $_bootloader_packages"
	EOF

  case $image_script_host_os in
    all )
      cat <<-EOF >> "$run_script"
	_host_os=\$(detect_host_os)
	case \$_host_os in
	  alpine )
	    _apk_binary="apk" ;;
	  * )
	    _apk_binary="\$TMPDIR/apk.static" ;;
	esac
	EOF
      ;;
    alpine )
      cat <<-EOF >> "$run_script"
	_apk_binary="apk"
	EOF
      ;;
    * )
      cat <<-EOF >> "$run_script"
	_apk_binary="\$TMPDIR/apk.static"
	EOF
      ;;
  esac

  cat <<-EOF >> "$run_script"
	write_log "Install base Alpine (plus bootloader packages) for ${image_arch} arch inside chroot"
	{
	  # shellcheck disable=SC2086
	  \$_apk_binary --arch "${image_arch}" --initdb --allow-untrusted \\
	    --root \$chroot_dir --update-cache add ${_base_packages} \\
	    >> "\$logfile" 2>&1
	  _rc=\$?
	  if [ \$_rc != 0 ]; then
	    write_log "Failure while installing base Alpine, error code: \$_rc"
	    exit 1
	  fi
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	write_debug_log "Disk space usage for base Alpine:"
	df -k $chroot_dir >> "$logfile"
	EOF
  fi

  case $image_script_host_os in
    alpine )
      : ;;
    * )
      cat <<-EOF >> "$run_script"
	
	  # Tidy-up after apk.static run
	  rm -f \$TMPDIR/apk.static
	  if [ -n "\$temp_ca_dir_created" ] && \\
	     [ "\$temp_ca_dir_created" = "true" ]; then
	    echo "deleting the temporary CA directory"
	    rm -Rf /etc/apk
	  elif [ -n "\$temp_ca_file_created" ] && \\
	     [ "\$temp_ca_file_created" = "true" ]; then
	    echo "deleting the temporary CA file"
	    rm -f /etc/apk/ca.pem
	  fi
	EOF
      ;;
  esac

  cat <<-EOF >> "$run_script"
	}
	EOF
}


#
# Insert function get_kernel_package_version into created script
#
insert_chroot_function_find_module_full_path() {
  cat <<-'EOF' >> "$run_script"
	
	find_module_full_path() {
	  local _module="\$1"
	
	  local _module_path
	
	  _module_path="\$(find /lib/modules/ -name "\${_module}.ko*" | \\
	    sed -e 's/^.*kernel/kernel/' -e 's/\.ko.*$//')"
	
	  if [ -z "\$_module_path" ]; then
	    _module="\$(echo \$_module | sed -e 's/-/_/g')"
	    _module_path="\$(find /lib/modules/ -name "\${_module}.ko*" | \\
	      sed -e 's/^.*kernel/kernel/' -e 's/\.ko.*$//')"
	  fi
	
	  if [ -n "\$_module_path" ]; then
	    _module_path="\${_module_path}.ko*"
	  fi
	
	  echo "\$_module_path"
	}
	EOF
}



#
# Insert function get_kernel_package_version into created script
#
insert_chroot_function_get_kernel_package_version() {
  local _kernel_type

  _kernel_type=$(get_kernel_type)

  cat <<-EOF >> "$run_script"
	
	get_kernel_package_version() {
	  echo "\\\$(apk info linux-$_kernel_type | head -n 1 | sed -e "s/^linux-$_kernel_type-//" \\
	    -e 's/ .*//')"
	}
	EOF
}


#
# Insert functions into created script
#
insert_chroot_functions() {
  cat <<-'EOF' >> "$run_script"
	
	############################################################################
	##		Chroot Functions
	############################################################################
	EOF

  insert_chroot_function_add_fstab_entry
  case $image_encryption_type in
    both | luks )
      insert_chroot_function_define_cmdline_for_luks_encryption ;;
  esac
  insert_chroot_function_find_module_full_path
  insert_chroot_function_get_kernel_package_version
  insert_chroot_function_get_kernel_version
  insert_chroot_function_write_debug_log
  insert_chroot_function_write_log
}


#
# Install relevant firmware packages
#
install_firmware() {
  local _firmware_pkgs=""

  if [ "$image_class" = "physical" ]; then
    cat <<-EOF >> "$run_script"
	write_log "Selecting firmware packages to install"
	{
	EOF

    _firmware_pkgs="$(firmware_list_for_physical)"

    if [ -n "$_firmware_pkgs" ]; then
      cat <<-EOF >> "$run_script"
	  write_log "Installing firmware" 2
	  apk add $_firmware_pkgs >> /chroot.log 2>&1
	EOF
    else
      cat <<-EOF >> "$run_script"
	  write_log "No firmware to install" 2
	EOF
    fi

    cat <<-EOF >> "$run_script"
	}
	EOF
  fi
}


#
# Install relevant kernel package
#
install_kernel() {
  local _firmware_pkg _kernel_pkg _kernel_config_file

  _firmware_pkg="linux-firmware-none"

  _kernel_pkg="linux-$(get_kernel_type)"
  _kernel_config_file="config-$(get_kernel_type)"

  cat <<-EOF >> "$run_script"
	
	write_log "Installing kernel $_kernel_pkg"
	{
	  apk add $_kernel_pkg ${_firmware_pkg:-} >> /chroot.log 2>&1
	EOF

  cat <<-'EOF' >> "$run_script"
	
	  _kernel_version=\$(get_kernel_version)
	  _kernel_package_version=\$(get_kernel_package_version)
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-EOF >> "$run_script"
	
	  write_debug_log "Disk space usage after kernel installed:"
	  df -k >> /chroot.log

	  write_debug_log "Kernel is: \\\$_kernel_version"
	  write_debug_log "Kernel package version is: \\\$_kernel_package_version"
	
	  # Take a copy of the kernel config file
	  cp /boot/$_kernel_config_file \\
	    /kernel-config_\\\${_kernel_package_version}_${image_arch}_${_kernel_config_file}
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Install CPU microcode packages
#
install_microcode() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Selecting microcode packages to install"
	{
	EOF

  # only Physical machines use microcode
  install_microcode_for_physical

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Prepare the main section of the run script
#
prep_runscript_main_section() {
  cat <<-EOF >> "$run_script"
	
	#############################################################################
	##   Main Section
	#############################################################################
	
	# Ensure if any errors occur that various cleanup operations happen
	trap error_cleanup EXIT
	
	chroot_dir="${chroot_directory}"
	images_dir="${images_directory}"
	TMPDIR="/var/tmp"
	
	image_filename="${filename_for_image}"
	logfile="${logs_output_file}"
	
	EOF

  if [ -n "$image_console_user_password" ]; then
    cat <<-EOF >> "$run_script"
	console_user_password="${image_console_user_password}"
	EOF
  fi

  if [ -n "$image_default_user_password" ]; then
    cat <<-EOF >> "$run_script"
	default_user_password="${image_default_user_password}"
	EOF
  fi

  case $image_encryption_type in
    both | luks )
      cat <<-EOF >> "$run_script"
	luks_passphrase="${image_luks_passphrase}"
	EOF
      ;;
  esac

  if [ -n "$image_bootloader_password" ]; then
    cat <<-EOF >> "$run_script"
	
	bootloader_username="${image_bootloader_username}"
	# shellcheck disable=SC2169
	bootloader_hashed_password="\$(printf "%s\n%s" $image_bootloader_password $image_bootloader_password | LC_ALL=C grub-mkpasswd-pbkdf2 | awk '/hash of / {print \$NF}')"
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	
	# Create empty logfile
	:> $logfile
	
	EOF

  if [ -n "$use_ramdisk" ]; then
    cat <<-EOF >> "$run_script"
	ramdisk_dir="${ramdisk_directory}"
	image_full_filename="\$ramdisk_dir/\$image_filename"
	EOF
  else
    cat <<-'EOF' >> "$run_script"
	image_full_filename="$images_dir/$image_filename"
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	
	check_for_required_packages
	EOF

  if [ "$image_script_host_arch" = "all" ] || \
     [ "$image_script_host_arch" != "$image_arch" ]; then
    cat <<-'EOF' >> "$run_script"
	check_binfmt_packages
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	
	mkdir -p $images_dir
	EOF
}


#
# Create Dropbear authorized_keys file
#
setup_dropbear_authorized_keys() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Setup Dropbear authorized_keys file"
	{
	  echo $ssh_public_key \\
	    > /etc/dropbear/authorized_keys
	  chown root:root /etc/dropbear/authorized_keys
	  chmod 600 /etc/dropbear/authorized_keys
	}
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	# Debug
	{
	  write_debug_log "Dropbear authorized_keys contents:" 2
	  cat /etc/dropbear/authorized_keys >> "$logfile"
	}
	EOF
  fi
}


#
# Source additional definitions files
#
source_additional_definitions_files(){
  local _source_script

  # source e.g. cloud/defines, physical/defines, virtual/defines
  _source_script="$script_dir/definitions/$image_class/defines"
  if [ ! -f "$_source_script" ]; then
    error_message "Unable to source settings for $image_class (definitions/$image_class/defines)!"
  else
    . "$_source_script"
  fi

  # source e.g. cloud/aws/defines, physical/pc/defines, virtual/qemu/defines
  _source_script="$script_dir/definitions/$image_class/$image_class_subtype/defines"
  if [ ! -f "$_source_script" ]; then
    error_message "Unable to source settings for $class_type_description (definitions/$image_class/$image_class_subtype/defines)!"
  else
    . "$_source_script"
  fi

  if [ -z "$image_arch" ]; then
    if [ -n "$CADI_DEFAULT_ARCH" ] && \
       is_in_comma_list "$CADI_DEFAULT_ARCH" "$CADI_SUPPORTED_ARCHS"; then
      image_arch="$CADI_DEFAULT_ARCH"
    elif [ -n "$CADI_SUPPORTED_ARCHS" ]; then
      image_arch="$(first_entry_in_comma_list "$CADI_SUPPORTED_ARCHS")"
    else
      error_message "No archs defined for $class_type_description!"
    fi
  fi

  # source e.g. packages/aarch64-packages-defines,
  # packages/armv7-packages-defines, packages/x86-packages-defines,
  # packages/x86_64-packages-defines
  _source_script="$script_dir/lib/packages/$image_arch-packages-defines"
  if [ ! -f "$_source_script" ]; then
    error_message "Unable to source settings from $_source_script!"
  else
    . "$_source_script"
  fi

  # source e.g. cloud/x86_64-defines, physical/x86_64-defines, virtual/x86_64-defines
  _source_script="$script_dir/definitions/$image_class/$image_arch-defines"
  if [ ! -f "$_source_script" ]; then
    error_message "Unable to source settings for $image_class using arch $image_arch ($_source_script)!"
  else
    . "$_source_script"
  fi

  # source e.g. cloud/x86_64-normal-defines, physical/x86_64-normal-defines, virtual/x86_64-normal-defines
  _source_script="$script_dir/definitions/$image_class/$image_arch-$(if [ -n "$image_barebones" ]; then echo "barebones"; else echo "normal"; fi)-defines"
  if [ ! -f "$_source_script" ]; then
    error_message "Unable to source settings for $image_class using arch $image_arch ($_source_script)!"
  else
    . "$_source_script"
  fi

  if is_in_comma_list "$image_arch" "$CADI_SUPPORTED_ARCHS"; then
    # source e.g. cloud/aws/x86_64-defines, physical/pc/x86_64-defines, virtual/qemu/x86_64-defines
    _source_script="$script_dir/definitions/$image_class/$image_class_subtype/$image_arch-defines"
    if [ ! -f "$_source_script" ]; then
      error_message "Unable to source settings for $class_type_description for arch $image_arch ($_source_script)!"
    else
      . "$_source_script"
    fi
  else
    error_message "Arch $image_arch is not supported for $class_type_description"
  fi
}
