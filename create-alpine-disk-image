#!/bin/sh -u
# shellcheck disable=SC1117
#
#############################################################################
##
##  create-alpine-disk-image
##
##  Version 0.2
##
##  Copyright 2021 Dermot Bradley <dermot_bradley@yahoo.com>
##
##  Licensed via GPL version 2.0
##
#############################################################################
##
##  This script must be run as root user.
##
#############################################################################

TMPDIR="/var/tmp"

DEFAULT_ALPINE_RELEASE="edge"
DEFAULT_APK_STATIC_VERSION="2.10.4"
DEFAULT_APK_STATIC_URL="https://github.com/alpinelinux/apk-tools/releases/download/v${DEFAULT_APK_STATIC_VERSION}"
DEFAULT_ARCH="x86_64"
DEFAULT_BOOT_REFERENCE="uuid"
DEFAULT_CONSOLE_NAME="tty1"
DEFAULT_KEYMAP="us us"
DEFAULT_LOCALE="en_US"
DEFAULT_LUKS_PASSPHRASE="test"
DEFAULT_MIRROR_SITE="https://alpine.global.ssl.fastly.net/alpine/"
DEFAULT_USER_PASSWORD="changeme"
DEFAULT_ROOTFS_LABEL="alpine-rootfs"
DEFAULT_SERIAL_PORT_NUMBER="0"
DEFAULT_SERIAL_PORT_NAME="ttyS${DEFAULT_SERIAL_PORT_NUMBER}"
DEFAULT_SERIAL_PORT_SPEED="115200"
DEFAULT_USERNAME="alpine"

DEFAULT_CHROOT_DIRECTORY="./chroot"
DEFAULT_IMAGES_DIRECTORY="./alpine-images"
DEFAULT_RAMDISK_DIRECTORY="./ramdisk"
RAMDISK_SIZE=3G

# Size in MiB
CIDATA_PART_SIZE="8"
###RPI_BOOT_PART_SIZE="128"
RPI_BOOT_PART_SIZE="64"
UEFI_PART_SIZE="128"

CLOUD_ROOT_PART_SIZE=270
PHYSICAL_ROOT_PART_SIZE=350
RPI_ROOT_PART_SIZE=220
VIRTUAL_ROOT_PART_SIZE=270

#############################################################################
##		Functions
#############################################################################


#
#
#
add_additional_init_d() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Adding additional init.d scripts"
{
  rc-update add rngd boot
  rc-update add rsyslog boot

  rc-update add chronyd default
  rc-update add sshd default
EOF

  if [ "$IMAGE_CLASS" = "vm" ]; then
    case $VM_TYPE in

      libvirtd | qemu )
        cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

  rc-update add qemu-guest-agent default
EOF
        ;;

      virtualbox )
        cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

  rc-update add virtualbox-guest-additions default
EOF
        ;;

      vmware )
        cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

  rc-update add open-vm-tools default
EOF
        ;;

    esac
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
} >> \$LOGFILE
EOF

}


#
#
#
add_additional_repos() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Adding additional repos"

write_log "  Adding Community repo to /etc/apk/repositories"
cat <<-_SCRIPT_ >> /etc/apk/repositories
	$ALPINE_MIRROR_SITE/$IMAGE_ALPINE_RELEASE/community
	_SCRIPT_
EOF

  if [ "$IMAGE_ALPINE_RELEASE" = "edge" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Adding Testing repo to /etc/apk/repositories"
cat <<-_SCRIPT_ >> /etc/apk/repositories
	$ALPINE_MIRROR_SITE/$IMAGE_ALPINE_RELEASE/testing
	_SCRIPT_
EOF
  fi

  if [ -n "${LOCAL_ALPINE_REPOSITORY+x}" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Adding local repo to /etc/apk/repositories"
cat <<-_SCRIPT_ >> /etc/apk/repositories
	$LOCAL_ALPINE_REPOSITORY/$IMAGE_ALPINE_RELEASE
	_SCRIPT_
EOF
  fi

}


#
# Enable base Alpine init.d services
#
add_base_init_d() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Enable init.d scripts"
{
  rc-update add devfs sysinit
  rc-update add dmesg sysinit

  rc-update add bootmisc boot
  rc-update add hostname boot
EOF

  if [ "$IMAGE_CLASS" = "physical" ] && \
     [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
  rc-update add hwclock boot
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
  rc-update add modules boot
EOF

  if [ "$IMAGE_CLASS" != "physical" ] || \
     [ -z "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
  rc-update add osclock boot
EOF

  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
  rc-update add sysctl boot
  rc-update add swap boot
EOF

  if [ "$IMAGE_CLASS" = "physical" ] && \
     [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
  rc-update add swclock boot
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
  rc-update add urandom boot

  rc-update add crond default
  rc-update add networking default

  rc-update add killprocs shutdown
  rc-update add mount-ro shutdown
  rc-update add savecache shutdown
} >> \$LOGFILE
EOF

}


#
# Adds an entry to /etc/fstab file
#
add_fstab_entry() {

  local ENTRY_TYPE=$1
  local ENTRY_VALUE=$2
  local MOUNT_POINT=$3
  local FS_TYPE=$4
  local FS_OPTIONS=$5
  local ENTRY_LOG=$6

  if [ "$ENTRY_TYPE" = "BIND" ]; then
    local FS_OPTIONS="bind,${FS_OPTIONS}"
    local FS_PASSNO="0"
  elif [ "$MOUNT_POINT" = "/" ]; then
    local FS_PASSNO="1"
  else
    local FS_PASSNO="2"
  fi

  if [ "$ENTRY_TYPE" = "BIND" ] ||
     [ "$ENTRY_TYPE" = "DEVICE" ]; then
    FSTAB_ENTRY="${ENTRY_VALUE}"
  else
    FSTAB_ENTRY="${ENTRY_TYPE}=${ENTRY_VALUE}"
  fi
  FSTAB_ENTRY="${FSTAB_ENTRY}\t${MOUNT_POINT}\t${FS_TYPE}\t${FS_OPTIONS} 0 ${FS_PASSNO}"

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Add ${ENTRY_LOG} entry"
# shellcheck disable=SC2169
echo -e "${FSTAB_ENTRY}" >> /etc/fstab
EOF

}


#
# Adds an entry to the specified /etc/mkinitfs/features.d/*.modules file
#
add_initramfs_entry() {

  modules_file=$1
  modules_entry=$2

  if [ "${modules_entry%% *}" != "#" ]; then

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Add '${modules_entry}' entry to ${modules_file}.modules"
EOF

  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
cat <<-_SCRIPT_ >> /etc/mkinitfs/features.d/${modules_file}.modules
	$modules_entry
	_SCRIPT_
EOF

}


#
# Additional OS configuration
#
additional_os_configuration() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Doing additional OS configuration"

# FIXUP: stop update-ca-certificates displaying a warning
sed -i \
  -e 's|/etc/ssl/certs|/etc/ssl/certs 2>/dev/null|' \
  /etc/ca-certificates/update.d/certhash
EOF

  tighten_sshd_configuration

  if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
     [ "$IMAGE_ENCRYPTED" = "true" ]; then
    setup_crypttab
  fi

}


#
# Basic OS configuration
#
basic_os_configuration() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Doing basic OS configuration"

write_log "  Set the login messages to be 'vague'"
# shellcheck disable=SC2169
echo -e "\nWelcome\n\n" > /etc/issue
EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then

    # Cloud

    LOGIN_BANNER="Alpine $IMAGE_ARCH $CLOUD_TYPE Cloud server"

  elif [ "$IMAGE_CLASS" = "vm" ]; then

    # Virtual machine

    LOGIN_BANNER="Alpine $IMAGE_ARCH $VM_TYPE VM server"

  else

    # Physical machine

    case $PHYSICAL_TYPE in

      rpi2 | rpi3 | rpi4 )
        LOGIN_BANNER="Alpine $IMAGE_ARCH Raspberry Pi server"
        ;;

      pc )
        LOGIN_BANNER="Alpine $IMAGE_ARCH PC server"
        ;;

      * )
        LOGIN_BANNER=""
        ;;

    esac

  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
# shellcheck disable=SC2169
echo -e "\n\n$LOGIN_BANNER\n\n" > /etc/motd

write_log "  Set the keymap to '$IMAGE_KEYMAP'"
setup-keymap $IMAGE_KEYMAP >> "\$LOGFILE" 2>&1
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/profile.d/locale.sh /etc/profile.d/locale.sh-orig
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting locale to $IMAGE_LOCALE.UTF-8"
sed -i -E \
  -e 's/^(export LANG=)C.UTF-8/\1$IMAGE_LOCALE.UTF-8/' \
  /etc/profile.d/locale.sh
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff /etc/profile.d/locale.sh-orig /etc/profile.d/locale.sh \
    >> "$LOGFILE" \
    || true
  rm /etc/profile.d/locale.sh-orig

  cp /etc/rc.conf /etc/rc.conf-orig
}
EOF
  fi

  cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Fixup rc.conf so that keyboards and screens use Unicode"
sed -i -e 's/^#unicode="NO"/unicode="YES"/' /etc/rc.conf
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff /etc/rc.conf-orig /etc/rc.conf \
    >> "$LOGFILE" \
    || true
  rm /etc/rc.conf-orig
}
EOF
  fi

  if [ "$IMAGE_ALPINE_RELEASE" = "v3.13" ]; then
    COLOR_PROMPT_FILE="color_prompt"
  else
    COLOR_PROMPT_FILE="color_prompt.sh.disabled"
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Enable colour shell prompt"

cp \
  /etc/profile.d/${COLOR_PROMPT_FILE} \
  /etc/profile.d/color_prompt.sh

rmdir /media/floppy

write_log "  Set ipv6 kernel module to be loaded at boot"
cat <<-_SCRIPT_ > /etc/modules-load.d/ipv6.conf
	#
	# /etc/modules-load.d/ipv6.conf
	#

	ipv6
	_SCRIPT_
EOF

}


#
# Calculate size of the resultant disk image taking into account
# whether bootloader and cloud-init partitions are needed.
#
calculate_image_size() {
  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      # shellcheck disable=SC2003
      SIZE="$(expr ${UEFI_PART_SIZE} + ${CLOUD_ROOT_PART_SIZE})"
    else
      SIZE="$CLOUD_ROOT_PART_SIZE"
    fi
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical machine
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
        # shellcheck disable=SC2003
        SIZE="$(expr ${UEFI_PART_SIZE} + ${CIDATA_PART_SIZE} + ${PHYSICAL_ROOT_PART_SIZE})"
      else
        # shellcheck disable=SC2003
        SIZE="$(expr ${CIDATA_PART_SIZE} + ${PHYSICAL_ROOT_PART_SIZE})"
      fi
    else
      # Raspberry Pi
      # shellcheck disable=SC2003
      SIZE="$(expr ${RPI_BOOT_PART_SIZE} + ${CIDATA_PART_SIZE} + ${RPI_ROOT_PART_SIZE})"
    fi
  else
    # Virtual machine
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      # shellcheck disable=SC2003
      SIZE="$(expr ${UEFI_PART_SIZE} + ${VIRTUAL_ROOT_PART_SIZE})"
    else
      SIZE="$VIRTUAL_ROOT_PART_SIZE"
    fi
  fi

  echo "$SIZE"
}


#
# Check that the host OS has necessary packages installed for
# running user-mode QEMU via binfmt and that it is configured.
#
check_binfmt_packages() {
  arch=$1
  host_os=$(detect_host_os)

  case $host_os in

    alpine )
      REQUIRED_PACKAGES="qemu-openrc"
      case $arch in
        aarch64 )
          REQUIRED_PACKAGES="$REQUIRED_PACKAGES qemu-aarch64"
          ;;
        armv7 )
          REQUIRED_PACKAGES="$REQUIRED_PACKAGES qemu-arm"
          ;;
        x86 )
          REQUIRED_PACKAGES="$REQUIRED_PACKAGES qemu-x86"
          ;;
        x86_64 )
          REQUIRED_PACKAGES="$REQUIRED_PACKAGES qemu-x86_64"
          ;;
        * )
          echo "Unsupported archicture: $arch!"
          exit 1
          ;;
      esac
      if [ -n "$(apk info -q "$REQUIRED_PACKAGES" 1>/dev/null)" ]; then
        echo
        echo "The following Alpine packages need to be installed:"
        echo "  $REQUIRED_PACKAGES"
        echo
        exit 1
      fi
      ;;

    debian | ubuntu )
      REQUIRED_PACKAGES="binfmt-support qemu-user-static"
      if [ "$(dpkg-query -W -f='${Status}\n' "$REQUIRED_PACKAGES")" -ne 0 ]; then
        echo
        echo "The following packages need to be installed:"
        echo "  $REQUIRED_PACKAGES"
        echo
        exit 1
      fi
      ;;

    * )
      echo
      echo "Unsupported host OS!" 
      echo
      exit 1
      ;;

  esac

  # Is binfmt configured for this QEMU arch?
  case $arch in

    aarch64 )
      BINFMT_FILE="/proc/sys/fs/binfmt_misc/qemu-aarch64"
      ;;

    armv7 )
      BINFMT_FILE="/proc/sys/fs/binfmt_misc/qemu-arm"
      ;;

    x86 )
      BINFMT_FILE="/proc/sys/fs/binfmt_misc/qemu-x86"
      ;;

    x86_64 )
      BINFMT_FILE="/proc/sys/fs/binfmt_misc/qemu-x86_64"
      ;;

  esac
  if [ -e "$BINFMT_FILE" ]; then
    BINFMT_ARCH_ENABLED=$(head -1 /proc/sys/fs/binfmt_misc/qemu-aarch64)
    if [ "$BINFMT_ARCH_ENABLED" = "enabled" ]; then
      return
    else
      echo
      echo "Binfmt is not enabled for $arch"
      echo
      exit 1
    fi
  else
    echo
    echo "Binfmt and QEMU are not configured for $arch"
    echo
    exit 1
  fi
}


#
# Checks that the host OS has all necessary packages installed
#
check_required_packages() {
  host_os=$(detect_host_os)

  case $host_os in
    alpine )
      # Busybox losetup not suitable
      REQUIRED_PACKAGES="busybox e2fsprogs parted sudo util-linux"
      if [ -n "$(apk info -q "$REQUIRED_PACKAGES" 1>/dev/null)" ]; then
        echo
        echo "The following Alpine packages need to be installed:"
        echo "  $REQUIRED_PACKAGES"
        echo
        exit 1
      fi
      ;;
    debian | ubuntu )
      REQUIRED_PACKAGES="coreutils e2fsprogs mount parted sudo wget"
      if [ "$(dpkg-query -W -f='${Status}\n' "$REQUIRED_PACKAGES")" -ne 0 ]; then
        echo
        echo "The following packages need to be installed:"
        echo "  $REQUIRED_PACKAGES"
        echo
        exit 1
      fi
      ;;
    *)
      echo
      echo "Unsupported host OS!"
      echo
      exit 1
      ;;
  esac
}


#
# Configure Grub
#
configure_bootloader_grub() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Configuring Grub"

mkdir -p /boot/grub
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_debug_log "  Root fs partition device is $ROOT_PART_DEVICE"
write_debug_log "  Loopback device is $LOOP_DEVICE"
EOF
  fi

  cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Busybox's losetup is not suitable when installing Grub on a loopback
# device as it may truncate the name of the underlying filename.
write_log "  Installing util-linux package for losetup"
apk add --quiet util-linux
EOF

  if [ "$IMAGE_BOOT_REFERENCE" = "label" ]; then

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  cp /etc/grub.d/10_linux /etc/grub.d/10_linux-orig
	cp /usr/share/grub/grub-mkconfig_lib /usr/share/grub/grub-mkconfig_lib-orig
	cp /usr/sbin/grub-mkconfig /usr/sbin/grub-mkconfig-orig
}
EOF
    fi

    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Temporarily installing patch program"
apk add --quiet patch >> $LOGFILE

write_log "  Patching /etc/grub.d/10_linux"
cat <<-'_SCRIPT_' | patch /etc/grub.d/10_linux >> $LOGFILE
	--- /etc/grub.d/10_linux
	+++ /etc/grub.d/10_linux-label
	@@ -44,7 +44,8 @@
	 # the initrds that Linux uses don't like that.
	 case ${GRUB_DEVICE} in
	   /dev/loop/*|/dev/loop[0-9])
	-    GRUB_DEVICE=`losetup ${GRUB_DEVICE} | sed -e "s/^[^(]*(\([^)]\+\)).*/\1/"`
	+    # Work with both Busybox and util-linux versions of losetup
	+    GRUB_DEVICE=`losetup ${GRUB_DEVICE} | sed -e "s/^[^:]*: []0-9[\:]* [\(]*\([^)]\+\)[\)]*$/\1/"`
	   ;;
	 esac
	
	@@ -64,6 +65,10 @@
	   LINUX_ROOT_DEVICE=PARTUUID=${GRUB_DEVICE_PARTUUID}
	 else
	   LINUX_ROOT_DEVICE=UUID=${GRUB_DEVICE_UUID}
	+  GRUB_DEVICE_LABEL="$(blkid | grep "UUID=\"${GRUB_DEVICE_UUID}\"" | sed -e 's|^.* LABEL="||g' -e 's|".*||g' | head -1)"
	+  if [ "x${GRUB_ENABLE_LINUX_LABEL}" = "xtrue" ] ; then
	+    LINUX_ROOT_DEVICE=LABEL=${GRUB_DEVICE_LABEL}
	+  fi
	 fi
	
	 case x"$GRUB_FS" in
	_SCRIPT_

write_log "  Patching /usr/share/grub/grub-mkconfig_lib"
cat <<-'_SCRIPT_' | patch /usr/share/grub/grub-mkconfig_lib >> $LOGFILE
	--- grub-mkconfig_lib-stock
	+++ grub-mkconfig_lib-custom
	@@ -156,7 +156,9 @@
	   if [ "x$fs_hint" != x ]; then
	     echo "set root='$fs_hint'"
	   fi
	-  if fs_uuid="`"${grub_probe}" --device $@ --target=fs_uuid 2> /dev/null`" ; then
	+  if label="`${grub_probe} --device $@ --target=fs_label 2> /dev/null`" ; then
	+    echo "search --no-floppy --label --set=root ${label}"
	+  elif fs_uuid="`"${grub_probe}" --device $@ --target=fs_uuid 2> /dev/null`" ; then
	     hints="`"${grub_probe}" --device $@ --target=hints_string 2> /dev/null`" || hints=
	     echo "if [ x\$feature_platform_search_hint = xy ]; then"
	     echo "  search --no-floppy --fs-uuid --set=root ${hints} ${fs_uuid}"
	_SCRIPT_

write_log "  Patching /usr/sbin/grub-mkconfig"
cat <<-'_SCRIPT_' | patch /usr/sbin/grub-mkconfig >> $LOGFILE
	--- grub-mkconfig-stock
	+++ grub-mkconfig-custom
	@@ -135,10 +135,12 @@
	 GRUB_DEVICE="`${grub_probe} --target=device /`"
	 GRUB_DEVICE_UUID="`${grub_probe} --device ${GRUB_DEVICE} --target=fs_uuid 2> /dev/null`" || true
	 GRUB_DEVICE_PARTUUID="`${grub_probe} --device ${GRUB_DEVICE} --target=partuuid 2> /dev/null`" || true
	+GRUB_DEVICE_LABEL="`${grub_probe} --device ${GRUB_DEVICE} --target=fs_label 2> /dev/null`" || true
	 
	 # Device containing our /boot partition.  Usually the same as GRUB_DEVICE.
	 GRUB_DEVICE_BOOT="`${grub_probe} --target=device /boot`"
	 GRUB_DEVICE_BOOT_UUID="`${grub_probe} --device ${GRUB_DEVICE_BOOT} --target=fs_uuid 2> /dev/null`" || true
	+GRUB_DEVICE_BOOT_LABEL="`${grub_probe} --device ${GRUB_DEVICE_BOOT} --target=fs_label 2> /dev/null`" || true
	 
	 # Filesystem for the device containing our userland.  Used for stuff like
	 # choosing Hurd filesystem module.
	@@ -190,8 +192,10 @@
	 export GRUB_DEVICE \
	   GRUB_DEVICE_UUID \
	   GRUB_DEVICE_PARTUUID \
	+  GRUB_DEVICE_LABEL \
	   GRUB_DEVICE_BOOT \
	   GRUB_DEVICE_BOOT_UUID \
	+  GRUB_DEVICE_BOOT_LABEL \
	   GRUB_FS \
	   GRUB_FONT \
	   GRUB_PRELOAD_MODULES \
	@@ -226,6 +230,7 @@
	   GRUB_SERIAL_COMMAND \
	   GRUB_DISABLE_LINUX_UUID \
	   GRUB_DISABLE_LINUX_PARTUUID \
	+  GRUB_ENABLE_LINUX_LABEL \
	   GRUB_DISABLE_RECOVERY \
	   GRUB_VIDEO_BACKEND \
	   GRUB_GFXMODE \
	_SCRIPT_

write_log "  Uninstalling patch program"
apk del --quiet patch >> $LOGFILE
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
	write_debug_log "  Diff 10_linux:"
  diff -aur /etc/grub.d/10_linux-orig /etc/grub.d/10_linux \
    >> \$LOGFILE \
    || true
  rm /etc/grub.d/10_linux-orig

  write_debug_log "  Diff grub-mkconfig_lib:"
  diff -aur \
    /usr/share/grub/grub-mkconfig_lib-orig /usr/share/grub/grub-mkconfig_lib \
  	>> \$LOGFILE \
  	|| true
  rm /usr/share/grub/grub-mkconfig_lib-orig

  write_debug_log "  Diff grub-mkconfig:"
 diff -aur \
    /usr/sbin/grub-mkconfig-orig /usr/sbin/grub-mkconfig \
  	>> \$LOGFILE \
  	|| true
  rm /usr/sbin/grub-mkconfig-orig

}
EOF
    fi

  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/default/grub /etc/default/grub-orig
EOF
  fi

  cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Update /etc/default/grub"
KERNEL_OPTS="rootfstype=ext4"
EOF

  if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
     [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # Add root entry pointing to LUKS
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS modules=crypto_simd,dm-crypt"
KERNEL_OPTS="\$KERNEL_OPTS root=/dev/mapper/cryptroot"
KERNEL_OPTS="\$KERNEL_OPTS cryptroot=UUID=${LUKS_PART_UUID}"
KERNEL_OPTS="\$KERNEL_OPTS cryptdm=cryptroot"
KERNEL_OPTS="\$KERNEL_OPTS cryptkey"
EOF
  fi

  if [ -z "${DISABLE_CONSOLE+x}" ]; then
    # Normal console
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
    KERNEL_OPTS="\$KERNEL_OPTS console=${CONSOLE_NAME}"
EOF
  fi

  if [ -n "${SERIAL_CONSOLE+x}" ]; then
    # Serial console
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS console=${SERIAL_PORT_NAME},${SERIAL_PORT_SPEED}"
EOF
  fi

  if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    # With BIOS can disable graphics as "standard" VGA provides text output
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS nomodeset"
EOF
  fi

  if [ "$IMAGE_DISABLE_IPV6" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
KERNEL_OPTS="$KERNEL_OPTS ipv6.disable=1"
EOF
  fi

  cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
KERNEL_OPTS="$KERNEL_OPTS quiet"

sed -i \
  -e 's|^GRUB_DISABLE_RECOVERY=.*$|GRUB_DISABLE_RECOVERY=false|g' \
  -e 's|^GRUB_TIMEOUT=.*$|GRUB_TIMEOUT=5|g' \
  /etc/default/grub

{
  echo "GRUB_CMDLINE_LINUX_DEFAULT=\"$KERNEL_OPTS\""
EOF

  if [ "$IMAGE_BOOT_REFERENCE" = "label" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	echo 'GRUB_ENABLE_LINUX_LABEL=true'
EOF
  else
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
  echo 'GRUB_ENABLE_LINUX_LABEL=false'
EOF
  fi

  cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
  echo 'GRUB_DISABLE_OS_PROBER=true'
  echo 'GRUB_GFXPAYLOAD_LINUX=text'
  echo 'GRUB_RECORDFAIL_TIMEOUT=20'
} >> /etc/default/grub

if ! grep -q "^GRUB_TERMINAL=" /etc/default/grub; then
  echo 'GRUB_TERMINAL=console' >> /etc/default/grub
fi
EOF

  if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
     [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

echo 'GRUB_ENABLE_CRYPTODISK=y' >> /etc/default/grub
echo 'GRUB_PRELOAD_MODULES="cryptodisk gcry_rijndael gcry_sha256 luks"' \
  >> /etc/default/grub
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

####chmod g=,o= /etc/default/grub

{
  # Debug
  diff /etc/default/grub-orig /etc/default/grub \
    >> $LOGFILE \
    || true
  rm /etc/default/grub-orig

  # Fudge
  sed -i -e 's|^set -e$|set -ex|' /usr/sbin/grub-mkconfig
}
EOF
  fi

  cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Generating GRUB config"
grub-mkconfig -o /boot/grub/grub.cfg >> $LOGFILE 2>&1
EOF

  cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Checking GRUB config"
grub-script-check /boot/grub/grub.cfg >> $LOGFILE

chmod g=,o= /boot/grub/grub.cfg
EOF

}


#
# Setup the config files used by Raspberry Pi bootloader
#
configure_bootloader_rpi() {

  CMDLINE="root=$RPI_ROOT_DEVICE"
	CMDLINE="$CMDLINE rootfstype=ext4 modules=sd-mod,usb-storage"
  if [ "$IMAGE_DISABLE_IPV6" = "true" ]; then
	  CMDLINE="$CMDLINE ipv6.disable=1"
	fi
  CMDLINE="$CMDLINE console=${CONSOLE_NAME} quiet"

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Create RPI bootloader configuration"

write_log "  Creating /boot/cmdline.txt"
cat <<-_SCRIPT_ > /boot/cmdline.txt
	$CMDLINE
	_SCRIPT_

write_log "  Creating /boot/config.txt"
cat <<-_SCRIPT_ > /boot/config.txt
EOF

  if [ "$PHYSICAL_TYPE" != "rpi4" ]; then
	  # RPI 2 or RPI 3
	  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	[pi2]
	kernel=vmlinuz-rpi
	initramfs initramfs-rpi
	[pi3]
	kernel=vmlinuz-rpi
	initramfs initramfs-rpi
	[pi3+]
	kernel=vmlinuz-rpi
	initramfs initramfs-rpi
EOF

  else
	  # RPI 4
	  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	[pi4]
	enable_gic=1
	kernel=vmlinuz-rpi4
	initramfs initramfs-rpi4
EOF

  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	[all]
EOF

  if [ "$IMAGE_ARCH" = "aarch64" ]; then
	  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	arm_64bit=1
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	# Set GPU memory to 16MB when using cutdown bootloader
	gpu_mem=16
	include usercfg.txt
	_SCRIPT_

write_log "  Creating /boot/usercfg.txt"
cat <<-_SCRIPT_ > /boot/usercfg.txt
EOF

  if [ "$PHYSICAL_TYPE" != "rpi4" ]; then
	  # RPI 2 or RPI 3
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	fixup_file=fixup_cd.dat
	start_file=start_cd.elf
	_SCRIPT_
EOF
  else
	  # RPI 4
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	fixup_file=fixup4cd.dat
	start_file=start4cd.elf
	_SCRIPT_
EOF
	fi

}


#
# Configure Syslinux
#
configure_bootloader_syslinux() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Configuring Syslinux"

mkdir -p /boot
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/update-extlinux.conf /etc/update-extlinux.conf-orig
EOF
  fi

  cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Update update-extlinux.conf"
KERNEL_OPTS="rootfstype=ext4"
EOF

  if [ -z "${DISABLE_CONSOLE+x}" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS console=${CONSOLE_NAME}"
EOF
  fi

  if [ -n "${SERIAL_CONSOLE+x}" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS console=${SERIAL_PORT_NAME},${SERIAL_PORT_SPEED}"
EOF
  fi

  if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS nomodeset"
EOF
  fi

  if [ "$IMAGE_DISABLE_IPV6" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS ipv6.disable=1"
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS quiet"

sed -i \
  -e 's|^overwrite=(.*)\$|overwrite=1|g' \
  -e "s|^default_kernel_opts=.*\$|default_kernel_opts=\"\$KERNEL_OPTS\"|g" \
  -e 's|^modules=.*\$|modules=ext4|g' \
  -e 's|^hidden=.*\$|hidden=0|g' \
  -e 's|^timeout=.*\$|timeout=3|g' \
  /etc/update-extlinux.conf
EOF

  if [ "$IMAGE_BOOT_REFERENCE" = "label" ]; then
	  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
# Use LABELs to refer to filesystems
sed -i \
  -e 's|^root=.*\$|root=LABEL=$DEFAULT_ROOTFS_LABEL|g' \
  /etc/update-extlinux.conf
EOF
  else
	  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
# Use UUIDs to refer to filesystems
sed -i \
  -e "s|^root=.*\$|root=UUID=$ROOT_FS_UUID|g" \
  /etc/update-extlinux.conf
EOF
	fi

  if [ -n "${SERIAL_CONSOLE+x}" ] && \
     [ "$SERIAL_CONSOLE" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Enable serial console

EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

chmod g=,o= /etc/update-extlinux.conf
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  write_debug_log "  diff update-extlinux.conf"
  diff /etc/update-extlinux.conf-orig /etc/update-extlinux.conf \
    >> \$LOGFILE \
    || true
  rm /etc/update-extlinux.conf-orig

  write_debug_log "  update-extlinux.conf contents:"
  cat /etc/update-extlinux.conf >> \$LOGFILE
}
EOF
  fi

}


#
# Place entries in /etc/fstab for various filesystems
#
configure_fstab() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Add /etc/fstab entries"

EOF

  if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
     [ "$IMAGE_ENCRYPTED" = "true" ]; then
    add_fstab_entry DEVICE "/dev/mapper/cryptroot" "/" "ext4" "rw,relatime" "rootfs"
  else
    case $IMAGE_BOOT_REFERENCE in
      label )
        add_fstab_entry LABEL "$DEFAULT_ROOTFS_LABEL" "/" "ext4" "rw,relatime" "rootfs"
        ;;
      * )
        add_fstab_entry UUID "$ROOT_FS_UUID" "/" "ext4" "rw,relatime" "rootfs"
        ;;
    esac
  fi

	if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    local MOUNTPOINT="/efi"

    case $IMAGE_BOOT_REFERENCE in
      label )
        add_fstab_entry LABEL "SYSTEM_EFI" "${MOUNTPOINT}" "vfat" "rw" "ESP filesystem"
        ;;
		  *)
        add_fstab_entry UUID "$ESP_FS_UUID" "${MOUNTPOINT}" "vfat" "rw" "ESP filesystem"
        ;;
		esac

    if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
      add_fstab_entry BIND "/efi/EFI/BOOT" "/boot" "none" "rw,relatime" "/boot ESP bind-mount"
    fi

	fi

  if [ "$IMAGE_CLASS" = "physical" ] && \
	   [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then

    # RPI 2, 3, or 4

    if [ "$IMAGE_BOOT_REFERENCE" = "label" ]; then
      add_fstab_entry LABEL "boot" "/media/sdcard" "vfat" "rw,relatime" "/media/sdcard"
    else
      add_fstab_entry UUID "$RPI_BOOT_FS_UUID" "/media/sdcard" "vfat" "rw,relatime" "/media/sdcard"
		fi

    add_fstab_entry BIND "/media/sdcard" "/boot" "none" "rw,relatime" "/boot bind-mount"

#    if [ "$PHYSICAL_TYPE" = "rpi4" ]; then
#      # RPI4
#			cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
#write_log "  Add /boot/dtbs-rpi4 bind-mount entry"
## shellcheck disable=SC2169
#echo -e "/boot\\t\\t/boot/dtbs-rpi4\\tnone\\tbind,rw,relatime 0 0" >> /etc/fstab
#EOF
#
#    else
#			
#			if [ "$IMAGE_ARCH" = "aarch64" ]; then
#        # aarch64 RPI 2 or RPI 3
#      	cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
#
#write_log "  Add /boot/dtbs-rpi bind-mount entry"
## shellcheck disable=SC2169
#echo -e "/boot\\t\\t/boot/dtbs-rpi\\tnone\\tbind,rw,relatime 0 0" >> /etc/fstab
#EOF
#      else
#		  	# armv7 RPI 2 or RPI 3
#        cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
#
#write_log "  Add /boot/dtbs-rpi2 bind-mount entry"
## shellcheck disable=SC2169
#echo -e "/boot\\t\\t/boot/dtbs-rpi2\\tnone\\tbind,rw,relatime 0 0" >> /etc/fstab
#EOF
#			fi
#
#		fi
#
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  write_debug_log "  Resultant /etc/fstab contents:"
  cat /etc/fstab >> "\$LOGFILE"
}
EOF
  fi

}


#
# Configure mkinitfs so that only the modules necessary for the relevant
# image type are placed in the initramfs file.
#
configure_mkinitfs() {
  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Configuring mkinitfs"

write_log "  Setting up mkinitfs.conf"
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/mkinitfs/mkinitfs.conf /etc/mkinitfs/mkinitfs.conf-orig
EOF
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then

    # Cloud

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

FEATURES="base"
EOF

    if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
       [ "$IMAGE_ENCRYPTED" = "true" ]; then
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES cryptkey cryptsetup"
EOF
    elif [ -n "${IMAGE_ENCRYPT_REMOTE_UNLOCK+x}" ] && \
         [ "$IMAGE_ENCRYPT_REMOTE_UNLOCK" = "true" ]; then
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES cryptsetup dropbear"
EOF
    fi

    if [ "$CLOUD_TYPE" = "aws" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # AWS
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
# For AWS
FEATURES="\$FEATURES ena"
EOF
    fi

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES ext4 keymap kms"
EOF

    if [ -n "${IMAGE_LVM_ROOTFS+x}" ] && \
       [ "$IMAGE_LVM_ROOTFS" = "true" ]; then
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES lvm"
EOF
    fi

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES network"
EOF

    if [ "$CLOUD_TYPE" = "aws" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # AWS
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
# For AWS
FEATURES="\$FEATURES nvme"
EOF
    fi

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES virtio"
EOF

  elif [ "$IMAGE_CLASS" = "physical" ]; then

    # Physical machine

    if [ "$PHYSICAL_TYPE" = "pc" ]; then

      # x86 or x86_64 PC

      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

FEATURES="ata base"
EOF

      if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
         [ "$IMAGE_ENCRYPTED" = "true" ]; then
        cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES cryptkey cryptsetup"
EOF
      elif [ -n "${IMAGE_ENCRYPT_REMOTE_UNLOCK+x}" ] && \
           [ "$IMAGE_ENCRYPT_REMOTE_UNLOCK" = "true" ]; then
        cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES cryptsetup dropbear"
EOF
      fi

      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES ext4 keymap"
EOF

      if [ -n "${IMAGE_LVM_ROOTFS+x}" ] && \
         [ "$IMAGE_LVM_ROOTFS" = "true" ]; then
        cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES lvm"
EOF
      fi

      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES network nvme scsi usb"
EOF

    elif [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then

      # RPI 2, 3, or 4

      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

FEATURES="base"
EOF

      if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
         [ "$IMAGE_ENCRYPTED" = "true" ]; then
        cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES cryptsetup"
EOF
      elif [ -n "${IMAGE_ENCRYPT_REMOTE_UNLOCK+x}" ] && \
           [ "$IMAGE_ENCRYPT_REMOTE_UNLOCK" = "true" ]; then
        cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES cryptsetup dropbear"
EOF
      fi

      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES ext4 keymap kms"
EOF

      if [ -n "${IMAGE_LVM_ROOTFS+x}" ] && \
         [ "$IMAGE_LVM_ROOTFS" = "true" ]; then
         cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES lvm"
EOF
      fi

      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES mmc network usb"
EOF

    fi

  elif [ "$IMAGE_CLASS" = "vm" ]; then

    # Virtual Machine

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

FEATURES="base"
EOF

    if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
       [ "$IMAGE_ENCRYPTED" = "true" ]; then
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES cryptkey cryptsetup"
EOF
    elif [ -n "${IMAGE_ENCRYPT_REMOTE_UNLOCK+x}" ] && \
         [ "$IMAGE_ENCRYPT_REMOTE_UNLOCK" = "true" ]; then
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES cryptsetup dropbear"
EOF
    fi

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES ext4 keymap kms"
EOF

    if [ -n "${IMAGE_LVM_ROOTFS+x}" ] && \
       [ "$IMAGE_LVM_ROOTFS" = "true" ]; then
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES lvm"
EOF
    fi

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
FEATURES="\$FEATURES network scsi virtio"
EOF

  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
  
if [ -z "\${FEATURES+x}" ]; then
  write_log "  Empty features list - something went wrong!"
  exit 1
fi
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
write_debug_log "  mkinitfs features list is: \$FEATURES"
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
sed -i \
  -e "s|^features=\".*\"|features=\"\$FEATURES\"|" \
  /etc/mkinitfs/mkinitfs.conf
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/mkinitfs.conf-orig \
    /etc/mkinitfs/mkinitfs.conf \
    >> \$LOGFILE \
    || true

  cp /etc/mkinitfs/features.d/ata.modules \
    /etc/mkinitfs/features.d/ata.modules-orig
}
EOF
  fi

  # ata.modules

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting up features.d/ata.modules"

:> /etc/mkinitfs/features.d/ata.modules
EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "ata" "# This file is empty for Cloud machines"
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical machine
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      # x86 or x86_64 PC
      add_initramfs_entry "ata" "kernel/drivers/ata/ahci.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/ahci_platform.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/ata_generic.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/ata_piix.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/libahci.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/libahci_platform.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/libata.ko"
    elif [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then
      # RPI 2, 3, or 4
      add_initramfs_entry "ata" "# This file is empty for Raspberry Pi machines"
    fi
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual Machine
    add_initramfs_entry "ata" "# This file is empty for Virtual machines"
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/ata.modules-orig \
    /etc/mkinitfs/features.d/ata.modules \
    >> "$LOGFILE" \
    || true
  rm /etc/mkinitfs/features.d/ata.modules-orig

  cp /etc/mkinitfs/features.d/base.modules \
    /etc/mkinitfs/features.d/base.modules-orig
}
EOF
  fi

  # base.modules

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting up features.d/base.modules"

:> /etc/mkinitfs/features.d/base.modules
EOF

  if [ "$IMAGE_ARCH" != "aarch86" ] || \
     [ "$IMAGE_TYPE" != "vm" ]; then
    # jitterentropy_rng is a module for all machines except for
    # aarch64 VMs where it is compiled into the linux-virt kernel.
    add_initramfs_entry "base" "kernel/crypto/jitterentropy_rng.ko"
  fi

  if [ "$IMAGE_ARCH" = "aarch64" ]; then
    if [ "$IMAGE_CLASS" = "cloud" ] || \
       [ "$IMAGE_CLASS" = "vm" ]; then
      # aarch64 Cloud and Virtual machines
      add_initramfs_entry "base" "kernel/drivers/acpi/button.ko"
    fi
  fi

  if [ "$IMAGE_ARCH" = "x86" ] || \
     [ "$IMAGE_ARCH" = "x86_64" ]; then
    # all x86 and x86_64 machines
    add_initramfs_entry "base" "kernel/drivers/acpi/button.ko"
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/base.modules-orig \
    /etc/mkinitfs/features.d/base.modules \
    >> "$LOGFILE" \
    || true
  rm /etc/mkinitfs/features.d/base.modules-orig
}
EOF
  fi

  if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
     [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # cryptkey.files

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/cryptkey.files \
    /etc/mkinitfs/features.d/cryptkey.files-orig
EOF
    fi

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting up features.d/cryptkey.files"
echo "/etc/crypttab" \
  >> /etc/mkinitfs/features.d/cryptkey.files
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/cryptkey.files-orig \
    /etc/mkinitfs/features.d/cryptkey.files \
    >> "$LOGFILE" \
    || true
  rm /etc/mkinitfs/features.d/cryptkey.files-orig
}
EOF
    fi

  fi

  if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
     [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # cryptsetup.modules

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/cryptsetup.modules \
    /etc/mkinitfs/features.d/cryptsetup.modules-orig
EOF
    fi

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting up features.d/cryptsetup.modules"

:> /etc/mkinitfs/features.d/cryptsetup.modules
EOF

    case $IMAGE_ARCH in
      aarch64 )
        add_initramfs_entry "cryptsetup" "kernel/arch/arm64/crypto/aes-arm64.ko"
        add_initramfs_entry "cryptsetup" "kernel/arch/arm64/crypto/sha256-arm64.ko"
        if [ "$IMAGE_CLASS" = "cloud" ]; then
          # Add Arm Crypto Extension modules for ARM64 servers
          add_initramfs_entry "cryptsetup" "kernel/arch/arm64/crypto/*-ce*.ko"
        fi

        ;;
      x86 | x86_64 )
        add_initramfs_entry "cryptsetup" "kernel/arch/x86/crypto/aesni-intel.ko"
        add_initramfs_entry "cryptsetup" "kernel/arch/x86/crypto/sha256-ssse3.ko"
        #add_initramfs_entry "cryptsetup" "kernel/arch/x86/crypto/*"
        ;;
    esac
    add_initramfs_entry "cryptsetup" "kernel/crypto/*"
    add_initramfs_entry "cryptsetup" "kernel/crypto/essiv.ko"
    add_initramfs_entry "cryptsetup" "kernel/drivers/md/dm-crypt.ko"

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/cryptsetup.modules-orig \
    /etc/mkinitfs/features.d/cryptsetup.modules \
    >> "$LOGFILE" \
    || true
  rm /etc/mkinitfs/features.d/cryptsetup.modules-orig
}
EOF
    fi
  fi

  # kms.modules

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/kms.modules \
  /etc/mkinitfs/features.d/kms.modules-orig
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting up features.d/kms.modules"

:> /etc/mkinitfs/features.d/kms.modules
EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then

    # Cloud
    add_initramfs_entry "kms" "kernel/drivers/gpu/drm/virtio"

    if [ "$CLOUD_TYPE" = "azure" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # Azure
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/hyperv_fb.ko"
    fi

  elif [ "$IMAGE_CLASS" = "physical" ]; then

    # Physical machine

    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      # x86 or x86_64 PC
      add_initramfs_entry "kms" "kernel/drivers/char/agp/agpgart.ko"
      add_initramfs_entry "kms" "kernel/drivers/char/agp/amd64-agp.ko"
      add_initramfs_entry "kms" "kernel/drivers/char/agp/intel-agp.ko"
      add_initramfs_entry "kms" "kernel/drivers/char/agp/intel-gtt.ko"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/amd"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/gma500"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/i2c"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/i915"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/nouveau"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/radeon"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/scheduler"
      add_initramfs_entry "kms" "kernel/drivers/i2c/busses/i2c-amd*.ko"
      add_initramfs_entry "kms" "kernel/drivers/i2c/busses/i2c-piix4.ko"
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/aty/radeonfb.ko"
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/intelfb"
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/nvidia"
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/uvesafb.ko"
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/vga16fb.ko"
    elif [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then
      # RPI 2, 3, or 4
      add_initramfs_entry "kms" "# kernel/drivers/gpu"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/vc4/vc4.ko"
      add_initramfs_entry "kms" "kernel/drivers/i2c"
    fi

  elif [ "$IMAGE_CLASS" = "vm" ]; then

    # Virtual Machine

    if [ "$VM_TYPE" = "hyperv" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # Hyper-V
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/hyperv_fb.ko"
    fi

    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "qemu" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # libvirtd / QEMU
      #add_initramfs_entry "kms" "kernel/drivers/gpu/drm/drm.ko"
      #add_initramfs_entry "kms" "kernel/drivers/gpu/drm/drm_kms_helper.ko"
      #add_initramfs_entry "kms" "kernel/drivers/gpu/drm/drm_panel_orientation_quirks.ko"
      #add_initramfs_entry "kms" "kernel/drivers/gpu/drm/drm_ttm_helper.ko"
      #add_initramfs_entry "kms" "kernel/drivers/gpu/drm/drm_vram_helper.ko"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/bochs/bochs-drm.ko"
      #add_initramfs_entry "kms" "kernel/drivers/gpu/drm/ttm"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/virtio"
    fi

    if [ "$VM_TYPE" = "virtualbox" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # Virtualbox
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/vboxvideo/vboxvideo.ko"
    fi

  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/kms.modules-orig \
    /etc/mkinitfs/features.d/kms.modules \
    >> "$LOGFILE" \
    || true
  rm /etc/mkinitfs/features.d/kms.modules-orig
}
EOF
  fi

  if [ -n "${IMAGE_LVM_ROOTFS+x}" ] && \
     [ "$IMAGE_LVM_ROOTFS" = "true" ]; then

    # lvm.modules

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/lvm.modules \
    /etc/mkinitfs/features.d/lvm.modules-orig

EOF
    fi

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting up features.d/lvm.modules"

:> /etc/mkinitfs/features.d/lvm.modules
EOF

    add_initramfs_entry "lvm" "kernel/drivers/md/dm-mod.ko"
    add_initramfs_entry "lvm" "kernel/drivers/md/dm-snapshot.ko"
    add_initramfs_entry "lvm" "kernel/drivers/md/dm-thin-pool.ko"

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/lvm.modules-orig \
    /etc/mkinitfs/features.d/lvm.modules \
    >> "$LOGFILE" \
    || true
  rm /etc/mkinitfs/features.d/lvm.modules-orig
}
EOF
    fi
  fi

  # network.modules

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/network.modules \
  /etc/mkinitfs/features.d/network.modules-orig
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting up features.d/network.modules"

:> /etc/mkinitfs/features.d/network.modules
EOF

  add_initramfs_entry "network" "kernel/net/packet/af_packet.ko"

  if [ "$IMAGE_CLASS" = "cloud" ]; then

    # Cloud
    add_initramfs_entry "network" "kernel/drivers/net/virtio_net.ko"
    add_initramfs_entry "network" "kernel/drivers/virtio/virtio_pci.ko"

    if [ "$CLOUD_TYPE" = "aws" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # AWS
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/amazon/ena"
    fi

    if [ "$CLOUD_TYPE" = "azure" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # Azure
      add_initramfs_entry "network" "kernel/drivers/net/hyperv"
    fi

  elif [ "$IMAGE_CLASS" = "physical" ]; then

    # Physical machine

    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      # x86 or x86_64 PC
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/atheros/alx"
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/broadcom/tg3.ko"
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/e1000"
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/e1000e"
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/i40e"
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/ice"
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/igb"
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/igbvf"
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/igc"
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/ixgb"
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/ixgbe"
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/ixgbevf"
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/nvidia"
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/realtek/r8169.ko"
      add_initramfs_entry "network" "kernel/drivers/net/mii.ko"
      add_initramfs_entry "network" "kernel/drivers/net/phy/realtek.ko"
    elif [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then
      # RPI 2, 3, or 4
      add_initramfs_entry "network" "# No additions for Raspberry Pi machines"
    fi

  elif [ "$IMAGE_CLASS" = "vm" ]; then

    # Virtual machine

    if [ "$VM_TYPE" = "hyperv" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # Hyper-V
      add_initramfs_entry "network" "kernel/drivers/net/hyperv"
    fi

    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "qemu" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # libvirtd / QEMU
      add_initramfs_entry "network" "kernel/drivers/net/virtio_net.ko"
      ##add_initramfs_entry "network" "kernel/drivers/virtio/virtio_pci.ko"
    fi

    if [ "$VM_TYPE" = "virtualbox" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # Virtualbox
      add_initramfs_entry "network" "kernel/drivers/net/virtio_net.ko"
      ##add_initramfs_entry "network" "kernel/drivers/virtio/virtio_pci.ko"
    fi

    if [ "$VM_TYPE" = "vmware" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # VMware
      add_initramfs_entry "network" "kernel/drivers/net/vmxnet3"
    fi

  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/network.modules-orig \
    /etc/mkinitfs/features.d/network.modules \
    >> "$LOGFILE" \
    || true
  rm /etc/mkinitfs/features.d/network.modules-orig

  cp /etc/mkinitfs/features.d/nvme.modules \
    /etc/mkinitfs/features.d/nvme.modules-orig
}
EOF
  fi

  # nvme.modules

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting up features.d/nvme.modules"

:> /etc/mkinitfs/features.d/nvme.modules
EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then

    # Cloud

    if [ "$CLOUD_TYPE" = "aws" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # AWS
      add_initramfs_entry "nvme" "kernel/drivers/nvme/host/nvme.ko"
    else
      add_initramfs_entry "nvme" "# This file is empty for non-AWS Cloud machines"
    fi

  elif [ "$IMAGE_CLASS" = "physical" ]; then

    # Physical

    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      # x86 or x86_64 PC
      add_initramfs_entry "nvme" "kernel/drivers/nvme/host/nvme.ko"
    elif [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then
      # RPI 2, 3, or 4
      add_initramfs_entry "nvme" "# This file is empty for Raspberry Pi machines"
    fi

  elif [ "$IMAGE_CLASS" = "vm" ]; then

    # Virtual machine
    add_initramfs_entry "nvme" "# This file is empty for Virtual machines"

  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/nvme.modules-orig \
    /etc/mkinitfs/features.d/nvme.modules \
    >> "$LOGFILE" \
    || true
  rm /etc/mkinitfs/features.d/nvme.modules-orig

  cp /etc/mkinitfs/features.d/scsi.modules \
    /etc/mkinitfs/features.d/scsi.modules-orig
}
EOF
fi

  # scsi.modules

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting up features.d/scsi.modules"

:> /etc/mkinitfs/features.d/scsi.modules
EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "scsi" "kernel/drivers/scsi/scsi_mod.ko"
    add_initramfs_entry "scsi" "kernel/drivers/scsi/sd_mod.ko"
    ########add_initramfs_entry "scsi" "kernel/drivers/scsi/sr_mod.ko"
    add_initramfs_entry "scsi" "kernel/drivers/scsi/virtio_scsi.ko"
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      # x86 or x86_64 PC
      add_initramfs_entry "scsi" "kernel/drivers/scsi/scsi_mod.ko"
      add_initramfs_entry "scsi" "kernel/drivers/scsi/sd_mod.ko"
      add_initramfs_entry "scsi" "kernel/drivers/scsi/ses.ko"
      add_initramfs_entry "scsi" "kernel/drivers/scsi/sg.ko"
      #######add_initramfs_entry "scsi" "kernel/drivers/scsi/sr_mod.ko"
    elif [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then
      # RPI 2, 3, or 4
      add_initramfs_entry "scsi" "kernel/drivers/scsi/ses.ko"
    fi
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual machine
    add_initramfs_entry "scsi" "kernel/drivers/scsi/scsi_mod.ko"
    add_initramfs_entry "scsi" "kernel/drivers/scsi/sd_mod.ko"
    add_initramfs_entry "scsi" "kernel/drivers/scsi/virtio_scsi.ko"
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/scsi.modules-orig \
    /etc/mkinitfs/features.d/scsi.modules \
    >> "$LOGFILE" \
    || true
  rm /etc/mkinitfs/features.d/scsi.modules-orig

  cp /etc/mkinitfs/features.d/usb.modules \
    /etc/mkinitfs/features.d/usb.modules-orig
}
EOF
  fi

  # usb.modules

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting up features.d/usb.modules"

:> /etc/mkinitfs/features.d/usb.modules
EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "usb" "# This file is empty for Cloud machines"
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      # x86 or x86_64 PC
      add_initramfs_entry "usb" "kernel/drivers/usb/storage/uas.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/usbhid"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-generic.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-cherry.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-apple.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/ehci-hcd.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/ehci-pci.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/ehci-platform.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/ohci-hcd.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/ohci-pci.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/ohci-platform.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/uhci-hcd.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/xhci-hcd.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/xhci-pci.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/xhci-plat-hcd.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/storage/usb-storage.ko"
      add_initramfs_entry "usb" "kernel/fs/fat"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_cp*ko"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_iso8859*ko"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_utf8*ko"
    elif [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then
      # RPI 2, 3, or 4
      add_initramfs_entry "usb" "kernel/drivers/usb/storage/uas.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/usbhid"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-generic.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-cherry.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-apple.ko"
      add_initramfs_entry "usb" "kernel/fs/fat"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_cp*ko"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_iso8859*ko"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_utf8*ko"
    fi
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual machine
    add_initramfs_entry "usb" "# This file is empty for Virtual machines"
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/usb.modules-orig \
    /etc/mkinitfs/features.d/usb.modules \
    >> "$LOGFILE" \
    || true
  rm /etc/mkinitfs/features.d/usb.modules-orig

  cp /etc/mkinitfs/features.d/virtio.modules \
    /etc/mkinitfs/features.d/virtio.modules-orig
}
EOF
  fi

  # virtio.modules

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting up features.d/virtio.modules"

:> /etc/mkinitfs/features.d/virtio.modules
EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "virtio" "kernel/drivers/char/virtio_console.ko"
    add_initramfs_entry "virtio" "kernel/drivers/char/hw_random/virtio-rng.ko"
    add_initramfs_entry "virtio" "kernel/drivers/crypto/virtio*"
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    add_initramfs_entry "virtio" "# This file is empty for Physical machines"
  elif [ "$IMAGE_CLASS" = "vm" ]; then

    # Virtual machine

    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "qemu" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # libvirtd / QEMU
      add_initramfs_entry "virtio" "kernel/drivers/block/virtio_blk.ko"
      add_initramfs_entry "virtio" "kernel/drivers/char/virtio_console.ko"
      add_initramfs_entry "virtio" "kernel/drivers/char/hw_random/virtio-rng.ko"
      add_initramfs_entry "virtio" "kernel/drivers/virtio"
    fi

    if [ "$VM_TYPE" = "virtualbox" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # Virtualbox
      add_initramfs_entry "virtio" "kernel/drivers/virt/vboxguest/vboxguest.ko"
      add_initramfs_entry "virtio" "kernel/drivers/virtio/virtio.ko"
      add_initramfs_entry "virtio" "kernel/drivers/virtio/virtio_pci.ko"
      add_initramfs_entry "virtio" "kernel/drivers/virtio/virtio_ring.ko"
    fi

  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/virtio.modules-orig \
    /etc/mkinitfs/features.d/virtio.modules \
    >> "$LOGFILE" \
    || true
  rm /etc/mkinitfs/features.d/virtio.modules-orig

  # Fudge
  sed -i -e 's|^set -e$|set -ex|' /sbin/mkinitfs
}
EOF
  fi

}


#
# Copy LUKS keyfile into place
#
copy_luks_keyfile_into_place() {
  write_log "  Moving LUKS keyfile into chroot directory"
  mv crypto_keyfile.bin "$CHROOT_DIRECTORY"/
  chmod 600 "$CHROOT_DIRECTORY"/crypto_keyfile.bin
}


#
# Create /etc/filesystems for Busybox mount
#
create_etc_filesystems() {
  CONFIG_FS_TYPE=$1

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Busybox mount command requires the following config
write_log "  Setting up /etc/filesystems for $CONFIG_FS_TYPE mount"
cat <<-_SCRIPT_ > /etc/filesystems
	#
	# /etc/filesystems
	#
	
	# Needed for cloud-init cidata $CONFIG_FS_TYPE
EOF

  if [ "$CONFIG_FS_TYPE" = "ISO" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	iso9660
	_SCRIPT_
EOF
  else
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	vfat
	_SCRIPT_
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  write_debug_log "    /etc/filesystems content:"
  cat /etc/filesystems >> $LOGFILE
}
EOF
  fi

}


#
# Define list of packages in addition to base Alpine
#
define_additional_packages() {

  INITIAL_PACKAGES="ca-certificates chrony cloud-init dhcpcd kbd-bkeymaps"
  INITIAL_PACKAGES="$INITIAL_PACKAGES openssh-server-pam rng-tools rsyslog"
  INITIAL_PACKAGES="$INITIAL_PACKAGES musl-locales tzdata"

  if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
     [ "$IMAGE_ENCRYPTED" = "true" ]; then
    INITIAL_PACKAGES="$INITIAL_PACKAGES cryptsetup"
  elif [ -n "${IMAGE_ENCRYPT_REMOTE_UNLOCK+x}" ] && \
       [ "$IMAGE_ENCRYPT_REMOTE_UNLOCK" = "true" ]; then
    INITIAL_PACKAGES="$INITIAL_PACKAGES cryptsetup dropbear-unlockdisk"
  fi

  if [ -n "${IMAGE_LVM_ROOTFS+x}" ] && \
     [ "$IMAGE_LVM_ROOTFS" = "true" ]; then
    INITIAL_PACKAGES="$INITIAL_PACKAGES lvm2"
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then

    # Cloud Providers

    case $CLOUD_TYPE in
      aws )
        INITIAL_PACKAGES="${INITIAL_PACKAGES} aws-cli nvme-cli"
        ###FINAL_ROOT_DEVICE="/dev/xvda1"
        ###FINAL_ROOT_DEVICE="/dev/nvme01p1"
        ;;

      digitalocean )
        INITIAL_PACKAGES="${INITIAL_PACKAGES} doctl"
        ;;

      hetzner )
        INITIAL_PACKAGES="${INITIAL_PACKAGES} hcloud"
        ;;
    esac

  elif [ "$IMAGE_CLASS" = "physical" ]; then

    # Physical machine

    case $PHYSICAL_TYPE in
      pc )
	  	  INITIAL_PACKAGES="${INITIAL_PACKAGES} amd-ucode intel-ucode irqbalance nvme-cli"
        ;;

      rpi2 | rpi3 | rpi4 )
	  	  INITIAL_PACKAGES="${INITIAL_PACKAGES} irqbalance mmc-utils raspberrypi"
        ;;
    esac

  elif [ "$IMAGE_CLASS" = "vm" ]; then

    # Virtual Machine

    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "qemu" ]; then
      INITIAL_PACKAGES="${INITIAL_PACKAGES} qemu-guest-agent"
    fi

    if [ "$VM_TYPE" = "virtualbox" ]; then
      INITIAL_PACKAGES="${INITIAL_PACKAGES} virtualbox-guest-additions"
    fi

    if [ "$VM_TYPE" = "vmware" ]; then
      INITIAL_PACKAGES="${INITIAL_PACKAGES} open-vm-tools open-vm-tools-guestinfo open-vm-tools-timesync open-vm-tools-vix"
    fi

  fi

}


#
# Define the cloud-init DataSource(s) to enable for the relevant Cloud type
#
define_cloud_settings() {
  case $CLOUD_TYPE in
    generic )
      DATASOURCE_LIST="'AliYun','Azure','BigStep','ConfigDrive','DigitalOcean','E24Cloud','Ec2','Exoscale','GCE','Hetzner','IBMCloud','Oracle','RbxCloud','Scaleway','UpCloud','Vultr'"
      ;;
    aliyun )
      DATASOURCE_LIST="'AliYun'"
      ;;
    aws )
      DATASOURCE_LIST="'Ec2'"
      if [ "$IMAGE_ARCH" = "aarch64" ]; then
        CONSOLE_NAME="ttyAMA1"
      fi
      if [ -n "${DISABLE_SERIAL+x}" ]; then
        SERIAL_CONSOLE="true"
        SERIAL_PORT_NUMBER="0"
        if [ "$IMAGE_ARCH" = "aarch64" ]; then
          SERIAL_PORT_NAME="ttyAMA${SERIAL_PORT_NUMBER}"
        else
          SERIAL_PORT_NAME="ttyS${SERIAL_PORT_NUMBER}"
        fi
      fi
      ;;
    azure )
      DATASOURCE_LIST="'Azure'"
      ;;
    bigstep )
      DATASOURCE_LIST="'Bigstep'"
      ;;
    brightbox )
      DATASOURCE_LIST="'Ec2'"
      ;;
    digitalocean )
      DATASOURCE_LIST="'DigitalOcean'"
      ;;
    e24 )
      DATASOURCE_LIST="'E24Cloud'"
      ;;
    exoscale )
      DATASOURCE_LIST="'Exoscale'"
      ;;
    google )
      DATASOURCE_LIST="'GCE'"
      ;;
    hetzner )
      DATASOURCE_LIST="'Ec2'"
      ;;
    hyperone )
      DATASOURCE_LIST="'RbxCloud'"
      ;;
    ibmcloud )
      DATASOURCE_LIST="'IBMCloud'"
      ;;
    oracle )
      DATASOURCE_LIST="'Oracle'"
      if [ "$IMAGE_ARCH" = "aarch64" ]; then
        CONSOLE_NAME="ttyAMA1"
      fi
      if [ -n "${DISABLE_SERIAL+x}" ]; then
        SERIAL_CONSOLE="true"
        SERIAL_PORT_NUMBER="0"
        if [ "$IMAGE_ARCH" = "aarch64" ]; then
          SERIAL_PORT_NAME="ttyAMA${SERIAL_PORT_NUMBER}"
        else
          SERIAL_PORT_NAME="ttyS${SERIAL_PORT_NUMBER}"
        fi
      fi
      ;;
    rootbox )
      DATASOURCE_LIST="'RbxCloud'"
      ;;
    scaleway )
      DATASOURCE_LIST="'Scaleway'"
      ;;
    tencent )
      DATASOURCE_LIST="'ConfigDrive'"
      ;;
    upcloud )
      DATASOURCE_LIST="'UpCloud'"
      ;;
    vultr )
      DATASOURCE_LIST="'Vultr'"
      ;;
  esac
}


#
# Define the cloud-init DataSource(s) to enable for the relevant VM type
#
define_virtual_settings() {
  case $VM_TYPE in

    generic )
      DATASOURCE_LIST="'AltCloud','Opennebula','Openstack','NoCloud','OVF'"
      ;;
    opennebula )
      DATASOURCE_LIST="'Opennebula'"
      ;;
    openstack )
      DATASOURCE_LIST="'Openstack'"
      ;;
    libvirtd | qemu )
      DATASOURCE_LIST="'NoCloud'"
      if [ -z "${DISABLE_SERIAL+x}" ]; then
        SERIAL_CONSOLE="true"
        if [ "$IMAGE_ARCH" = "armv7" ] || \
           [ "$IMAGE_ARCH" = "aarch64" ]; then
          SERIAL_PORT_NUMBER="0"
          SERIAL_PORT_NAME="ttyAMA${SERIAL_PORT_NUMBER}"
        fi
      fi
      ;;
    rhevm )
      DATASOURCE_LIST="'AltCloud'"
      ;;
    test )
      DATASOURCE_LIST="'NoCloud'"
      DATASOURCE_LIST="$DATASOURCE_LIST,'AliYun','Azure','BigStep','CloudSigma','CloudStack','DigitalOcean','Ec2','Exoscale','GCE','Hetzner','IBMCloud','Oracle','RbxCloud','Scaleway','SmartOS','UpCloud','Vultr'"
      DATASOURCE_LIST="$DATASOURCE_LIST,'AltCloud',ConfigDrive','MAAS','OpenNebula','OpenStack','OVF'"

      DATASOURCE_SETTINGS=$(printf %s\\n "Ec2:" "  timeout: 5")
      ;;
    virtualbox )
      DATASOURCE_LIST="'NoCloud'"
      ;;
    vmware )
      DATASOURCE_LIST="'OVF'"
      ;;
    vsphere )
      DATASOURCE_LIST="'AltCloud'"
      ;;
  esac
}


#
# Delete unnecessary users & groups
#
delete_users_groups() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Delete unnecessary users"
for user in cyrus ftp games guest halt lp man news ntp operator \
            postmaster shutdown smmsp squid sync vpopmail xfs
do
  deluser \$user 2> /dev/null
done

write_log "Delete unnecessary groups"
for group in abuild audio cdrom cdrw floppy kvm tape video
do
  delgroup \$group
done
EOF

}


#
#
#
detect_host_os() {
  os=$(grep "^ID" /etc/os-release | sed -e 's/^ID=//')
  echo "$os"
}


#
# Disable most of the gettys normally configured to run
#
disable_extra_getty() {
  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Disabling extra getty processes"
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/inittab /etc/inittab-orig
EOF
  fi

  if [ "$IMAGE_CLASS" = "cloud" ] || \
     [ "$IMAGE_CLASS" = "vm" ]; then
    # Only have 1 getty for cloud/virtual machines
    FIRST_GETTY_TO_DISABLE="2"
  else
    # Keep 2 gettys for physical machines
    FIRST_GETTY_TO_DISABLE="3"
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

sed -i -E -e 's|^tty([${FIRST_GETTY_TO_DISABLE}-6].*)|#tty\1|g' /etc/inittab
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff /etc/inittab-orig /etc/inittab \
    >> "$LOGFILE" \
    || true
  rm /etc/inittab-orig
}
EOF
  fi

}


#
# Disable a specific kernel module
#
disable_kernel_module() {
  local MODULE_NAME=$1
  local MODULE_SECTION=$2

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Disabling ${MODULE_SECTION} kernel module ${MODULE_NAME}"

cat <<-_SCRIPT_ >> /etc/modprobe.d/disable-${MODULE_SECTION}-modules.conf
	install ${MODULE_NAME} /bin/true
	_SCRIPT_
EOF
}


#
# Disable non-server specific kernel modules
#
disable_kernel_modules() {
  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Disable non-server kernel modules"
EOF

  disable_kernel_module "evdev" "drivers"
  disable_kernel_module "mousedev" "drivers"
  disable_kernel_module "psmouse" "drivers"

  if [ "$IMAGE_CLASS" = "cloud" ] || \
     [ "$IMAGE_CLASS" = "vm" ]; then
    disable_kernel_module "ac" "drivers"
    disable_kernel_module "battery" "drivers"
    disable_kernel_module "i2c-piix4" "drivers"
    #disable_kernel_module "ehci_pci" "drivers"
    #disable_kernel_module "ohci_pci" "drivers"
    #disable_kernel_module "uhci_pci" "drivers"
    disable_kernel_module "usb_common" "drivers"
    #disable_kernel_module "xhci_pci" "drivers"
  fi

  if [ "$IMAGE_CLASS" = "vm" ]; then

    disable_kernel_module "xen-scsiback" "drivers"
    disable_kernel_module "xen-scsifront" "drivers"

    #case $VM_TYPE in
    #  libvirt | qemu )
    #    disable_kernel_module "???" "drivers"
    #    ;;
    #esac
  fi
}


#
# Download tarball of statically compiled apk tool
#
download_static_apk() {
  write_log "Downloading statically built APK tool"
  wget \
    -q \
    -O $TMPDIR/apk-tools-"$APK_STATIC_VERSION"-x86_64-linux.tar.gz \
    "$APK_STATIC_URL"/apk-tools-"$APK_STATIC_VERSION"-x86_64-linux.tar.gz \
    2>> "$LOGFILE"
  tar \
    --extract \
    -C $TMPDIR \
    -z \
    -f $TMPDIR/apk-tools-"$APK_STATIC_VERSION"-x86_64-linux.tar.gz \
    >> "$LOGFILE"
  rm -f $TMPDIR/apk-tools-"$APK_STATIC_VERSION"-x86_64-linux.tar.gz
}


#
# Enable getty for serial console
#
enable_serial_console() {

  if [ "$DEBUG" = "true" ]; then

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/inittab /etc/inittab-orig
EOF

    if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
      # GRUB
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

cp /etc/default/grub /etc/default/grub-orig
EOF
    elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
      # Syslinux
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

cp /etc/update-extlinux.conf /etc/update-extlinux.conf-orig
EOF
    fi

  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Enable serial console"
EOF

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Enabling getty on ${SERIAL_PORT_NAME} for serial console"
sed -i \
  -e 's|^[#]*ttyS0::.*$|${SERIAL_PORT_NAME}::respawn:/sbin/getty -L ${SERIAL_PORT_NAME} ${SERIAL_PORT_SPEED} vt100|g' \
  /etc/inittab
EOF

  if [ "$DEBUG" = "true" ]; then

    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff /etc/inittab-orig /etc/inittab \
    >> "$LOGFILE" \
    || true
  rm /etc/inittab-orig
}
EOF

  fi

  if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
    # GRUB
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Configure GRUB serial command"
echo 'GRUB_SERIAL_COMMAND="serial --unit=${SERIAL_PORT_NUMBER} --speed=${SERIAL_PORT_SPEED}"' \
  >> /etc/default/grub

write_log "  Configure GRUB for serial console"
echo 'GRUB_TERMINAL="serial console"' \
  >> /etc/default/grub
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff /etc/default/grub-orig /etc/default/grub \
    >> "$LOGFILE" \
    || true
  rm /etc/default/grub-orig
}
EOF
    fi

  elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
    # Syslinux
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Configure Syslinux serial port"
sed -i -e "s|^serial_port=.*|serial_port=${SERIAL_PORT_NUMBER}|g" \
  /etc/update-extlinux.conf

write_log "  Configure Syslinux serial speed"
sed -i -e "s|^serial_baud=.*|serial_baud=${SERIAL_PORT_SPEED}|g" \
  /etc/update-extlinux.conf
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff /etc/update-extlinux.conf-orig /etc/update-extlinux.conf \
    >> "$LOGFILE" \
    || true
  rm /etc/update-extlinux.conf-orig
}
EOF
    fi

  fi

}


#
#
#
error_cleanup() {
  write_log "An error occurred, cleaning up before aborting!"

  normal_cleanup

  if [ -n "${RAMDISK_DIRECTORY+x}" ] && \
     [ "$(mount | grep "$RAMDISK_DIRECTORY")" != "" ]; then
    write_log "Unmounting ramdisk"
    umount "$RAMDISK_DIRECTORY" >> "$LOGFILE"
    rmdir "$RAMDISK_DIRECTORY"
  fi
}


#
# Install additional packages
#
install_additional_packages() {
  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

ADDITIONAL_PACKAGES="$INITIAL_PACKAGES"

write_log "Install additional packages: \$ADDITIONAL_PACKAGES"

# shellcheck disable=SC2086
apk add \$ADDITIONAL_PACKAGES >> \$LOGFILE

EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  write_debug_log "Full installed packages list:"
  apk info | sort >> \$LOGFILE
}
EOF
  fi
}


#
# Install base Alpine system
#
install_alpine_base() {

  BASE_PACKAGES="alpine-base"
  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    BASE_PACKAGES="$BASE_PACKAGES efibootmgr efivar"
  fi

  # RPI alpine-base doesn't depend on mkinitfs so add it to list.
  if [ "$IMAGE_CLASS" = "physical" ] && \
     [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then
    BASE_PACKAGES="$BASE_PACKAGES mkinitfs"
  fi

  # Define bootloader-related packages
  if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
    BOOTLOADER_PACKAGES="grub"
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      BOOTLOADER_PACKAGES="$BOOTLOADER_PACKAGES dosfstools grub-efi"
    else
      BOOTLOADER_PACKAGES="$BOOTLOADER_PACKAGES grub-bios"
    fi
    BASE_PACKAGES="$BASE_PACKAGES $BOOTLOADER_PACKAGES"
  elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
    BOOTLOADER_PACKAGES="syslinux"
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      BOOTLOADER_PACKAGES="$BOOTLOADER_PACKAGES dosfstools"
    fi
    BASE_PACKAGES="$BASE_PACKAGES $BOOTLOADER_PACKAGES"
  elif [ "$IMAGE_CLASS" = "physical" ] && \
       [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then

    BOOTLOADER_PACKAGES="raspberrypi-bootloader raspberrypi-bootloader-cutdown"
    BASE_PACKAGES="$BASE_PACKAGES $BOOTLOADER_PACKAGES"
  else
    BOOTLOADER_PACKAGES="none"
  fi

  write_log "Bootloader packages to be installed are: $BOOTLOADER_PACKAGES"

  write_log "Install base Alpine (plus bootloader packages) inside chroot"
  # shellcheck disable=SC2086
  $TMPDIR/apk-tools-$APK_STATIC_VERSION/apk \
    --arch "$IMAGE_ARCH" \
    --initdb \
    --allow-untrusted \
    --root $CHROOT_DIRECTORY \
    --update-cache \
    add \
    $BASE_PACKAGES \
    >> "$LOGFILE" 2>&1
  RET_CODE=$?
  if [ $RET_CODE != 0 ]; then
    write_log "Failure while installing base Alpine, error code: $RET_CODE"
    exit 1
  fi

}


#
# Install GRUB onto disk
#
install_grub() {

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  write_debug_log "grub.cfg contents:"
  cat /boot/grub/grub.cfg \
    >> \$LOGFILE \
    || true
}
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    GRUB_OPTIONS="--verbose"
  else
    GRUB_OPTIONS=""
  fi
  GRUB_EFI_OPTIONS="--bootloader-id=alpine --efi-directory=/efi --no-nvram"
  if [ "$IMAGE_ARCH" = "aarch64" ] && [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    GRUB_TARGET="arm64-efi"
    GRUB_OPTIONS="$GRUB_OPTIONS $GRUB_EFI_OPTIONS"
  elif [ "$IMAGE_ARCH" = "x86" ]; then
    GRUB_TARGET="i386-pc"
  elif [ "$IMAGE_ARCH" = "x86_64" ] && [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    GRUB_TARGET="i386-pc"
  else
    GRUB_TARGET="x86_64-efi"
    GRUB_OPTIONS="$GRUB_OPTIONS $GRUB_EFI_OPTIONS"
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Installing GRUB bootloader"
grub-install \
  $GRUB_OPTIONS \
  --target=$GRUB_TARGET \
  $LOOP_DEVICE \
  >> \$LOGFILE \
  2>&1
EOF

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

mkdir -p /efi/EFI/boot
EOF

    case $IMAGE_ARCH in
      aarch64 )
        EFI_ARCH_FILE_INSERT="aa64"
        ;;
      x86_64 )
        EFI_ARCH_FILE_INSERT="x64"
        ;;
    esac

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Creating UEFI default boot file"
cp /efi/EFI/alpine/grub${EFI_ARCH_FILE_INSERT}.efi \
  /efi/EFI/boot/boot${EFI_ARCH_FILE_INSERT}.efi
EOF

  fi

}


#
# Install relevant kernel package
#
install_kernel() {

  if [ "$IMAGE_CLASS" = "cloud" ] || \
     [ "$IMAGE_CLASS" = "vm" ]; then

    # Cloud or Virtual machine

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Installing kernel linux-virt"
apk add linux-virt >> \$LOGFILE 2>&1

# Get the kernel version                                                        
KERNEL_VERSION=\$(apk info linux-virt | head -n 1 | sed -e 's/^linux-virt-//' -e 's/-r/-/' -e 's/ .*//' -Ee 's/^(.*)\$/\\1-virt/')
EOF

  else

    # Physical machine

    if [ "$PHYSICAL_TYPE" = "pc" ]; then

      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Installing kernel linux-lts"
apk add linux-lts linux-firmware-none >> \$LOGFILE 2>&1
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  write_debug_log "grub.cfg contents:"
  cat /boot/grub/grub.cfg \
    >> \$LOGFILE \
    || true
}
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Get the kernel version
KERNEL_VERSION=\$(apk info linux-lts | head -n 1 | sed -e 's/^linux-lts-//' -e 's/-r/-/' -e 's/ .*//' -Ee 's/^(.*)\$/\\1-lts/')
EOF

    elif [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then

      # Raspberry Pi

      case $PHYSICAL_TYPE in
        rpi2 | rpi3 )
          if [ "$IMAGE_ARCH" = "armv7" ]; then
            RPI_KERNEL="linux-rpi2"
          else
            RPI_KERNEL="linux-rpi"
          fi
          ;;
        rpi4 )
          RPI_KERNEL="linux-rpi4"
          ;;
      esac

      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Installing kernel $RPI_KERNEL"
apk add $RPI_KERNEL >> \$LOGFILE 2>&1

# Get the kernel version
KERNEL_VERSION=\$(get_kernel_version)
EOF

    fi

  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_debug_log "Kernel is: \$KERNEL_VERSION"
EOF
  fi

}


#
# Install Syslinux onto disk
#
install_syslinux() {

 if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /boot/extlinux.conf /boot/extlinux.conf-orig
write_debug_log "/boot/extlinux.conf contents at start:"
cat /boot/extlinux.conf >> \$LOGFILE
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Installing Syslinux"
EOF

  if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then

    # BIOS

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Installing BIOS MBR"
dd \
  bs=440 \
  count=1 \
  conv=notrunc \
  if=/usr/share/syslinux/mbr.bin \
  of="$LOOP_DEVICE" \
  >> $LOGFILE 2>&1

write_log "  Installing Syslinux files in /boot directory"
extlinux --install /boot/ >> $LOGFILE 2>&1

write_debug_log "/boot/extlinux.conf contents after extlinux --install:"
cat /boot/extlinux.conf >> \$LOGFILE
EOF

  else

    # UEFI

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

#write_log "  Installing Syslinux files in EFI/alpine"
#mkdir -p /boot/EFI/alpine
#cp \
#  /boot/initramfs-* \
#  /boot/vmlinuz-* \
#  /usr/share/syslinux/efi64/syslinux.efi \
#  /usr/share/syslinux/efi64/ldlinux.e64 \
#  /usr/share/syslinux/efi64/libcom32.c32 \
#  /usr/share/syslinux/efi64/libutil.c32 \
#  /usr/share/syslinux/efi64/mboot.c32 \
#  /usr/share/syslinux/efi64/menu.c32 \
#  /usr/share/syslinux/efi64/vesamenu.c32 \
#  /boot/EFI/alpine/

#write_log "  Installing Syslinux files in EFI/boot"
#mkdir -p /boot/EFI/BOOT
#cp \
#  /usr/share/syslinux/efi64/syslinux.efi \
#  /boot/EFI/boot/bootx64.efi
#cp \
#  /boot/initramfs-* \
#  /boot/vmlinuz-* \
#  /usr/share/syslinux/efi64/ldlinux.e64 \
#  /boot/EFI/alpine/*.c32 \
#  /boot/EFI/boot/

write_log "  Installing Syslinux UEFI files in EFI/BOOT aka /boot"
cp \
  /usr/share/syslinux/efi64/syslinux.efi \
  /boot/bootx64.efi
rm \
  /boot/*.c32
cp \
  /usr/share/syslinux/efi64/syslinux.c32 \
  /usr/share/syslinux/efi64/ldlinux.e64 \
  /usr/share/syslinux/efi64/libcom32.c32 \
  /usr/share/syslinux/efi64/libutil.c32 \
  /usr/share/syslinux/efi64/mboot.c32 \
  /usr/share/syslinux/efi64/menu.c32 \
  /usr/share/syslinux/efi64/vesamenu.c32 \
  /boot/

write_debug_log "  After installing Syslinux UEFI files"
ls -ltrR /boot/ >> \$LOGFILE

write_debug_log "/boot/extlinux.conf contents:"
cat /boot/extlinux.conf >> \$LOGFILE
EOF

  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_debug_log "  Before update-extlinux"
ls -ltrR /boot/ >> \$LOGFILE

write_log "  Updating extlinux.conf file"
update-extlinux --verbose --warn-only >> $LOGFILE 2>&1

write_debug_log "/boot/extlinux.conf contents after update-extlinux:"
cat /boot/extlinux.conf >> \$LOGFILE

write_log "  Fix permissions on extlinux.conf files"
chmod g=,o= /boot/extlinux.conf*
EOF

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then

    # UEFI

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_debug_log "/boot/extlinux.conf contents after everything:"
cat /boot/extlinux.conf >> \$LOGFILE
write_debug_log "  After everything"
ls -ltrR /boot/ >> \$LOGFILE
EOF

  fi

  if [ "$DEBUG" = "true" ]; then

    if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then

      # BIOS

    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

diff /boot/extlinux.conf-orig /boot/extlinux.conf \
  >> "$LOGFILE" \
  || true
rm /boot/extlinux.conf-orig

write_debug_log "  extlinux.conf contents:"
cat /boot/extlinux.conf >> "$LOGFILE"
EOF

    else

      # UEFI

    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

diff /boot/extlinux.conf-orig /boot/extlinux.conf \
  >> "$LOGFILE" \
  || true
rm /boot/extlinux.conf-orig

write_debug_log "  extlinux.conf contents:"
cat /boot/extlinux.conf >> "$LOGFILE"
EOF

    fi

  fi

}



#
#
#
normal_cleanup() {

  write_log "Normal cleanup"

  # Unmount special filesystems
  if [ "$(mount | grep "$CHROOT_DIRECTORY"/dev)" != "" ]; then
    write_log "  Unmounting /dev inside chroot"
    umount -l -f "$CHROOT_DIRECTORY"/dev >> "$LOGFILE"
  fi
  if [ "$(mount | grep "$CHROOT_DIRECTORY"/sys)" != "" ]; then
    write_log "  Unmounting /sys inside chroot"
    umount -l -f "$CHROOT_DIRECTORY"/sys >> "$LOGFILE"
  fi
  if [ "$(mount | grep "$CHROOT_DIRECTORY"/proc)" != "" ]; then
    write_log "  Unmounting /proc inside chroot"
    umount -l -f "$CHROOT_DIRECTORY"/proc >> "$LOGFILE"
  fi

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then

    # Unmount ESP partition
    write_log "  Unmounting ESP filesystem"

    if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
      umount -l -f "$CHROOT_DIRECTORY"/efi >> "$LOGFILE"
    else
      umount -l -f "$CHROOT_DIRECTORY"/boot >> "$LOGFILE"
      umount -l -f "$CHROOT_DIRECTORY"/efi >> "$LOGFILE"
    fi
  fi

  if [ "$IMAGE_CLASS" = "physical" ] && \
     mount | grep -q "$CHROOT_DIRECTORY/cidata" ; then

    # physical machines all use cidata filesystem/partition

    # Unmount cloud-init YAML partition
    write_log "  Unmounting cidata filesystem"
    umount -l -f "$CHROOT_DIRECTORY"/cidata >> "$LOGFILE"
  fi

  if [ "$IMAGE_CLASS" = "physical" ] && \
     [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ] && \
     mount | grep -q "$CHROOT_DIRECTORY/boot" ; then

    # Raspberry PIs have a /boot filesystem/partition

    # Unmount boot filesystem
    write_log "  Unmounting /boot"
    umount -l -f "$CHROOT_DIRECTORY"/boot >> "$LOGFILE"
  fi

  if [ "$(mount | grep "$CHROOT_DIRECTORY")" != "" ]; then
    # All machine types
    write_log "  Unmounting root filesystem"
    umount -l -f "$CHROOT_DIRECTORY" >> "$LOGFILE"
  fi

  if { [ -n "${IMAGE_ENCRYPTED+x}" ] && \
       [ "$IMAGE_ENCRYPTED" = "true" ]; } || \
     { [ -n "${IMAGE_ENCRYPT_REMOTE_UNLOCK+x}" ] && \
       [ "$IMAGE_ENCRYPT_REMOTE_UNLOCK" = "true" ]; }; then
    # Close LUKS partition
    cryptsetup close cryptroot
  fi

  # Free up loop device
  write_log "  Freeing up loop device"
  losetup -d "$LOOP_DEVICE" >> "$LOGFILE"
}


#
# Create relevant filesystems for the disk image and mount these
# inside the chroot directory.
#
format_and_mount_fs() {

  write_log "Formatting and mounting filesystems"

  if [ "$IMAGE_CLASS" = "cloud" ]; then

    # Cloud

    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then

      # Cloud machines booting via UEFI have ESP partition as well as root partition.

      UEFI_PART_DEVICE="${LOOP_DEVICE}p${UEFI_PART_NUM}"

      write_log "  Formatting FAT32 filesystem on ESP partition"
      mkfs.fat -F32 -n SYSTEM_EFI "$UEFI_PART_DEVICE" >> "$LOGFILE" 2>&1

      if [ "$IMAGE_BOOT_REFERENCE" = "uuid" ]; then
        ESP_FS_UUID="$(blkid -s UUID "$UEFI_PART_DEVICE" | sed -E -e 's|^.*UUID="(.*)"|\1|')"
      fi

    fi

    if { [ -n "${IMAGE_ENCRYPTED+x}" ] && \
         [ "$IMAGE_ENCRYPTED" = "true" ]; } || \
       { [ -n "${IMAGE_ENCRYPT_REMOTE_UNLOCK+x}" ] && \
         [ "$IMAGE_ENCRYPT_REMOTE_UNLOCK" = "true" ]; }; then
      ROOT_PART_DEVICE="/dev/mapper/cryptroot"
    else
      ROOT_PART_DEVICE="${LOOP_DEVICE}p${ROOT_PART_NUM}"
    fi

  elif [ "$IMAGE_CLASS" = "physical" ]; then

    # Physical machine - they all have cidata and root partitions.
    #                    RPIs also have boot partition (for RPI bootloader).
    #                    PCs if booting via UEFI also have ESP partition.

    case $PHYSICAL_TYPE in

      pc )
        if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then

          # PCs booting via UEFI have a ESP partition.

          UEFI_PART_DEVICE="${LOOP_DEVICE}p${UEFI_PART_NUM}"

          write_log "  Formatting FAT32 filesystem on ESP partition"
          mkfs.fat -F32 -n SYSTEM_EFI "$UEFI_PART_DEVICE" >> "$LOGFILE" 2>&1

          if [ "$IMAGE_BOOT_REFERENCE" = "uuid" ]; then
            ESP_FS_UUID="$(blkid -s UUID "$UEFI_PART_DEVICE" | sed -E -e 's|^.*UUID="(.*)"|\1|')"
          fi

        fi
        ;;

      rpi2 | rpi3 | rpi4 )

        # Raspberry Pi's have a boot partition for use
        # by their built-in bootloader.

        RPI_BOOT_PART_DEVICE="${LOOP_DEVICE}p${RPI_BOOT_PART_NUM}"

        write_log "  Formatting FAT16 filesystem on RPI boot partition"
        mkfs.fat -F16 -s 2 -S 512 -n BOOT "$RPI_BOOT_PART_DEVICE" \
				  >> "$LOGFILE" 2>&1

        if [ "$IMAGE_BOOT_REFERENCE" = "uuid" ]; then
          RPI_BOOT_FS_UUID="$(blkid -s UUID "$RPI_BOOT_PART_DEVICE" | sed -E -e 's|^.*UUID="(.*)"|\1|')"
        fi
        ;;

    esac

    # All Physical machines have at least a cloud-init partition
    # and a root partition.

    CIDATA_PART_DEVICE="${LOOP_DEVICE}p${CIDATA_PART_NUM}"
    if { [ -n "${IMAGE_ENCRYPTED+x}" ] && \
         [ "$IMAGE_ENCRYPTED" = "true" ]; } || \
       { [ -n "${IMAGE_ENCRYPT_REMOTE_UNLOCK+x}" ] && \
         [ "$IMAGE_ENCRYPT_REMOTE_UNLOCK" = "true" ]; }; then
      ROOT_PART_DEVICE="/dev/mapper/cryptroot"
    else
      ROOT_PART_DEVICE="${LOOP_DEVICE}p${ROOT_PART_NUM}"
    fi

    # Format (minimum sized) FAT16 filesystem for cloud-init
    write_log "  Formatting FAT16 filesystem on cidata partition"
    mkfs.fat -F16 -s 1 -S 512 -n CIDATA "$CIDATA_PART_DEVICE" >> "$LOGFILE" 2>&1

  else

    # Virtual machine - they have a root partition, and
    # a ESP partition if using UEFI.

    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then                                          
                                                                                
      # VMs booting via UEFI have ESP partition as well as root partition.           
                                                                                
      UEFI_PART_DEVICE="${LOOP_DEVICE}p${UEFI_PART_NUM}"                        

      write_log "  Formatting FAT32 filesystem on ESP partition"                  
      mkfs.fat -F32 -n SYSTEM_EFI "$UEFI_PART_DEVICE" >> "$LOGFILE" 2>&1

      if [ "$IMAGE_BOOT_REFERENCE" = "uuid" ]; then
        ESP_FS_UUID="$(blkid -s UUID "$UEFI_PART_DEVICE" | sed -E -e 's|^.*UUID="(.*)"|\1|')"
			fi

    fi

    if { [ -n "${IMAGE_ENCRYPTED+x}" ] && \
         [ "$IMAGE_ENCRYPTED" = "true" ]; } || \
       { [ -n "${IMAGE_ENCRYPT_REMOTE_UNLOCK+x}" ] && \
         [ "$IMAGE_ENCRYPT_REMOTE_UNLOCK" = "true" ]; }; then
      ROOT_PART_DEVICE="/dev/mapper/cryptroot"
    else
      ROOT_PART_DEVICE="${LOOP_DEVICE}p${ROOT_PART_NUM}"
    fi

  fi

  # Ensure inode size is 256 bytes rather than 128 in
  # order to avoid Year 2038 problems/warning.
  rootfs_options="-I 256"
  if [ "$IMAGE_BOOTLOADER" = "syslinux" ] && \
     { [ -z "${IMAGE_ENCRYPTED+x}" ] || \
       [ "$IMAGE_ENCRYPTED" != "true" ]; } || \
     { [ -z "${IMAGE_ENCRYPT_REMOTE_UNLOCK+x}" ] || \
       [ "$IMAGE_ENCRYPT_REMOTE_UNLOCK" != "true" ]; }; then
    # Syslinux requires 64bit flag be disabled for boot filesystem
    rootfs_options="$rootfs_options -O ^64bit"
  fi

  write_log "  Formatting Ext4 filesystem on root partition"
  # shellcheck disable=SC2086
  mkfs.ext4 -q -L $DEFAULT_ROOTFS_LABEL $rootfs_options "$ROOT_PART_DEVICE" >> "$LOGFILE"

  if [ "$IMAGE_BOOT_REFERENCE" = "uuid" ]; then
    ROOT_FS_UUID="$(blkid -s UUID "$ROOT_PART_DEVICE" | sed -E -e 's|^.*UUID="(.*)"|\1|')"
  fi

  # Create directory for chroot/rootfs use and mount
  # loopback device root partition onto the directory.
  write_log "  Mounting root filesystem onto $CHROOT_DIRECTORY"
  mkdir -p "$CHROOT_DIRECTORY"
  mount -o private "$ROOT_PART_DEVICE" "$CHROOT_DIRECTORY" >> "$LOGFILE"

  if [ "$IMAGE_CLASS" = "cloud" ] && \
     [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then

    # Cloud machine using UEFI

    # Create directory for UEFI and mount loopback
    # device ESP partition onto the directory.

    if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
      # When using Syslinux with UEFI then, as the kernel and initramfs
      # files need to be in the ESP partition it is mounted as /boot.
      write_log "  Mounting ESP filesystem onto $CHROOT_DIRECTORY/boot"
      mkdir -p "$CHROOT_DIRECTORY"/boot
      mount \
        -o private \
        "$UEFI_PART_DEVICE" \
        "$CHROOT_DIRECTORY"/boot \
        >> "$LOGFILE"
    else
      write_log "  Mounting ESP filesystem onto $CHROOT_DIRECTORY/efi"
      mkdir -p "$CHROOT_DIRECTORY"/efi
      mount \
        -o private \
        "$UEFI_PART_DEVICE" \
        "$CHROOT_DIRECTORY"/efi \
        >> "$LOGFILE"
    fi

  elif [ "$IMAGE_CLASS" = "physical" ]; then

    if [ "$PHYSICAL_TYPE" = "pc" ] && \
       [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then

      # PC using UEFI

      # Create directory for UEFI and mount loopback
      # device ESP partition onto the directory.

      if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
        # When using Syslinux with UEFI then, as the kernel and initramfs
        # files need to be in the ESP partition it is mounted as /boot.
        write_log "  Mounting ESP filesystem onto $CHROOT_DIRECTORY/boot"
        mkdir -p "$CHROOT_DIRECTORY"/boot
        mount \
          -o private \
          "$UEFI_PART_DEVICE" \
          "$CHROOT_DIRECTORY"/boot \
          >> "$LOGFILE"
      else
        write_log "  Mounting ESP filesystem onto $CHROOT_DIRECTORY/efi"
        mkdir -p "$CHROOT_DIRECTORY"/efi
        mount \
          -o private \
          "$UEFI_PART_DEVICE" \
          "$CHROOT_DIRECTORY"/efi \
          >> "$LOGFILE"
      fi

    elif [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then
      # Raspberry Pi 2/3/4

      # Create directory for RPI builtin bootloader's use and mount
      # loopback device RPI boot partition onto the directory.

      write_log "  Mounting RPI boot filesystem onto $CHROOT_DIRECTORY/boot"
      mkdir -p "$CHROOT_DIRECTORY"/boot
      mount -o private "$RPI_BOOT_PART_DEVICE" "$CHROOT_DIRECTORY"/boot >> "$LOGFILE"
    fi

    # Create directory for cloud-init YAML files and mount
    # loopback device cidata partition onto CHROOT_DIRECTORY/cidata"

    write_log "  Mounting cloud-init YAML filesystem onto $CHROOT_DIRECTORY/cidata"
    mkdir -p "$CHROOT_DIRECTORY"/cidata
    mount -o private "$CIDATA_PART_DEVICE" "$CHROOT_DIRECTORY"/cidata >> "$LOGFILE"

  elif [ "$IMAGE_CLASS" = "vm" ] && \
       [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    # Virtual machine using UEFI

    # Create directory for UEFI and mount loopback
    # device ESP partition onto the directory.

    if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
      write_log "  Mounting ESP filesystem onto $CHROOT_DIRECTORY/efi"
      mkdir -p "$CHROOT_DIRECTORY"/efi
      mount \
        -o private \
        "$UEFI_PART_DEVICE" \
        "$CHROOT_DIRECTORY"/efi \
        >> "$LOGFILE"

      # When using Syslinux with UEFI then, as the kernel and initramfs
      # files need to be in the EFI/BOOT directory of the ESP partition
      # then EFI/BOOT directory of ESP partition is bind-mounted to /boot.
      # This ensures that the kernel, initramfs, and extlinux.conf files
      # are in the ESP partition.
      write_log "  Bind mounting ESP filesystem's EFI/BOOT onto $CHROOT_DIRECTORY/boot"
      mkdir -p "$CHROOT_DIRECTORY"/efi/EFI/BOOT
      mkdir -p "$CHROOT_DIRECTORY"/boot
      mount \
        -t none \
        -o bind \
        "$CHROOT_DIRECTORY"/efi/EFI/BOOT \
        "$CHROOT_DIRECTORY"/boot \
        >> "$LOGFILE"
    else
      write_log "  Mounting ESP filesystem onto $CHROOT_DIRECTORY/efi"
      mkdir -p "$CHROOT_DIRECTORY"/efi
      mount \
        -o private \
        "$UEFI_PART_DEVICE" \
        "$CHROOT_DIRECTORY"/efi \
        >> "$LOGFILE"
    fi

  fi
}


#
# Parse options given on the command line
#
parse_cli_options() {

  IMAGE_DISABLE_IPV4=false
  IMAGE_DISABLE_IPV6=false

  if ! CLI=$(getopt -s sh \
    -o h \
    -l apk_static_url:,apk_static_version:,arch:,boot_by_label,bootloader:,boottype:,chroot_directory:,disable_console,disable_serial,cloud:,debug,encrypt,encrypt_remote_unlock,help,image_filename:,images_directory:,ipv4only,ipv6only,keymap:,local_repo:,local_repo_sig_file:,locale:,lvm,mirror:,password:,physical:,ramdisk_directory:,release:,use_ramdisk,username:,virtual: \
    -n "$0" -- "$@"); then
    echo
    echo "Terminating..." >&2
    echo
    exit 2
  fi

  eval set -- "$CLI"

  while true; do
    case "$1" in

      --apk_static_url )
        APK_STATIC_URL="$2"
        shift 2
        ;;

      --apk_static_version )
        APK_STATIC_VERSION="$2"
        shift 2
        ;;

      --arch )
        case $2 in
          aarch64 | armv7 | x86 | 86_64 )
            IMAGE_ARCH=$2
            check_binfmt_packages "$IMAGE_ARCH"
            ;;
          * )
            echo
            echo "Unknown arch!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;

      --boot_by_label )
        IMAGE_BOOT_REFERENCE="label"
        shift
        ;;

      --bootloader )
        IMAGE_BOOTLOADER="$2"
        shift 2
        ;;

      --boottype )
        case $2 in
          bios | none | uefi )
            IMAGE_BOOT_TYPE=$2
            ;;
          * )
            echo
            echo "Unknown boot type, valid values are 'bios', 'none', and 'uefi'"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;

      --chroot_directory )
        CHROOT_DIRECTORY="$2"
        shift 2
        ;;

      --cloud )
        IMAGE_CLASS="cloud"
        case $2 in
          aliyun | aws | azure | bigstep | brightbox | digitalocean | e24 | exoscale | generic | google | hetzner | hyperone | ibmcloud | oracle | rootbox | scaleway | tencent | upcloud | vultr )
            CLOUD_TYPE=$2
            ;;
          *)
            echo
            echo "Unknown cloud type!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;

      --debug )
        DEBUG=true
        shift
        ;;

      --disable_console )
        DISABLE_CONSOLE=true
        shift
        ;;

      --disable_serial )
        DISABLE_SERIAL=true
        shift
        ;;

      --encrypt )
        IMAGE_ENCRYPTED=true
        shift
        ;;

      --encrypt_remote_unlock )
        IMAGE_ENCRYPT_REMOTE_UNLOCK=true
        shift
        ;;

      -h | --help )
        usage
        exit 0
        ;;

      --image_filename )
        IMAGE_FILENAME="$2"
        shift 2
        ;;

      --images_directory )
        IMAGES_DIRECTORY="$2"
        shift 2
        ;;

      --ipv4only )
        IMAGE_DISABLE_IPV4=false
        IMAGE_DISABLE_IPV6=true
        shift
        ;;

      --ipv6only )
        IMAGE_DISABLE_IPV4=true
        IMAGE_DISABLE_IPV6=false
        shift
        ;;

      --keymap )
        IMAGE_KEYMAP="$2"
        shift 2
        ;;

      --local_repo )
        LOCAL_ALPINE_REPOSITORY="$2"
        shift 2
        ;;

      --local_repo_sig_file )
        LOCAL_REPO_SIGNATURE_FILE="$2"
        shift 2
        ;;

      --locale )
        IMAGE_LOCALE="$2"
        shift 2
        ;;

      --lvm )
        IMAGE_LVM_ROOTFS=true
        shift
        ;;

      --mirror )
        ALPINE_MIRROR_SITE="$2"
        shift 2
        ;;

      --password )
        IMAGE_DEFAULT_USER_PASSWORD="$2"
        shift 2
        ;;

      --physical )
        IMAGE_CLASS="physical"
        case $2 in
          pc | rpi2 | rpi3 | rpi4 )
            PHYSICAL_TYPE=$2
            ;;
          * )
            echo
            echo "Unknown physical machine type!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;

      --ramdisk_directory )
        RAMDISK_DIRECTORY="$2"
        shift 2
        ;;

      --release )
        case $2 in
          3.13 | 3.14 )
            IMAGE_ALPINE_RELEASE=v$2
            ;;
          edge )
            IMAGE_ALPINE_RELEASE=$2
            ;;
          * )
            echo
            echo "Unknown or unsupported Alpine release!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;

      --use_ramdisk )
        USE_RAMDISK=true
        shift
        ;;

      --username )
        IMAGE_DEFAULT_USERNAME=$2
        shift 2
        ;;

      --virtual )
        IMAGE_CLASS="vm"
        case $2 in
          generic | hyperv | libvirtd | proxmox | qemu | virtualbox | vmware )
            VM_TYPE=$2
            ;;
          * )
            echo
            echo "Unknown virtual machine type!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;

      -- )
        shift
        break
        ;;

    esac
  done

}


#
# Partition the disk image for booting via BIOS
#
partition_bios() {
  write_log "Partitioning disk image for BIOS"

  write_debug_log "  Creating MSDOS disk label"
  parted --machine --script --align=optimal "$FULL_FILENAME" \
    mklabel msdos \
    >> "$LOGFILE" 2>&1

  if { [ -n "${IMAGE_ENCRYPTED+x}" ] && \
       [ "$IMAGE_ENCRYPTED" = "true" ]; } || \
     { [ -n "${IMAGE_ENCRYPT_REMOTE_UNLOCK+x}" ] && \
       [ "$IMAGE_ENCRYPT_REMOTE_UNLOCK" = "true" ]; }; then

    if [ "$IMAGE_CLASS" = "physical" ]; then
      CIDATA_PART_NUM="1"
      LUKS_PART_NUM="2"

      write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
      parted --machine --script --align=optimal "$FULL_FILENAME" \
        mkpart primary 0% ${CIDATA_PART_SIZE}MiB \
        >> "$LOGFILE" 2>&1
      write_debug_log "  Creating LUKS partition"
      parted --machine --script --align=optimal "$FULL_FILENAME" \
        mkpart primary ${CIDATA_PART_SIZE}MiB 100% \
        >> "$LOGFILE" 2>&1
    else
      LUKS_PART_NUM="1"

      write_debug_log "  Creating LUKS partition"
      parted --machine --script --align=optimal "$FULL_FILENAME" \
        mkpart primary 0% 100% \
        >> "$LOGFILE"
    fi

  else

    if [ "$IMAGE_CLASS" = "physical" ]; then
      CIDATA_PART_NUM="1"
      ROOT_PART_NUM="2"
      write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
      parted --machine --script --align=optimal "$FULL_FILENAME" \
        mkpart primary 0% ${CIDATA_PART_SIZE}MiB \
        >> "$LOGFILE" 2>&1
      write_debug_log "  Creating root partition with boot flag on"
      parted --machine --script --align=optimal "$FULL_FILENAME" \
        mkpart primary ${CIDATA_PART_SIZE}MiB 100% \
        set $ROOT_PART_NUM boot on \
        >> "$LOGFILE" 2>&1
    else
      ROOT_PART_NUM="1"
      write_debug_log "  Creating root partition with boot flag on"
      parted --machine --script --align=optimal "$FULL_FILENAME" \
        mkpart primary 0% 100% \
        set $ROOT_PART_NUM boot on \
        >> "$LOGFILE"
    fi
  fi
}


#
# Partition for Raspberry Pi use
#
partition_rpi() {
  write_log "Partitioning disk image for Raspberry Pi"

  RPI_BOOT_PART_NUM="1"
  CIDATA_PART_NUM="2"                                                         
  ROOT_PART_NUM="3"

  RPI_ROOT_DEVICE="/dev/mmcblk0p${ROOT_PART_NUM}"

  write_debug_log "  Creating MSDOS disk label"
  parted --machine --script --align=optimal "$FULL_FILENAME" mklabel msdos \
    >> "$LOGFILE" 2>&1

  # Create partition for RPI built-in bootloader
  write_debug_log "  Creating ${RPI_BOOT_PART_SIZE}MiB boot partition"
  parted --machine --script --align=optimal "$FULL_FILENAME" \
    mkpart primary 0% ${RPI_BOOT_PART_SIZE}MiB \
    set $RPI_BOOT_PART_NUM lba on \
    >> "$LOGFILE" 2>&1

  # Create partition for cloud-init use
  write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
  # shellcheck disable=SC2003
  parted --machine --script --align=optimal "$FULL_FILENAME" \
    mkpart primary ${RPI_BOOT_PART_SIZE}MiB "$(expr ${RPI_BOOT_PART_SIZE} + ${CIDATA_PART_SIZE})"MiB \
    >> "$LOGFILE" 2>&1

  # Create root partition
  write_debug_log "  Creating root parition"
  # shellcheck disable=SC2003
  parted --machine --script --align=optimal "$FULL_FILENAME" \
    mkpart primary "$(expr ${RPI_BOOT_PART_SIZE} + ${CIDATA_PART_SIZE})"MiB 100% \
    >> "$LOGFILE" 2>&1
}


# 
# Partition the disk image for booting via UEFI
#
partition_uefi() {
  write_log "Partitioning disk image for UEFI"

  if [ "$IMAGE_CLASS" = "physical" ]; then
    UEFI_PART_NUM="1"
    CIDATA_PART_NUM="2"
    ROOT_PART_NUM="3"
  else
    UEFI_PART_NUM="1"
    ROOT_PART_NUM="2"
  fi

  write_debug_log "  Creating GPT disk label"
  parted --machine --script --align=optimal "$FULL_FILENAME" \
    mklabel gpt \
    >> "$LOGFILE" 2>&1

  # Create EFI partition
  write_debug_log "  Creating ${UEFI_PART_SIZE}MiB ESP partition"
  parted --machine --script --align optimal "$FULL_FILENAME" \
    unit MiB \
    mkpart primary fat32 0% ${UEFI_PART_SIZE} \
    set $UEFI_PART_NUM esp on \
    >> "$LOGFILE" 2>&1

  if [ "$IMAGE_CLASS" = "physical" ]; then
    # shellcheck disable=SC2003
    write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
    # shellcheck disable=SC2003
    parted --machine --script --align=optimal "$FULL_FILENAME" \
      unit MiB \
      mkpart primary ${UEFI_PART_SIZE} "$(expr ${UEFI_PART_SIZE} + ${CIDATA_PART_SIZE})" \
      >> "$LOGFILE" 2>&1
    write_debug_log "  Creating root partition with boot on"
    # shellcheck disable=SC2003
    parted --machine --script --align=optimal "$FULL_FILENAME" \
      unit MiB \
      mkpart primary "$(eval ${UEFI_PART_SIZE} + ${CIDATA_PART_SIZE})" 100% \
      >> "$LOGFILE" 2>&1
  else
    write_debug_log "  Creating root partition with boot on"
    parted --machine --script --align=optimal "$FULL_FILENAME" \
      unit MiB \
      mkpart primary ${UEFI_PART_SIZE} 100% \
      >> "$LOGFILE" 2>&1
  fi
}


#
# Regenerate initramfs file
#
regenerate_initramfs() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Regenerate initramfs"                                            
mkinitfs "\$KERNEL_VERSION" >> \$LOGFILE
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  write_debug_log "mkinitfs contents after:"
  mkinitfs -l "\$KERNEL_VERSION" >> \$LOGFILE
}
EOF
  fi

}


#
# Create the /etc/crypttab file
#
setup_crypttab() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Creating /etc/crypttab"
echo "cryptroot UUID=${LUKS_PART_UUID} /crypto_keyfile.bin luks" > /etc/crypttab
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
write_debug_log "    /etc/crypttab contents:"
cat /etc/crypttab >> \$LOGFILE
EOF
  fi

}


#
# Configure modules to be loaded upon boot
#
setup_etc_modules() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Setup /etc/modules"
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/modules /etc/modules-orig
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

cat <<-_SCRIPT_ > /etc/modules
	af_packet
EOF

  if [ "$IMAGE_DISABLE_IPV6" != "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	ipv6
EOF
  fi

  if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
     [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

	# LUKS
	dm-crypt
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

	# Used by rngd
	jitterentropy_rng
EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud machine
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

	# Cloud-specific modules
	virtio-rng
EOF
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual machine
    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "qemu" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

	# VM-specific modules
	ptp_kvm
	virtio-rng
EOF
    fi

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	_SCRIPT_
EOF

  else
    # Physical machine
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	_SCRIPT_
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff \
    /etc/modules-orig \
    /etc/modules \
    >> "$LOGFILE" \
    || true
  rm /etc/modules-orig
}
EOF
  fi

}


#
# Setup the LUKS device
#
setup_luks_device() {
  write_log "Setting up LUKS device"

  LUKS_DEVICE="${LOOP_DEVICE}p${LUKS_PART_NUM}"

  if [ "$IMAGE_ALPINE_RELEASE" = "v3.13" ]; then
    LUKS_VERSION="1"
  else
    LUKS_VERSION="1"
    ###LUKS_VERSION="2"
  fi

  write_log "  Formatting partition as LUKS version ${LUKS_VERSION}"
  echo "$DEFAULT_LUKS_PASSPHRASE" | \
    cryptsetup \
      -q \
      luksFormat \
        --cipher aes-xts-plain64 \
        --hash sha256 \
        --key-size 512 \
        --pbkdf pbkdf2 \
        --type luks$LUKS_VERSION \
      "$LUKS_DEVICE" \
    >> "$LOGFILE"

  if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
     [ "$IMAGE_ENCRYPTED" = "true" ]; then

    # Create keyfile - this will be placed in the initramfs and used to
    # unlock the rootfs - this prevents being prompted for passphrase
    # twice, once by GRUB and then again by initramfs.
    write_log "  Creating keyfile for LUKS"
    dd \
      bs=512 \
      count=4 \
      if=/dev/random \
      of=crypto_keyfile.bin \
      iflag=fullblock \
      >> "$LOGFILE" 2>&1

    write_log "  Adding keyfile to LUKS device"
    echo "$DEFAULT_LUKS_PASSPHRASE" | \
      cryptsetup \
        luksAddKey \
        "$LUKS_DEVICE" \
        ./crypto_keyfile.bin \
      >> "$LOGFILE"

    write_log "  Opening LUKS device"
    cryptsetup \
      open \
        --type luks$LUKS_VERSION \
        --key-file ./crypto_keyfile.bin \
      "$LUKS_DEVICE" \
      cryptroot

  elif [ -n "${IMAGE_ENCRYPT_REMOTE_UNLOCK+x}" ] && \
     [ "$IMAGE_ENCRYPT_REMOTE_UNLOCK" = "true" ]; then

    write_log "  Opening LUKS device"
    echo "$DEFAULT_LUKS_PASSPHRASE" | \
      cryptsetup \
        open \
          --type luks$LUKS_VERSION \
        "$LUKS_DEVICE" \
        cryptroot \
        -

  fi

  LUKS_PART_UUID=$(blkid "$LUKS_DEVICE" | sed -e 's|^.* UUID="||' -e 's|".*$||')

  if [ "$DEBUG" = "true" ]; then
    write_log "  Show LUKS device details"
    cryptsetup luksDump "$LUKS_DEVICE" >> "$LOGFILE"
  fi
}


#
# Change the default OpenSSH server config to be more secure
#
tighten_sshd_configuration() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Tighten the SSH server configuration"
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/conf.d/sshd /etc/conf.d/sshd-orig
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "    Only generate ED25519 & 4096bit RSA host keys"
sed -i \
  -e 's/^#key_types_to_generate=.*$/key_types_to_generate="ed25519 rsa"/' \
  -e 's/^#rsa_bit_size=.*$/rsa_bit_size="4096"/' \
  /etc/conf.d/sshd
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff /etc/conf.d/sshd-orig /etc/conf.d/sshd \
  >> "$LOGFILE" \
  || true
  rm /etc/conf.d/sshd-orig

  cp /etc/ssh/sshd_config /etc/ssh/sshd_config-orig
}
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Configure sshd to:
#   - only use ED25519 & RSA host keys
#   - prevent root logins
#   - prevent password-based logins
#   - enable PAM
write_log "    Prevent root login, prevent password logins"
sed -i \
  -e 's|^#HostKey /etc/ssh/ssh_host_ed25519_key$|HostKey /etc/ssh/ssh_host_ed25519_key|' \
  -e 's|^#HostKey /etc/ssh/ssh_host_rsa_key$|HostKey /etc/ssh/ssh_host_rsa_key|' \
  -e 's|^#PermitRootLogin .*$|PermitRootLogin no|' \
  -e 's|^#PasswordAuthentication .*$|PasswordAuthentication no|' \
  -e 's|^#UsePAM .*$|UsePAM yes|' \
  /etc/ssh/sshd_config
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff /etc/ssh/sshd_config-orig /etc/ssh/sshd_config \
    >> "$LOGFILE" \
    || true
  rm /etc/ssh/sshd_config-orig
}
EOF
  fi

}


#
# Configure cloud-init
#
tweak_cloud_init() {

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Tweaking cloud-init configuration"
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
cp /etc/cloud/cloud.cfg /etc/cloud/cloud.cfg-orig
EOF
  fi

  if [ "$DEBUG" != "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Lock the root account"
cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	
	# Lock root's password
	users:
	  - name: root
	    lock_passwd: true
	_SCRIPT_
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
EOF

  if [ "$DEBUG" != "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	
	# Set default user's password
	passwd: $IMAGE_DEFAULT_USER_PASSWORD
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

	# Delete any pre-existing SSH hosts keys
	ssh_deletekeys: True
	
	# Only create ED25519 and RSA SSH host keys
	ssh_genkeytypes: ["ed25519","rsa"]
	
	# Don't show SSH host key fingerprints on console at boot.
	no_ssh_fingerprints: True
	_SCRIPT_

write_log "  Ensure SSH password authentication is disabled"
sed -i \
  -Ee 's/^([[:space:]]*)ssh_pwauth:.*$/\1ssh_pwauth: false/' \
  /etc/cloud/cloud.cfg
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Prevent default user account being locked"
sed -i \
  -Ee 's/^([[:space:]]+)lock_passwd: .*$/\1lock_passwd: false/' \
  /etc/cloud/cloud.cfg
EOF
  fi

  if [ "$IMAGE_DEFAULT_USERNAME" != "alpine" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting the default username to $IMAGE_DEFAULT_USERNAME"
sed -i \
  -Ee 's/^([[:space:]]+)name: alpine$/\1name: $IMAGE_DEFAULT_USERNAME/' \
  /etc/cloud/cloud.cfg
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

sed -i \
  -Ee 's/^([[:space:]]+)gecos: .*$/\1gecos: Default cloud-init user/' \
  /etc/cloud/cloud.cfg
EOF

  DATASOURCE_LIST="'None'"
  DATASOURCE_SETTINGS=""

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    define_cloud_settings
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    DATASOURCE_LIST="'NoCloud'"
  else
    # VM
    define_virtual_settings
  fi

  # Need to sort out serial console settings at this stage, after specific
  # clouds/VM types may/may not have overriden the defaults.
  if [ -n "${SERIAL_CONSOLE+x}" ] && \
     [ "$SERIAL_CONSOLE" = "true" ]; then
    if [ -z "${SERIAL_PORT_NUMBER+x}" ]; then
      SERIAL_PORT_NUMBER=$DEFAULT_SERIAL_PORT_NUMBER
      SERIAL_PORT_NAME=$DEFAULT_SERIAL_PORT_NAME
    fi
    if [ -z "${SERIAL_PORT_SPEED+x}" ]; then
      SERIAL_PORT_SPEED=$DEFAULT_SERIAL_PORT_SPEED
    fi
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Setting up DataSources list"
cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	
	datasource_list: [$DATASOURCE_LIST,'None']
EOF

  if [ -n "$DATASOURCE_SETTINGS" ]; then
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	
	datasource:
	  $DATASOURCE_SETTINGS
EOF
  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	_SCRIPT_
EOF

  if [ "$DEBUG" = "true" ]; then                                                   
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff /etc/cloud/cloud.cfg-orig \
    /etc/cloud/cloud.cfg \
    >> "$LOGFILE" \
    || true
  rm /etc/cloud/cloud.cfg-orig

  cp /etc/cloud/cloud.cfg.d/05_logging.cfg \
    /etc/cloud/cloud.cfg.d/05_logging.cfg-orig
}
EOF
  fi

  if [ "$DEBUG" = "true" ]; then  
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Enabling cloud-init debugging"
sed -i \
  -E '\$!N; s/(class=.*Handler\n[[:space:]]*)level=INFO/\1level=DEBUG/g ;P;D' \
  /etc/cloud/cloud.cfg.d/05_logging.cfg
EOF
  else
    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "  Disabling cloud-init debugging"
sed -i \
  -E '\$!N; s/(class=.*Handler\n[[:space:]]*)level=DEBUG/\1level=INFO/g ;P;D' \
  /etc/cloud/cloud.cfg.d/05_logging.cfg
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

{
  # Debug
  diff /etc/cloud/cloud.cfg.d/05_logging.cfg-orig \
    /etc/cloud/cloud.cfg.d/05_logging.cfg \
    >> "$LOGFILE" \
    || true
  rm /etc/cloud/cloud.cfg.d/05_logging.cfg-orig
}
EOF
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    case $CLOUD_TYPE in
      azure )
        create_etc_filesystems "VFAT"
        ;;
    esac
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual machine
    create_etc_filesystems "ISO"
  else
    # Physical
    create_etc_filesystems "VFAT"
  fi

  if [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Creating cloud-init YAML files for physical machine"

write_log "  Creating meta-data.yaml"
cat <<-_SCRIPT_ > "\$CIDATA_DIRECTORY"/meta-data.yaml
	#
	# \$CIDATA_DIRECTORY/meta-data.yaml
	#
	
	instance-id: iid-local0
	_SCRIPT_

write_log "  Creating network-config-v2.yaml"
cat <<-_SCRIPT_ > "\$CIDATA_DIRECTORY"/network-config-v2.yaml
	#
	# \$CIDATA_DIRECTORY/network-config-v2.yaml
	#
	
	version: 2
	ethernets:
	  eth0:
	    dhcpv4: yes
	    dhcpv6: yes
	_SCRIPT_

write_log "  Creating user-data.yaml"
cat <<-_SCRIPT_ > "\$CIDATA_DIRECTORY"/user-data.yaml
	#
	# \$CIDATA_DIRECTORY/user-data.yaml
	#
	
	#cloud-config
	
	apk_repos:
	  preserve_repositories: false
	  alpine_repo:
	    version: '$IMAGE_ALPINE_RELEASE'
	    base_url: $ALPINE_MIRROR_SITE
	    community_enabled: true
EOF

    if [ "$IMAGE_ALPINE_RELEASE" = "edge" ]; then
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	    testing_enabled: true
EOF
    else
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	    testing_enabled: false
EOF
    fi

    if [ -n "${LOCAL_ALPINE_REPOSITORY+x}" ]; then
      cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	  local_repo_base_url: $LOCAL_ALPINE_REPOSITORY
EOF
    fi

    cat <<EOF >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"
	
	debug:
	  verbose: false
	
	ssh:
	  # Whether to show either host keys or their fingerprints on console
	  emit_keys_to_console: false
	
	locale: ??????
	
	ntp:
	  enabled: true
	  servers:
	    - pool.ntp.org
	
	package_reboot_if_required: false
	package_update: false
	package_upgrade: false
	
	resize_rootfs: true
	
	ssh_authorized_keys:
	  - '??????'
	
	# Host keys: Pre-existing keys are deleted by default.
	ssh_deletekeys: true
	
	timezone: ????
	
	_SCRIPT_
EOF

  fi

}


#
#
#
update_upgrade_packages() {
  cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

write_log "Updating package list"
apk update >> "$LOGFILE"

write_log "Upgrading base packages if necessary"
# shellcheck disable=SC2129
apk upgrade >> "$LOGFILE"
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$CHROOT_DIRECTORY"/"$PREP_SCRIPT"

# Debug
apk info | sort > base-packages.list
EOF
  fi
}


#
# Help text
#
usage() {
  echo "Usage: $0 [ options ]"
  echo
  echo "When called with no option is equivalent to '--arch x86_66 --release edge --bootloader syslinux -virtual qemu'"
  echo
  echo "Options:"
  echo
  echo "  --apk_static_url < url >"
  echo "     Base url to download statically compiled APK tool from."
  echo
  echo "  --apk_static_version < version >"
  echo
  echo "    Version of the statically compiled APK tool to download/use."
  echo
  echo "  --arch < aarch64 | armv7 | x86 | x86_64 >"
  echo
  echo "    Defaults to x86_86, except when '--physical rpi*' specified when it defaults to aarch64."
  echo
  echo "  --boot_by_label"
  echo
  echo "    Use FS Labels rather than UUIDs in /etc/fstab and bootloader to refer to filesystems."
  echo
  echo "  --bootloader < grub | syslinux >"
  echo
  echo "    Defaults to Syslinux."
  echo
  echo "  --boottype < bios | uefi >"
  echo
  echo "    Defaults to UEFI."
  echo
  echo "  --chroot_directory < directory >"
  echo
  echo "    Directory to use for building the Alpine image. Defaults to './chroot'."
  echo
  echo "  --cloud <cloud type>"
  echo
  echo "    Valid values are:"
  echo "      generic aliyun aws azure bigstep brightbox digitalocean e24 exoscale"
  echo "      google hetzner hyperone ibmcloud oracle rootbox scaleway tencent"
  echo "      upcloud vultr"
  echo
  echo "  --image_filename < filename >"
  echo
  echo "    Filename to use for the created Alpine disk image."
  echo
  echo "  --images_directory < directory >"
  echo
  echo "    The directory to store the created disk image in."
  echo
  echo "  --ipv4only"
  echo
  echo "    Do not enable IPv6 in the created disk image."
  echo
  echo "  --ipv6only"
  echo
  echo "    Do not enable IPv4 in the created disk image."
  echo
  echo "  --keymap < keymap >"
  echo
  echo "    Defaults to 'us us'."
  echo
  echo "  --local_repo < url >"
  echo
  echo "    Local Alpine repository for *additional* packages."
  echo
  echo "  --local_repo_sig_file < filename >"
  echo
  echo "    Signature file used to sign pacakges in local Alpine repository."
  echo
  echo "  --locale < locale >"
  echo
  echo "    Defaults to 'en_US'."
  echo
  echo "  --mirror < mirror url >"
  echo
  echo "    URL of Alpine mirror site to use."
  echo
  echo "  --password < password >"
  echo
  echo "    Password for default user created upon 1st boot. Defaults to 'changeme'."
  echo
  echo "  --physical < pc | rpi2 | rpi3 | rpi4 >"
  echo
  echo "  --release < release >"
  echo
  echo "    Valid values are:  3.13 3.14 edge"
  echo
  echo "  --username <username>"
  echo
  echo "    Name of the default account to create upon 1st boot. Defaults to 'alpine'."
  echo
  echo "  --virtual <vm type>"
  echo
  echo "    Valid values are:  generic hyperv libvirtd openstack proxmox qemu"
  echo "                       virtualbox vmware"
  echo
}


#
# Check that the combination of CLI options make sense
#
validate_cli_options() {
  # If --debug not specified then debug defaults to off
  if [ -z ${DEBUG+x} ]; then
    DEBUG=no
  fi

  # If console name not specified then assume default
  if [ -z ${CONSOLE_NAME+x} ]; then
    CONSOLE_NAME=$DEFAULT_CONSOLE_NAME
  fi

  # If Alpine release not specified then assume default
  if [ -z ${IMAGE_ALPINE_RELEASE+x} ]; then
    IMAGE_ALPINE_RELEASE=$DEFAULT_ALPINE_RELEASE
  fi

  # If arch not specified then assume default
  if [ -z ${IMAGE_ARCH+x} ]; then
    IMAGE_ARCH=$DEFAULT_ARCH
  fi

  # If neither Cloud / VM / Physical specified then assume QEMU VM
  if [ -z ${IMAGE_CLASS+x} ]; then
    IMAGE_CLASS="vm"
    VM_TYPE="qemu"
  fi

  if [ -z "${IMAGE_FILENAME+x}" ]; then
    IMAGE_BASE_FILENAME="alpine-$IMAGE_ALPINE_RELEASE-$IMAGE_ARCH-$IMAGE_CLASS"
    case $IMAGE_CLASS in
      cloud )
        IMAGE_FILENAME="$IMAGE_BASE_FILENAME-$CLOUD_TYPE.img"
        ;;
      physical )
        IMAGE_FILENAME="$IMAGE_BASE_FILENAME-$PHYSICAL_TYPE.img"
        ;;
      vm )
        IMAGE_FILENAME="$IMAGE_BASE_FILENAME-$VM_TYPE.img"
        ;;
    esac
  fi

  # Log filename is based on image filename
  LOGFILE=$(echo $IMAGE_FILENAME | sed -e 's|\.img$|\.log|')
  :> "$LOGFILE"

  # If version of APK-static is not specified then assume default
  if [ -z ${APK_STATIC_VERSION+x} ]; then
    APK_STATIC_VERSION=$DEFAULT_APK_STATIC_VERSION
  fi

  # If URL to download APK-static is not specified then assume default
  if [ -z ${APK_STATIC_URL+x} ]; then
    APK_STATIC_URL=$DEFAULT_APK_STATIC_URL
  fi

  # If chroot directory not specified then assume default
  if [ -z ${CHROOT_DIRECTORY+x} ]; then
    CHROOT_DIRECTORY=$DEFAULT_CHROOT_DIRECTORY
  fi

  # If images directory not specified then assume default
  if [ -z ${IMAGES_DIRECTORY+x} ]; then
    IMAGES_DIRECTORY=$DEFAULT_IMAGES_DIRECTORY
  fi

  # If USE_RAMDISK specified then assume disabled
  if [ -n "${USE_RAMDISK+x}" ]; then
    if [ -z "${RAMDISK_DIRECTORY+x}" ]; then
      # If ramdisk directory not specified then assume default
      RAMDISK_DIRECTORY=$DEFAULT_RAMDISK_DIRECTORY
    fi
  else
    USE_RAMDISK="false"
  fi

  # If Alpine repo mirror site not specified then assume default
  if [ -z ${ALPINE_MIRROR_SITE+x} ]; then
    ALPINE_MIRROR_SITE=$DEFAULT_MIRROR_SITE
  fi

  if [ -z ${IMAGE_ENCRYPTED+x} ]; then
    IMAGE_ENCRYPTED=false
  fi

  # If boot_by_label not specified then assume default
  if [ -z ${IMAGE_BOOT_REFERENCE+x} ]; then
    IMAGE_BOOT_REFERENCE=$DEFAULT_BOOT_REFERENCE
  fi

  if [ -z ${IMAGE_DEFAULT_USERNAME+x} ]; then
    IMAGE_DEFAULT_USERNAME=$DEFAULT_USERNAME
  fi

  if [ -z ${IMAGE_DEFAULT_USER_PASSWORD+x} ]; then
    IMAGE_DEFAULT_USER_PASSWORD=$DEFAULT_USER_PASSWORD
  fi

  if [ -z ${IMAGE_KEYMAP+x} ]; then
    IMAGE_KEYMAP=$DEFAULT_KEYMAP
  fi

  if [ -z ${IMAGE_LOCALE+x} ]; then
    IMAGE_LOCALE=$DEFAULT_LOCALE
  fi

  if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
     [ "$IMAGE_ENCRYPTED" = "true" ]; then
    if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
      echo
      echo "Syslinux does not support a fully encrypted rootfs!"
      echo
      exit 2
    elif [ "$IMAGE_CLASS" = "cloud" ] && \
         [ "$CLOUD_TYPE" = "aws" ]; then
      echo
      echo "For AWS you should use an encrypted EBS device!"
      echo
      exit 2
    fi
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then

    # Check for cloud machines that other specified settings make sense

    case $IMAGE_ARCH in
      aarch64 )
        if [ -n "${IMAGE_BOOTLOADER+x}" ]; then
          if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
            echo
            echo "aarch64 cloud machine can only use Grub bootloader!"
            echo
            exit 2
          fi
        else
          IMAGE_BOOTLOADER="grub"
        fi

        case $CLOUD_TYPE in
          aws | oracle )
            ;;

          * )
            echo
            echo "aarch64 cloud images cannot be created for this cloud provider!"
            echo
            exit 2
            ;;
        esac

        # aarch VMs always use UEFI
        IMAGE_BOOT_TYPE="uefi"
        ;;

      x86_64 )
        case $CLOUD_TYPE in
          oracle )
            IMAGE_BOOT_TYPE="bios"
            IMAGE_BOOTLOADER="syslinux"
            ;;

          * )
            IMAGE_BOOT_TYPE="bios"
            IMAGE_BOOTLOADER="grub"
            ;;
        esac
        ;;
    esac

  elif [ "$IMAGE_CLASS" = "physical" ]; then

    # Check for physical machines that other specified settings make sense

    case $PHYSICAL_TYPE in
      pc )
        if [ -n "${IMAGE_BOOTLOADER+x}" ]; then
          IMAGE_BOOTLOADER="syslinux"
        fi

        if [ "$IMAGE_ARCH" = "x86" ]; then
          # x86
          if [ -n "${IMAGE_BOOT_TYPE+x}" ]; then
            IMAGE_BOOT_TYPE="bios"
          elif [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
            echo
            echo "UEFI is not supported for x86!"
            echo
            exit 2
          fi
        else
          # 86_64
          if [ -n "${IMAGE_BOOT_TYPE+x}" ]; then
            IMAGE_BOOT_TYPE="uefi"
          fi
        fi
        ;;

      rpi2 | rpi3 | rpi4 )
        if [ -z "${IMAGE_BOOTLOADER+x}" ]; then
          # Bootloader not specified
          IMAGE_BOOTLOADER="none"

          if [ -z ${IMAGE_BOOT_TYPE+x} ]; then
            # BIOS/UEFI/None not specified
            IMAGE_BOOT_TYPE="none"
          elif [ "$IMAGE_BOOT_TYPE" != "none" ]; then
            echo
            echo "An invalid boot type was specified! For an RPI only 'none' is valid"
            echo
            exit 2
          fi

        elif [ "${IMAGE_BOOTLOADER}" != "none" ]; then
          echo
          echo "An invalid bootloader was specified!"
          echo
          exit 2
        fi
        ;;
    esac
       
  elif [ "$IMAGE_CLASS" = "vm" ]; then

    # Check for Virtual Machines that other specified settings make sense

    case $IMAGE_ARCH in
      armv7 )
        echo
        echo "armv7 virtual machines are not supported!"
        echo
        exit 2
        ;; 

      aarch64 )
        if [ -n "${IMAGE_BOOTLOADER+x}" ]; then
          if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
            echo
            echo "aarch64 virtual machine can only use Grub bootloader!"
            echo
            exit 2
          fi
        else
          IMAGE_BOOTLOADER="grub"
        fi

        if [ "$VM_TYPE" = "virtualbox" ]; then
          echo
          echo "aarch64 Virtualbox images cannont be created!"
          echo
          exit 2
        fi

        # aarch VMs always use UEFI
        IMAGE_BOOT_TYPE="uefi"
        ;;

      x86 )
        if [ -n "${IMAGE_BOOTLOADER+x}" ]; then
          IMAGE_BOOTLOADER="syslinux"
        fi

        if [ -n "${IMAGE_BOOT_TYPE+x}" ]; then
          IMAGE_BOOT_TYPE="bios"
        elif [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
          echo
          echo "UEFI is not supported for x86!"
          echo
          exit 2
        fi
        ;;

      x86_64 )
        if [ -z ${IMAGE_BOOTLOADER+x} ]; then

          if [ -z ${IMAGE_BOOT_TYPE+x} ]; then
            IMAGE_BOOTLOADER="syslinux"
            IMAGE_BOOT_TYPE="uefi"
          elif [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
            IMAGE_BOOTLOADER="syslinux"
          else
            IMAGE_BOOTLOADER="syslinux"
          fi

        elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then

          if [ -z ${IMAGE_BOOT_TYPE+x} ]; then
            IMAGE_BOOT_TYPE="uefi"
          fi

        else

          if [ -z ${IMAGE_BOOT_TYPE+x} ]; then
            IMAGE_BOOT_TYPE="uefi"
          fi

        fi
        ;;
    esac
  fi
}


#
# Write debug messages only to the log file
#
write_debug_log() {
  if [ "$DEBUG" = "true" ]; then
    time=$(printf "[%s]" "$(date -u "+%Y-%m-%d %H:%M:%S")")
    echo "$time $1" >> "$LOGFILE"
  fi
}


#
# Write log messages to both the logfile and stdout
#
write_log() {
  time=$(printf "[%s]" "$(date -u "+%Y-%m-%d %H:%M:%S")")
  echo "$time $1" | tee -a "$LOGFILE"
}


#############################################################################
#############################################################################
##		Main Section
#############################################################################
#############################################################################

if [ "$(id -u)" -ne 0 ]; then
  echo
  echo "This script must be run as the root user!"
  echo
  exit 1
fi

# Check the host OS has necessary packages installed
check_required_packages

parse_cli_options "$@"

validate_cli_options

write_log "Using the following settings:"
write_log "  Image arch: $IMAGE_ARCH"
write_log "  Image class: $IMAGE_CLASS"
case $IMAGE_CLASS in
  cloud )
    write_log "  Cloud type: $CLOUD_TYPE"
    ;;
  physical )
    write_log "  Physical machine type: $PHYSICAL_TYPE"
    ;;
  vm )
    write_log "  VM type: $VM_TYPE"
    ;;
esac
write_log "  Alpine release: $IMAGE_ALPINE_RELEASE"
write_log "  Boot Type: $IMAGE_BOOT_TYPE"
write_log "  Bootloader: $IMAGE_BOOTLOADER"

DEST_IMAGE_FULL_FILENAME=$IMAGES_DIRECTORY/$IMAGE_FILENAME

if [ "$USE_RAMDISK" = "true" ]; then
  RAMDISK_IMAGE_FULL_FILENAME=$RAMDISK_DIRECTORY/$IMAGE_FILENAME
fi

#############################################################################
##		Prepare
#############################################################################

# Ensure if any errors that various clean operations happen
trap error_cleanup EXIT

# Ensure images directory exists
mkdir -p $IMAGES_DIRECTORY

if [ "$USE_RAMDISK" = "true" ]; then
  write_log "Setting up ramdisk"
  mkdir -p $RAMDISK_DIRECTORY
  mount -t tmpfs -o size=$RAMDISK_SIZE tmpfs $RAMDISK_DIRECTORY >> "$LOGFILE"
  FULL_FILENAME=$RAMDISK_IMAGE_FULL_FILENAME
else
  FULL_FILENAME=$DEST_IMAGE_FULL_FILENAME
fi

IMAGE_SIZE=$(calculate_image_size)

write_log "Creating sparse disk image of ${IMAGE_SIZE}MiB"
truncate -s "${IMAGE_SIZE}"M "$FULL_FILENAME" >> "$LOGFILE"

if [ "$IMAGE_BOOT_TYPE" = "none" ]; then
  partition_rpi
elif [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
  partition_bios
else
  partition_uefi
fi

if [ "$DEBUG" = "true" ]; then
  write_debug_log "  Resultant partition layout:"
  parted --machine --script --align=optimal "$FULL_FILENAME" \
    unit MiB \
    print \
    >> "$LOGFILE"
fi

write_log "Setting up loop device for disk image"
LOOP_DEVICE=$(losetup -P --show -f "$FULL_FILENAME" 2>> "$LOGFILE")
if [ -z "$LOOP_DEVICE" ]; then
  echo
  echo "There was a problem creating the loop device. Aborting!"
  echo
  exit 1
fi

if { [ -n "${IMAGE_ENCRYPTED+x}" ] && \
     [ "$IMAGE_ENCRYPTED" = "true" ]; } || \
   { [ -n "${IMAGE_ENCRYPT_REMOTE_UNLOCK+x}" ] && \
     [ "$IMAGE_ENCRYPT_REMOTE_UNLOCK" = "true" ]; }; then
  setup_luks_device
fi

format_and_mount_fs

if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
   [ "$IMAGE_ENCRYPTED" = "true" ]; then
  copy_luks_keyfile_into_place
fi

download_static_apk

# Create /etc directory inside chroot
mkdir -p "$CHROOT_DIRECTORY"/etc

# Copy system's resolv.conf into chroot
write_log "Copying system's /etc/resolv.conf into chroot filesystem"
cp /etc/resolv.conf "$CHROOT_DIRECTORY"/etc/

# Create repositories file inside chroot
mkdir -p "$CHROOT_DIRECTORY"/etc/apk/keys
write_log "Creating /etc/apk/repositories file inside chroot"
echo \
  "$ALPINE_MIRROR_SITE/$IMAGE_ALPINE_RELEASE/main" \
  > "$CHROOT_DIRECTORY"/etc/apk/repositories

if [ -n "${LOCAL_REPO_SIGNATURE_FILE+x}" ]; then
  write_log "Copy local repo key to /etc/apk/keys/ directory inside chroot"
  cp "$LOCAL_REPO_SIGNATURE_FILE" "$CHROOT_DIRECTORY"/etc/apk/keys/
fi

install_alpine_base

# Delete the static apk tool
rm -Rf $TMPDIR/apk-tools-$APK_STATIC_VERSION

# Mount special filesystems inside chroot
write_log "Mounting /proc, /sys, and /dev special filesystems in chroot"
{
  mount -t proc none "$CHROOT_DIRECTORY"/proc
  mount -t none -o rbind /sys "$CHROOT_DIRECTORY"/sys
  mount --make-rprivate "$CHROOT_DIRECTORY"/sys
  mount -t none -o rbind /dev "$CHROOT_DIRECTORY"/dev
  mount --make-rprivate "$CHROOT_DIRECTORY"/dev
} >> "$LOGFILE" 2>&1

define_additional_packages

#############################################################################
##		Create chroot script
#############################################################################

PREP_SCRIPT="chroot"
write_log "Creating $PREP_SCRIPT script"
cat <<EOF > "$CHROOT_DIRECTORY"/$PREP_SCRIPT
#!/bin/sh -eu
#
# Alpine $PREP_SCRIPT script
#

LANG="$IMAGE_LOCALE.UTF-8"

DEBUG="$DEBUG"
LOGFILE="/var/tmp/$PREP_SCRIPT.log"
EOF

if [ "$IMAGE_CLASS" = "physical" ]; then

  cat <<EOF >> "$CHROOT_DIRECTORY"/$PREP_SCRIPT
CIDATA_DIRECTORY="/cidata"
EOF

fi

cat <<EOF >> "$CHROOT_DIRECTORY"/$PREP_SCRIPT

############################################################################
##		Functions
############################################################################

#
# Work out the kernel version
#
get_kernel_version() {
EOF

case $IMAGE_CLASS in

  cloud | vm )
		KERNEL_PACKAGE="virt"
	  ;;

	physical )
		case $PHYSICAL_TYPE in
			pc )
				KERNEL_PACKAGE="lts"
				;;

			rpi2 | rpi3 )
				if [ "$IMAGE_ARCH" = "armv7" ]; then
				  KERNEL_PACKAGE="rpi2"
				else
				  KERNEL_PACKAGE="rpi"
				fi
				;;
			rpi4 )
  			KERNEL_PACKAGE="rpi4"
				;;
		esac
	  ;;
esac

cat <<EOF >> "$CHROOT_DIRECTORY"/$PREP_SCRIPT

  apk info linux-$KERNEL_PACKAGE | head -n 1 | sed -e 's/^linux-$KERNEL_PACKAGE-//' -e 's/-r/-/' -e 's/ .*//' -Ee 's/^(.*)\$/\\1-$KERNEL_PACKAGE/'

}

write_debug_log() {
  if [ "\$DEBUG" = "true" ]; then
    time=\$(printf "[%s]" "\$(date -u "+%Y-%m-%d %H:%M:%S")")
    echo "\$time $PREP_SCRIPT: \$1" >> "\$LOGFILE"
  fi
}

write_log() {
  time=\$(printf "[%s]" "\$(date -u "+%Y-%m-%d %H:%M:%S")")
  echo "\$time $PREP_SCRIPT: \$1" | tee -a "\$LOGFILE"
}

############################################################################
##		Main Section
############################################################################
EOF

if [ "$DEBUG" = "true" ]; then
  cat <<'EOF' >> "$CHROOT_DIRECTORY"/$PREP_SCRIPT

# Debug
write_log "Mounted filesystems:"
mount | \
  grep -E -v "(binfmt_misc|cgroup|debugfs|devpts|mqueue|proc|pstore|securityfs|sysfs|tmpfs)" \
  >> "$LOGFILE"
#write_log "Contents of /dev/mapper/ directory:"
#ls -l /dev/mapper/ >> "$LOGFILE"
df -m >> "$LOGFILE"
EOF
fi

configure_fstab

add_additional_repos

update_upgrade_packages

basic_os_configuration

setup_etc_modules

delete_users_groups

disable_extra_getty

add_base_init_d

install_additional_packages

additional_os_configuration

cat <<'EOF' >> "$CHROOT_DIRECTORY"/$PREP_SCRIPT

write_log "Running setup-cloud-init"
setup-cloud-init >> $LOGFILE 2>&1
EOF

tweak_cloud_init

if [ -n "${SERIAL_CONSOLE+x}" ] && \
   [ "$SERIAL_CONSOLE" = "true" ]; then

  enable_serial_console

fi

add_additional_init_d

disable_kernel_modules

configure_mkinitfs

install_kernel

if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
  configure_bootloader_grub
elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
  configure_bootloader_syslinux
elif [ "$IMAGE_CLASS" = "physical" ] && \
     [ -n "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" ]; then
  configure_bootloader_rpi
fi

if [ -n "${IMAGE_ENCRYPTED+x}" ] && \
  [ "$IMAGE_ENCRYPTED" = "true" ]; then
  # Ensure that initramfs is only readable by root as it
  # contains the keyfile to decrypt the root partition.
  case $IMAGE_CLASS in
    cloud | vm )
      INITRAMFS_FILENAME="initramfs-virt"
      ;;
    rpi )
      INITRAMFS_FILENAME="initramfs-rpi"
      ;;
    * )
      INITRAMFS_FILENAME="initramfs-lts"
      ;;
  esac
  cat <<EOF >> "$CHROOT_DIRECTORY"/$PREP_SCRIPT

  chmod 600 /boot/$INITRAMFS_FILENAME
EOF
fi

if [ "$DEBUG" = "true" ]; then
  cat <<EOF >> "$CHROOT_DIRECTORY"/$PREP_SCRIPT

{
  # Debug
  write_debug_log "mkinitfs contents:"
  mkinitfs -l "\$KERNEL_VERSION" >> \$LOGFILE
}
EOF
fi

if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
  install_grub
elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
  install_syslinux
fi

if [ "$DEBUG" = "true" ]; then
  cat <<EOF >> "$CHROOT_DIRECTORY"/$PREP_SCRIPT

{
  # Debug
  df -k >> \$LOGFILE
EOF

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    # UEFI

    if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then

      cat <<EOF >> "$CHROOT_DIRECTORY"/$PREP_SCRIPT

  #write_debug_log "Contents of /boot/EFI directory:"
  #ls -lR /boot/EFI >> "\$LOGFILE"

  write_debug_log "Contents of /boot/ directory:"
  ls -lR /boot/ >> "\$LOGFILE"
EOF

    else

      cat <<EOF >> "$CHROOT_DIRECTORY"/$PREP_SCRIPT

  write_debug_log "Contents of /efi directory:"
  ls -lR /efi >> "\$LOGFILE"
EOF

    fi

  fi

  cat <<EOF >> "$CHROOT_DIRECTORY"/$PREP_SCRIPT
}
EOF
fi

cat <<EOF >> "$CHROOT_DIRECTORY"/$PREP_SCRIPT

write_log "Finished $PREP_SCRIPT script"

exit

#############################################################################
##		The end of $PREP_SCRIPT
#############################################################################

EOF

chmod +x "$CHROOT_DIRECTORY"/$PREP_SCRIPT

if [ "$DEBUG" = "true" ]; then
  shellcheck -s ash "$CHROOT_DIRECTORY"/$PREP_SCRIPT
  RET_CODE=$?
  #if [ $RET_CODE != 0 ]; then
  #  exit 2
  #fi
fi

write_log "Running $PREP_SCRIPT script inside chroot"
chroot $CHROOT_DIRECTORY /$PREP_SCRIPT
RET_CODE=$?

# Add $PREP_SCRIPT logs to main logfile
cat "$CHROOT_DIRECTORY"/var/tmp/$PREP_SCRIPT.log >> "$LOGFILE"

if [ "$DEBUG" = "true" ]; then
  cp "$CHROOT_DIRECTORY"/$PREP_SCRIPT $PREP_SCRIPT.contents
fi

if [ $RET_CODE != 0 ]; then
  write_log "script $PREP_SCRIPT failed with return code: $RET_CODE"
  exit 1
fi

write_log "Deleting $PREP_SCRIPT script"
rm "$CHROOT_DIRECTORY"/$PREP_SCRIPT

write_log "Removing temporary /etc/resolv.conf from chroot filesystem"
rm "$CHROOT_DIRECTORY"/etc/resolv.conf

write_log "Cleaning up"
normal_cleanup

if [ "$USE_RAMDISK" = "true" ]; then
  write_log "Copying image from ramdisk to final location"
  cp "$RAMDISK_IMAGE_FULL_FILENAME" "$DEST_IMAGE_FULL_FILENAME"

  write_log "Unmounting ramdisk"
  umount $RAMDISK_DIRECTORY >> "$LOGFILE"
  rmdir $RAMDISK_DIRECTORY
fi

# Clear exit trap function
trap EXIT

exit
