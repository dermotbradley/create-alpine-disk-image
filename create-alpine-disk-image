#!/bin/sh -u
# shellcheck disable=SC1117
#
#############################################################################
##
##  create-alpine-disk-image
##
##  Copyright 2021 Dermot Bradley <dermot_bradley@yahoo.com>
##
##  Licensed via GPL version 2.0
##
#############################################################################
##
##  This script must be run as root user.
##
#############################################################################

SCRIPT_VERSION="0.2-DEV"


TMPDIR="/var/tmp"

DEFAULT_ADMIN_USERNAME="alpine"
DEFAULT_ALPINE_RELEASE="edge"
DEFAULT_APK_STATIC_VERSION="2.10.4"
DEFAULT_APK_STATIC_URL="https://github.com/alpinelinux/apk-tools/releases/download/v${DEFAULT_APK_STATIC_VERSION}"
DEFAULT_ARCH="x86_64"
DEFAULT_AUTH_CONTROL="sudo"
DEFAULT_BOOT_REFERENCE="uuid"
DEFAULT_BOOTFS_LABEL="boot"
DEFAULT_CONSOLE_NAME="tty0"
DEFAULT_DHCP_CLIENT="dhcpcd"
DEFAULT_EXT4_RESERVED_PERCENT="5"
DEFAULT_F2FS_RESERVED_PERCENT="40"
DEFAULT_FIREWALL="iptables"
DEFAULT_FS_TYPE="ext4"
DEFAULT_KEYMAP="us us"
DEFAULT_LOCALE="en_US"
DEFAULT_LOGSFS_LABEL="logs"
DEFAULT_LUKS_PASSPHRASE="InsecureDefault"
DEFAULT_MIRROR_SITE="https://alpine.global.ssl.fastly.net/alpine/"
DEFAULT_ROOTFS_LABEL="alpine-root"
DEFAULT_SERIAL_PORT_NUMBER="0"
DEFAULT_SERIAL_PORT_NAME="ttyS${DEFAULT_SERIAL_PORT_NUMBER}"
DEFAULT_SERIAL_PORT_SPEED="115200"
DEFAULT_SSH_SERVER="openssh"
DEFAULT_TIMEZONE="America/New_York"

DEFAULT_CHROOT_DIRECTORY="./chroot"
DEFAULT_IMAGES_DIRECTORY="./alpine-images"
DEFAULT_RAMDISK_DIRECTORY="./ramdisk"
RAMDISK_SIZE=3G

# Size in MiB
CIDATA_PART_SIZE=4

# Takes into account size of kernel & initramfs
CLOUD_BOOT_PART_SIZE=32
###CLOUD_ROOT_PART_SIZE=270
CLOUD_ROOT_PART_SIZE=325
CLOUD_UEFI_PART_SIZE=48
#
# Takes into account size of firmware, kernel and initramfs
PHYSICAL_BOOT_PART_SIZE=64
PHYSICAL_ROOT_PART_SIZE=450
PHYSICAL_UEFI_PART_SIZE=100
#
RPI_BOOT_PART_SIZE=64
###RPI_ROOT_PART_SIZE=224
RPI_ROOT_PART_SIZE=256
#
# Takes into account size of kernel & initramfs
VIRTUAL_BOOT_PART_SIZE=32
VIRTUAL_ROOT_PART_SIZE=240
VIRTUAL_UEFI_PART_SIZE=32

#
LVM_LOGS_LV_SIZE=4

#############################################################################
##		Functions
#############################################################################

#
# Enable some additional server-related init.d services
#
add_additional_init_d() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Adding additional init.d scripts"
{
EOF

  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
  ###rc-update add dmeventd boot
  rc-update add lvm boot
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add rngd boot
  rc-update add rsyslog boot

  rc-update add chronyd default
EOF

  case $IMAGE_SSH_SERVER in
    dropbear )
      cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add dropbear default
EOF
      ;;
    openssh )
      cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add sshd default
EOF
      ;;
    tinyssh )
      cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add tinysshd default
EOF
      ;;
  esac

  if [ "$IMAGE_ENABLE_UTMP" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add utmpd default
  rc-update add wtmpd default
EOF
  fi

  if [ "$IMAGE_CLASS" = "virtual" ]; then
    case $VM_TYPE in
      libvirtd | qemu )
        cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add qemu-guest-agent default
EOF
        ;;
      virtualbox )
        cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add virtualbox-guest-additions default
EOF
        ;;
      vmware )
        cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add open-vm-tools default
EOF
        ;;
    esac
  fi

  # No acpid running on Cloud or Virtual machines as tiny-power-button
  # or QEMU/Virtualbox/VMware agents which do not require it.
  if [ "$IMAGE_CLASS" = "physical" ] && \
     [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -eq 0 ]; then
    # acpid is not run on Raspberry PIs
    cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add acpid default
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
} >> /chroot.log 2>&1
EOF
}


#
# Add more Alpine repos to the repositories file
#
add_additional_repos() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Adding additional repos"

write_log "  Adding Community repo to /etc/apk/repositories"
cat <<-_SCRIPT_ >> /etc/apk/repositories
	$ALPINE_MIRROR_SITE/$IMAGE_ALPINE_RELEASE/community
	_SCRIPT_
EOF

  if [ "$IMAGE_ALPINE_RELEASE" = "edge" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Adding Testing repo to /etc/apk/repositories"
cat <<-_SCRIPT_ >> /etc/apk/repositories
	$ALPINE_MIRROR_SITE/$IMAGE_ALPINE_RELEASE/testing
	_SCRIPT_
EOF
  fi

  if [ -n "${LOCAL_ALPINE_REPOSITORY+x}" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Adding local repo to /etc/apk/repositories"
cat <<-_SCRIPT_ >> /etc/apk/repositories
	$LOCAL_ALPINE_REPOSITORY/$IMAGE_ALPINE_RELEASE
	_SCRIPT_
EOF
  fi
}


#
# Enable base Alpine init.d services
#
add_base_init_d() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Enable init.d scripts"
{
  rc-update add devfs sysinit
  rc-update add dmesg sysinit

  rc-update add bootmisc boot
  rc-update add hostname boot
  rc-update add modules boot
  rc-update add sysctl boot
  rc-update add swap boot
  rc-update add urandom boot

EOF

  if [ "$IMAGE_CLASS" = "cloud" ] || \
     [ "$IMAGE_CLASS" = "virtual" ] || \
     { [ "$IMAGE_CLASS" = "physical" ] && \
       [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -eq 0 ]; }; then
    # Everything except RPIs
    cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add osclock boot
EOF
  elif [ "$IMAGE_CLASS" = "physical" ] && \
     [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
    # RPIs
    if [ "$RPI_RTC" = "true" ]; then
      # With hardware RTC
      cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add osclock boot
EOF
    else
      # Without hardware RTC
      cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add swclock boot
EOF
    fi
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

  rc-update add crond default
  rc-update add networking default

  rc-update add killprocs shutdown
  rc-update add mount-ro shutdown
  rc-update add savecache shutdown
} >> /chroot.log 2>&1
EOF
}


#
# Adds an entry to the specified /etc/mkinitfs/features.d/*.modules file
#
add_initramfs_entry() {
  local modules_file=$1
  local modules_entry="$2"

  cat <<EOF >> "$RUN_SCRIPT"
	$modules_entry
EOF
}


#
# Insert required functions into the run script
#
add_runscript_functions() {
  cat <<EOF >> "$RUN_SCRIPT"

#############################################################################
##   Functions
#############################################################################

#
# Checks that the host OS has all necessary packages installed
#
check_for_required_packages() {
  local host_os

  host_os=\$(detect_host_os)
  case \$host_os in
    alpine )
EOF

  # Busybox losetup not suitable
  REQUIRED_LIST="blkid busybox parted util-linux"
  if [ "$IMAGE_FS_TYPE" = "btrfs" ]; then
    REQUIRED_LIST="$REQUIRED_LIST btrfs-progs btrfs-progs-extra"
  elif [ "$IMAGE_FS_TYPE" = "ext4" ]; then
    REQUIRED_LIST="$REQUIRED_LIST e2fsprogs"
  elif [ "$IMAGE_FS_TYPE" = "f2fs" ]; then
    REQUIRED_LIST="$REQUIRED_LIST f2fs-tools"
  elif [ "$IMAGE_FS_TYPE" = "xfs" ]; then
    REQUIRED_LIST="$REQUIRED_LIST xfsprogs xfsprogs-extra"
  fi
  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    REQUIRED_LIST="$REQUIRED_LIST cryptsetup"
  fi
  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    REQUIRED_LIST="$REQUIRED_LIST lvm2"
  fi
  ###if [ "${IMAGE_FOR_SSD}" = "true" ]; then
  ###  REQUIRED_LIST="$REQUIRED_LIST fstrim"
  ###fi

  cat <<EOF >> "$RUN_SCRIPT"
      REQUIRED_PACKAGES="$REQUIRED_LIST"
      # shellcheck disable=SC2086
      if ! apk info -e -q \$REQUIRED_PACKAGES; then
        echo
        echo "The following Alpine packages need to be installed:"
        echo "  \$REQUIRED_PACKAGES"
        echo
        exit 1
      fi
      ;;
    debian | ubuntu )
EOF

  REQUIRED_LIST="coreutils mount parted wget"
  if [ "$IMAGE_FS_TYPE" = "btrfs" ]; then
    REQUIRED_LIST="$REQUIRED_LIST btrfs-progs"
  elif [ "$IMAGE_FS_TYPE" = "ext4" ]; then
    REQUIRED_LIST="$REQUIRED_LIST e2fsprogs"
  elif [ "$IMAGE_FS_TYPE" = "f2fs" ]; then
    REQUIRED_LIST="$REQUIRED_LIST f2fs-tools"
  elif [ "$IMAGE_FS_TYPE" = "xfs" ]; then
    REQUIRED_LIST="$REQUIRED_LIST xfsprogs"
  fi
  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    REQUIRED_LIST="$REQUIRED_LIST cryptsetup-bin"
  fi
  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    REQUIRED_LIST="$REQUIRED_LIST lvm2"
  fi

  cat <<EOF >> "$RUN_SCRIPT"
      REQUIRED_PACKAGES="$REQUIRED_LIST"
      if [ "\$(dpkg-query -W -f='\${Status}\n' "\$REQUIRED_PACKAGES")" -ne 0 ]; then
        echo
        echo "The following packages need to be installed:"
        echo "  \$REQUIRED_PACKAGES"
        echo
        exit 1
      fi
      ;;
    *)
      echo
      echo "Unsupported host OS!"
      echo
      exit 1
      ;;
  esac
}


#
# Check that the host OS has necessary packages installed for
# running user-mode QEMU via binfmt and that it is configured.
#
check_binfmt_packages() {
  local arch=\$1
  local host_arch host_os

  host_arch=\$(uname -m)

  if [ "\$host_arch" != "\$arch" ]; then
    host_os=\$(detect_host_os)
    case \$host_os in
      alpine )
        REQUIRED_PACKAGES="qemu-openrc"
        case \$arch in
          aarch64 )
            REQUIRED_PACKAGES="\$REQUIRED_PACKAGES qemu-aarch64" ;;
          armv7 )
            REQUIRED_PACKAGES="\$REQUIRED_PACKAGES qemu-arm" ;;
          x86 )
            REQUIRED_PACKAGES="\$REQUIRED_PACKAGES qemu-i386" ;;
          x86_64 )
            REQUIRED_PACKAGES="\$REQUIRED_PACKAGES qemu-x86_64" ;;
          * )
            echo "Unsupported archicture: \$arch!"
            exit 1
            ;;
        esac
        # shellcheck disable=SC2086
        if ! apk info -e -q \$REQUIRED_PACKAGES; then
          echo
          echo "The following Alpine packages need to be installed:"
          echo "  \$REQUIRED_PACKAGES"
          echo
          exit 1
        fi
        ;;
      debian | ubuntu )
        REQUIRED_PACKAGES="binfmt-support qemu-user-static"
        if [ "\$(dpkg-query -W -f='\${Status}\n' "\$REQUIRED_PACKAGES")" -ne 0 ]; then
          echo
          echo "The following packages need to be installed:"
          echo "  \$REQUIRED_PACKAGES"
          echo
          exit 1
        fi
        ;;
      * )
        echo
        echo "Unsupported host OS!"
        echo
        exit 1
        ;;
    esac

    # Is binfmt configured for this QEMU arch?
    case \$arch in
      aarch64 )
        BINFMT_FILE="/proc/sys/fs/binfmt_misc/qemu-aarch64" ;;
      armv7 )
        BINFMT_FILE="/proc/sys/fs/binfmt_misc/qemu-arm" ;;
      x86 )
        BINFMT_FILE="/proc/sys/fs/binfmt_misc/qemu-i386" ;;
      x86_64 )
        BINFMT_FILE="/proc/sys/fs/binfmt_misc/qemu-x86_64" ;;
    esac
    if [ -e "\$BINFMT_FILE" ]; then
      BINFMT_ARCH_ENABLED=\$(head -1 \${BINFMT_FILE})
      if [ "\$BINFMT_ARCH_ENABLED" = "enabled" ]; then
        return
      else
        echo
        echo "Binfmt is not enabled for \$arch"
        echo
        exit 1
      fi
    else
      echo
      echo "Binfmt and QEMU are not configured for \$arch"
      echo
      exit 1
    fi
  fi
}


#
# Determine the Linux distro that this script is being run on
#
detect_host_os() {
  local os

  os=\$(grep "^ID" /etc/os-release | sed -e 's/^ID=//')
  echo "\$os"
}


#
# Unmount filesystems whenever an error occurs in the script
#
error_cleanup() {
  write_log "An error occurred, cleaning up before aborting!"

  if [ -f "\$CHROOT_DIRECTORY"/chroot.log ]; then
    cat "\$CHROOT_DIRECTORY"/chroot.log >> "\$LOGFILE"
  fi

  normal_cleanup
EOF

  if [ -n "${RAMDISK_DIRECTORY+x}" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

  if mount | grep -q "$RAMDISK_DIRECTORY" ; then
    write_log "Unmounting ramdisk"
    umount "$RAMDISK_DIRECTORY" >> "$LOGFILE"
    rmdir "$RAMDISK_DIRECTORY"
  fi
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
}


#
# Get the UUID of the filesystem in the specified device
#
get_uuid_from_device() {
  local DEVICE=$1

  # shellcheck disable=SC2005
  echo "$(blkid -s UUID "$DEVICE" | sed -E -e 's|^.*UUID="(.*)"|\1|')"
}


#
# Unmount filesystems mounted inside chroot directory
#
normal_cleanup() {
  write_log "Normal cleanup"

  # Unmount special filesystems
  if mount | grep -q "$CHROOT_DIRECTORY"/dev ; then
    write_log "  Unmounting /dev inside chroot"
    umount -l -f "$CHROOT_DIRECTORY"/dev >> "$LOGFILE"
  fi
  if mount | grep -q "$CHROOT_DIRECTORY"/sys ; then
    write_log "  Unmounting /sys inside chroot"
    umount -l -f "$CHROOT_DIRECTORY"/sys >> "$LOGFILE"
  fi
  if mount | grep -q "$CHROOT_DIRECTORY"/proc ; then
    write_log "  Unmounting /proc inside chroot"
    umount -l -f "$CHROOT_DIRECTORY"/proc >> "$LOGFILE"
  fi
EOF

  if [ "$NEEDS_BOOT_PARTITION" = "true" ] || \
     [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

  if mount | grep -q "$CHROOT_DIRECTORY"/boot ; then
    write_log "  Unmounting /boot filesystem"
    umount -l -f "$CHROOT_DIRECTORY"/boot >> "$LOGFILE"
  fi
EOF
  elif [ "$IMAGE_BOOT_TYPE" = "uefi" ] && \
       [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

  if mount | grep -q "$CHROOT_DIRECTORY"/boot ; then
    write_log "  Unmounting /boot bind-mounted from ESP filesystem"
    umount -l -f "$CHROOT_DIRECTORY"/boot >> "$LOGFILE"
  fi
EOF
  fi

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

  if mount | grep -q "$CHROOT_DIRECTORY"/efi ; then
    write_log "  Unmounting ESP filesystem"
    umount -l -f "$CHROOT_DIRECTORY"/efi >> "$LOGFILE"
  fi
EOF
  fi

  if [ "$IMAGE_CLASS" = "physical" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

  if mount | grep -q "$CHROOT_DIRECTORY/cidata" ; then
    write_log "  Unmounting cidata filesystem"
    umount -l -f "$CHROOT_DIRECTORY"/cidata >> "$LOGFILE"
  fi
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

  if mount | grep -q "$CHROOT_DIRECTORY" ; then
    write_log "  Unmounting root filesystem"
    umount -l -f "$CHROOT_DIRECTORY" >> "$LOGFILE"
  fi
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

  cryptsetup close cryptroot >> "$LOGFILE"
EOF
  elif [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

  vgchange -an >> "$LOGFILE"
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

  if [ -n "${LOOP_DEVICE+x}" ]; then
    write_log "  Freeing up loop device"
    losetup -d "$LOOP_DEVICE" >> "$LOGFILE"
  fi
}

#
# Write debug messages only to the log file
#
write_debug_log() {
EOF

  if [ "$DEBUG" = "true" ]; then
	  cat <<'EOF' >> "$RUN_SCRIPT"
  current_time=$(printf "[%s]" "$(date -u "+%Y-%m-%d %H:%M:%S")")
  echo "$current_time $1" >> "$LOGFILE"
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"
  # Debug not enabled so do nothing
  true
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
}


#
# Write log messages to both the logfile (with timestamp) and stdout
#
write_log() {
  current_time=$(printf "[%s]" "$(date -u "+%Y-%m-%d %H:%M:%S")")
  echo "$current_time $1" >> "$LOGFILE"
  echo "$1"
}

#############################################################################
##   Main Section
#############################################################################

# Ensure if any errors occur that various cleanup operations happen
trap error_cleanup EXIT
EOF

  cat <<EOF >> "$RUN_SCRIPT"

CHROOT_DIRECTORY="$CHROOT_DIRECTORY"
IMAGES_DIRECTORY="$IMAGES_DIRECTORY"
TMPDIR="/var/tmp"

IMAGE_FILENAME="$IMAGE_FILENAME"
LOGFILE="$LOGFILE"

EOF

  if [ -n "${IMAGE_DEFAULT_USER_PASSWORD+x}" ]; then
    cat <<EOF >> "$RUN_SCRIPT"
DEFAULT_USER_PASSWORD="$IMAGE_DEFAULT_USER_PASSWORD"

EOF
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<EOF >> "$RUN_SCRIPT"
ENCRYPTION_PASSPHRASE="$IMAGE_ENCRYPTION_PASSPHRASE"

EOF
  fi

  cat <<EOF >> "$RUN_SCRIPT"
# Create empty logfile
:> \$LOGFILE

EOF

if [ "$USE_RAMDISK" = "true" ]; then
  cat <<EOF >> "$RUN_SCRIPT"
RAMDISK_DIRECTORY="$RAMDISK_DIRECTORY"
IMAGE_FULL_FILENAME="\$RAMDISK_DIRECTORY/\$IMAGE_FILENAME"
EOF
else
  cat <<EOF >> "$RUN_SCRIPT"
IMAGE_FULL_FILENAME="\$IMAGES_DIRECTORY/\$IMAGE_FILENAME"
EOF
fi

}


#
# Additional OS configuration
#
additional_os_configuration() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Doing additional OS configuration"

# FIXUP: stop update-ca-certificates displaying a warning
sed -i \
  -e 's|/etc/ssl/certs|/etc/ssl/certs 2>/dev/null|' \
  /etc/ca-certificates/update.d/certhash

# Create empty file as rsyslog's logrotate config expects it
:> /var/log/mail.log
EOF

  if [ "$IMAGE_AUTH_CONTROL" = "doas" ] || \
     [ "$IMAGE_AUTH_CONTROL" = "both" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Adding doas configuration for wheel group"
cat <<-_SCRIPT_ > /etc/doas.d/00-configure-wheel-group.conf
	#
	# Allow members of group wheel to become root
	#
	permit persist :wheel
	_SCRIPT_
EOF
  fi

  tighten_sshd_configuration
}


#
# Basic OS configuration
#
basic_os_configuration() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Doing basic OS configuration"

write_log "  Setting the login message to be 'vague'"
printf '\nWelcome\n\n' > /etc/issue
EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    LOGIN_BANNER="Alpine $IMAGE_ARCH $CLOUD_TYPE Cloud server"
  elif [ "$IMAGE_CLASS" = "virtual" ]; then
    # Virtual machine
    LOGIN_BANNER="Alpine $IMAGE_ARCH $VM_TYPE VM server"
  else
    # Physical machine
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      LOGIN_BANNER="Alpine $IMAGE_ARCH PC server"
    elif [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      LOGIN_BANNER="Alpine $IMAGE_ARCH Raspberry Pi server"
    fi
  fi

  cat <<EOF >> "$RUN_SCRIPT"
printf '\n\n$LOGIN_BANNER\n\n' > /etc/motd
EOF

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting the keymap to '\$KEYMAP'"
setup-keymap \$KEYMAP >> "/chroot.log" 2>&1
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/profile.d/locale.sh /etc/profile.d/locale.sh-orig
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting locale to \$LOCALE.UTF-8"
sed -i -E \
  -e "s/^(export LANG=)C.UTF-8/\1\$LOCALE.UTF-8/" \
  /etc/profile.d/locale.sh
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/profile.d/locale.sh-orig /etc/profile.d/locale.sh \
    >> /chroot.log \
    || true
  rm /etc/profile.d/locale.sh-orig

  cp /etc/rc.conf /etc/rc.conf-orig
}
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Fixup rc.conf so that keyboards and screens use Unicode"
sed -i -e 's/^#unicode="NO"/unicode="YES"/' /etc/rc.conf
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/rc.conf-orig /etc/rc.conf \
    >> /chroot.log \
    || true
  rm /etc/rc.conf-orig
}
EOF
  fi

  if [ "$IMAGE_ALPINE_RELEASE" = "v3.13" ]; then
    COLOR_PROMPT_FILE="color_prompt"
  else
    COLOR_PROMPT_FILE="color_prompt.sh.disabled"
  fi

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Enable colour shell prompt"
cp \
  /etc/profile.d/${COLOR_PROMPT_FILE} \
  /etc/profile.d/color_prompt.sh

rmdir /media/floppy
EOF
}


#
# Calculate size of the resultant disk image taking into account
# whether bootloader, boot and cloud-init partitions are needed.
#
calculate_image_size() {
  local IMAGE_TOTAL_SIZE

  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    IMAGE_TOTAL_SIZE=$(($(calculate_lvm_vg_size) + 4))
  else
    IMAGE_TOTAL_SIZE=$(calculate_root_part_size)
  fi

  if [ "$IMAGE_CLASS" = "physical" ]; then
    IMAGE_TOTAL_SIZE="$((IMAGE_TOTAL_SIZE + CIDATA_PART_SIZE))"
  fi

  if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
    IMAGE_TOTAL_SIZE="$((IMAGE_TOTAL_SIZE + $(calculate_boot_part_size)))"
  fi

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    IMAGE_TOTAL_SIZE="$((IMAGE_TOTAL_SIZE + $(calculate_uefi_part_size)))"
  fi

  if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
	  # Allow for 1MiB boot sector
    IMAGE_TOTAL_SIZE="$((IMAGE_TOTAL_SIZE + 1))"
  fi

  echo "$IMAGE_TOTAL_SIZE"
}



#
# Calculate size of the boot partition if it is required.
#
calculate_boot_part_size() {
  local SIZE FS_TOTAL_SIZE

  if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
    FS_TOTAL_SIZE=$((BOOT_PART_SIZE))
    if [ "$IMAGE_FS_TYPE" = "ext4" ]; then
      # Allow for Ext4 FS reserved percentage
      SIZE=$((FS_TOTAL_SIZE + (FS_TOTAL_SIZE * DEFAULT_EXT4_RESERVED_PERCENT / 100 + 1)))
    elif [ "$IMAGE_FS_TYPE" = "f2fs" ]; then
      # Allow for F2FS overprovision percentage
      SIZE=$((FS_TOTAL_SIZE + (FS_TOTAL_SIZE * DEFAULT_F2FS_RESERVED_PERCENT / 100 + 1)))
    else
      SIZE=$FS_TOTAL_SIZE
    fi
  else
    SIZE=0
  fi

  echo "$SIZE"
}



#
# Calculate size of the LUKS partition taking into account whether
# separate boot partition is not needed (so boot files add to size).
#
calculate_luks_part_size() {
  local LUKS_TOTAL_SIZE SIZE

  LUKS_TOTAL_SIZE=$ROOT_PART_SIZE
  if [ "$NEEDS_BOOT_PARTITION" != "true" ]; then
    LUKS_TOTAL_SIZE=$((LUKS_TOTAL_SIZE + BOOT_PART_SIZE))
  fi
  if [ "$IMAGE_FS_TYPE" = "ext4" ]; then
    # Allow for Ext4 FS reserved percentage
    SIZE=$((LUKS_TOTAL_SIZE + (LUKS_TOTAL_SIZE * DEFAULT_EXT4_RESERVED_PERCENT / 100 + 1)))
  elif [ "$IMAGE_FS_TYPE" = "f2fs" ]; then
    # Allow for F2FS overprovision percentage
    SIZE=$((LUKS_TOTAL_SIZE + (LUKS_TOTAL_SIZE * DEFAULT_F2FS_RESERVED_PERCENT / 100 + 1)))
  else
    SIZE=$LUKS_TOTAL_SIZE
  fi

  echo "$SIZE"
}



#
# LVM extents are 4MiB in size and so the size of a LV must be rounded
# up to the nearest 4MiM multiple
#
lvm_round_extents() {
  local extent rounded size

  size=$1

  # 4MiB
  extent=4

  rounded=$(echo "$size $extent" | awk '{print int(($1/$2)+0.75)*$2}')
  echo "$rounded"
}



#
# Calculate size of the LVM boot LV.
#
calculate_lvm_boot_lv_size() {
  local BOOT_TOTAL_SIZE LV_TOTAL_SIZE

  BOOT_TOTAL_SIZE=$BOOT_PART_SIZE

  if [ "$IMAGE_FS_TYPE" = "ext4" ]; then
    # Allow for Ext4 FS reserved percentage
    BOOT_TOTAL_SIZE=$((BOOT_TOTAL_SIZE + (BOOT_TOTAL_SIZE * DEFAULT_EXT4_RESERVED_PERCENT / 100 + 1)))
  elif [ "$IMAGE_FS_TYPE" = "f2fs" ]; then
    # Allow for F2FS overprovision percentage
    BOOT_TOTAL_SIZE=$((BOOT_TOTAL_SIZE + (BOOT_TOTAL_SIZE * DEFAULT_F2FS_RESERVED_PERCENT / 100 + 1)))
  fi

  # Round up to next 4MiB extent
  LV_TOTAL_SIZE=$(lvm_round_extents $BOOT_TOTAL_SIZE)
  echo "$LV_TOTAL_SIZE"
}



#
# Calculate size of the LVM logs LV.
#
calculate_lvm_logs_lv_size() {
  local LOGS_TOTAL_SIZE LV_TOTAL_SIZE

  LOGS_TOTAL_SIZE=$LVM_LOGS_LV_SIZE

  if [ "$IMAGE_FS_TYPE" = "ext4" ]; then
    # Allow for Ext4 FS reserved percentage
    LOGS_TOTAL_SIZE=$((LOGS_TOTAL_SIZE + (LOGS_TOTAL_SIZE * DEFAULT_EXT4_RESERVED_PERCENT / 100 + 1)))
  elif [ "$IMAGE_FS_TYPE" = "f2fs" ]; then
    # Allow for F2FS overprovision percentage
    LOGS_TOTAL_SIZE=$((LOGS_TOTAL_SIZE + (LOGS_TOTAL_SIZE * DEFAULT_F2FS_RESERVED_PERCENT / 100 + 1)))
  fi

  # Round up to next 4MiB extent
  LV_TOTAL_SIZE=$(lvm_round_extents $LOGS_TOTAL_SIZE)
  echo "$LV_TOTAL_SIZE"
}



#
# Calculate size of the LVM root LV.
#
calculate_lvm_root_lv_size() {
  local ROOT_TOTAL_SIZE LV_TOTAL_SIZE

  ROOT_TOTAL_SIZE=$ROOT_PART_SIZE

  if [ "$IMAGE_FS_TYPE" = "ext4" ]; then
    # Allow for Ext4 FS reserved percentage
    ROOT_TOTAL_SIZE=$((ROOT_TOTAL_SIZE + (ROOT_TOTAL_SIZE * DEFAULT_EXT4_RESERVED_PERCENT / 100 + 1)))
  elif [ "$IMAGE_FS_TYPE" = "f2fs" ]; then
    # Allow for F2FS overprovision percentage
    ROOT_TOTAL_SIZE=$((ROOT_TOTAL_SIZE + (ROOT_TOTAL_SIZE * DEFAULT_F2FS_RESERVED_PERCENT / 100 + 1)))
  fi

  # Round up to next 4MiB extent
  LV_TOTAL_SIZE=$(lvm_round_extents $ROOT_TOTAL_SIZE)
  echo "$LV_TOTAL_SIZE"
}



#
# Calculate size of the LVM partition taking into account whether
# separate boot partition is not needed (so boot files add to size).
#
calculate_lvm_vg_size() {
  local BOOT_TOTAL_SIZE ROOT_TOTAL_SIZE LOGS_TOTAL_SIZE VG_TOTAL_SIZE

  if [ "$NEEDS_BOOT_PARTITION" != "true" ]; then
    BOOT_TOTAL_SIZE=$(calculate_lvm_boot_lv_size)
  fi
  ROOT_TOTAL_SIZE=$(calculate_lvm_root_lv_size)
  LOGS_TOTAL_SIZE=$(calculate_lvm_logs_lv_size)

  if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
    VG_TOTAL_SIZE=$((ROOT_TOTAL_SIZE + LOGS_TOTAL_SIZE))
  else
    VG_TOTAL_SIZE=$((BOOT_TOTAL_SIZE + ROOT_TOTAL_SIZE + LOGS_TOTAL_SIZE))
  fi
  echo "$VG_TOTAL_SIZE"
}



#
# Calculate size of the root partition taking into account whether
# separate boot partition is not needed (so boot files add to size of root).
#
calculate_root_part_size() {
  local SIZE FS_TOTAL_SIZE

  FS_TOTAL_SIZE=$ROOT_PART_SIZE
  if [ "$NEEDS_BOOT_PARTITION" != "true" ]; then
    FS_TOTAL_SIZE=$((FS_TOTAL_SIZE + BOOT_PART_SIZE))
  fi
  if [ "$IMAGE_FS_TYPE" = "ext4" ]; then
    # Allow for Ext4 FS reserved percentage
    SIZE=$((FS_TOTAL_SIZE + (FS_TOTAL_SIZE * DEFAULT_EXT4_RESERVED_PERCENT / 100 + 1)))
  elif [ "$IMAGE_FS_TYPE" = "f2fs" ]; then
    # Allow for F2FS overprovision percentage
    SIZE=$((FS_TOTAL_SIZE + (FS_TOTAL_SIZE * DEFAULT_F2FS_RESERVED_PERCENT / 100 + 1)))
  else
    SIZE=$FS_TOTAL_SIZE
  fi

  echo "$SIZE"
}



#
# Calculate size of the UEFI ESP partition taking into account if it will
# also contain boot files.
#
calculate_uefi_part_size() {
  local SIZE FS_TOTAL_SIZE

  FS_TOTAL_SIZE=$((UEFI_PART_SIZE))

  if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
    # There is size of boot files to account for when
    # using Syslinux as then EFI partition is also /boot.
    FS_TOTAL_SIZE="$((FS_TOTAL_SIZE + BOOT_PART_SIZE))"
  fi

  SIZE=$FS_TOTAL_SIZE
  echo "$SIZE"
}



#
# Configure Grub
#
configure_bootloader_grub() {
  local MODULES

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Configuring Grub"
mkdir -p /boot/grub
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
write_debug_log "  Root fs partition device is $ROOT_PART_DEVICE"
write_debug_log "  Loopback device is $LOOP_DEVICE"
EOF
  fi

  # Busybox's losetup is not suitable when installing Grub on a loopback
  # device as it may truncate the name of the underlying filename.
  cat <<'EOF' >> "$RUN_SCRIPT"
write_log "  Installing util-linux package for losetup"
apk add --quiet util-linux
EOF

  if [ "$IMAGE_BOOT_REFERENCE" = "label" ]; then

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
  cp /etc/grub.d/10_linux /etc/grub.d/10_linux-orig
	cp /usr/share/grub/grub-mkconfig_lib /usr/share/grub/grub-mkconfig_lib-orig
	cp /usr/sbin/grub-mkconfig /usr/sbin/grub-mkconfig-orig
}
EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Temporarily installing patch program"
apk add --quiet patch >> $LOGFILE
write_log "  Patching /etc/grub.d/10_linux"
cat <<-'_SCRIPT_' | patch /etc/grub.d/10_linux >> $LOGFILE
	--- /etc/grub.d/10_linux
	+++ /etc/grub.d/10_linux-label
	@@ -44,7 +44,8 @@
	 # the initrds that Linux uses don't like that.
	 case ${GRUB_DEVICE} in
	   /dev/loop/*|/dev/loop[0-9])
	-    GRUB_DEVICE=`losetup ${GRUB_DEVICE} | sed -e "s/^[^(]*(\([^)]\+\)).*/\1/"`
	+    # Work with both Busybox and util-linux versions of losetup
	+    GRUB_DEVICE=`losetup ${GRUB_DEVICE} | sed -e "s/^[^:]*: []0-9[\:]* [\(]*\([^)]\+\)[\)]*$/\1/"`
	   ;;
	 esac
	
	@@ -64,6 +65,10 @@
	   LINUX_ROOT_DEVICE=PARTUUID=${GRUB_DEVICE_PARTUUID}
	 else
	   LINUX_ROOT_DEVICE=UUID=${GRUB_DEVICE_UUID}
	+  GRUB_DEVICE_LABEL="$(blkid | grep "UUID=\"${GRUB_DEVICE_UUID}\"" | sed -e 's|^.* LABEL="||g' -e 's|".*||g' | head -1)"
	+  if [ "x${GRUB_ENABLE_LINUX_LABEL}" = "xtrue" ] ; then
	+    LINUX_ROOT_DEVICE=LABEL=${GRUB_DEVICE_LABEL}
	+  fi
	 fi
	
	 case x"$GRUB_FS" in
	_SCRIPT_

write_log "  Patching /usr/share/grub/grub-mkconfig_lib"
cat <<-'_SCRIPT_' | patch /usr/share/grub/grub-mkconfig_lib >> $LOGFILE
	--- grub-mkconfig_lib-stock
	+++ grub-mkconfig_lib-custom
	@@ -156,7 +156,9 @@
	   if [ "x$fs_hint" != x ]; then
	     echo "set root='$fs_hint'"
	   fi
	-  if fs_uuid="`"${grub_probe}" --device $@ --target=fs_uuid 2> /dev/null`" ; then
	+  if label="`${grub_probe} --device $@ --target=fs_label 2> /dev/null`" ; then
	+    echo "search --no-floppy --label --set=root ${label}"
	+  elif fs_uuid="`"${grub_probe}" --device $@ --target=fs_uuid 2> /dev/null`" ; then
	     hints="`"${grub_probe}" --device $@ --target=hints_string 2> /dev/null`" || hints=
	     echo "if [ x\$feature_platform_search_hint = xy ]; then"
	     echo "  search --no-floppy --fs-uuid --set=root ${hints} ${fs_uuid}"
	_SCRIPT_

write_log "  Patching /usr/sbin/grub-mkconfig"
cat <<-'_SCRIPT_' | patch /usr/sbin/grub-mkconfig >> $LOGFILE
	--- grub-mkconfig-stock
	+++ grub-mkconfig-custom
	@@ -135,10 +135,12 @@
	 GRUB_DEVICE="`${grub_probe} --target=device /`"
	 GRUB_DEVICE_UUID="`${grub_probe} --device ${GRUB_DEVICE} --target=fs_uuid 2> /dev/null`" || true
	 GRUB_DEVICE_PARTUUID="`${grub_probe} --device ${GRUB_DEVICE} --target=partuuid 2> /dev/null`" || true
	+GRUB_DEVICE_LABEL="`${grub_probe} --device ${GRUB_DEVICE} --target=fs_label 2> /dev/null`" || true
	 
	 # Device containing our /boot partition.  Usually the same as GRUB_DEVICE.
	 GRUB_DEVICE_BOOT="`${grub_probe} --target=device /boot`"
	 GRUB_DEVICE_BOOT_UUID="`${grub_probe} --device ${GRUB_DEVICE_BOOT} --target=fs_uuid 2> /dev/null`" || true
	+GRUB_DEVICE_BOOT_LABEL="`${grub_probe} --device ${GRUB_DEVICE_BOOT} --target=fs_label 2> /dev/null`" || true
	 
	 # Filesystem for the device containing our userland.  Used for stuff like
	 # choosing Hurd filesystem module.
	@@ -190,8 +192,10 @@
	 export GRUB_DEVICE \
	   GRUB_DEVICE_UUID \
	   GRUB_DEVICE_PARTUUID \
	+  GRUB_DEVICE_LABEL \
	   GRUB_DEVICE_BOOT \
	   GRUB_DEVICE_BOOT_UUID \
	+  GRUB_DEVICE_BOOT_LABEL \
	   GRUB_FS \
	   GRUB_FONT \
	   GRUB_PRELOAD_MODULES \
	@@ -226,6 +230,7 @@
	   GRUB_SERIAL_COMMAND \
	   GRUB_DISABLE_LINUX_UUID \
	   GRUB_DISABLE_LINUX_PARTUUID \
	+  GRUB_ENABLE_LINUX_LABEL \
	   GRUB_DISABLE_RECOVERY \
	   GRUB_VIDEO_BACKEND \
	   GRUB_GFXMODE \
	_SCRIPT_

write_log "  Uninstalling patch program"
apk del --quiet patch >> $LOGFILE
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
	write_debug_log "  Diff 10_linux:"
  diff -aur /etc/grub.d/10_linux-orig /etc/grub.d/10_linux \
    >> $LOGFILE \
    || true
  rm /etc/grub.d/10_linux-orig

  write_debug_log "  Diff grub-mkconfig_lib:"
  diff -aur \
    /usr/share/grub/grub-mkconfig_lib-orig /usr/share/grub/grub-mkconfig_lib \
    >> $LOGFILE \
  	|| true
  rm /usr/share/grub/grub-mkconfig_lib-orig

  write_debug_log "  Diff grub-mkconfig:"
  diff -aur \
    /usr/sbin/grub-mkconfig-orig /usr/sbin/grub-mkconfig \
    >> $LOGFILE \
  	|| true
  rm /usr/sbin/grub-mkconfig-orig

}
EOF
    fi

  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
write_debug_log "  Contents of /etc/grub.d/10_linux:"
cat /etc/grub.d/10_linux >> /chroot.log
cp /etc/default/grub /etc/default/grub-orig
EOF
  fi

  KERNEL_OPTS_LIST="rootfstype=$IMAGE_FS_TYPE"
  # Add modules list
  MODULES="$(define_cmdline_for_modules)"
  if [ -n "${MODULES}" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST modules=$MODULES"
  fi
  if [ "$CONSOLE_TYPE" = "serial" ] || \
     [ "$CONSOLE_TYPE" = "both" ]; then
    # Serial console
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST console=${SERIAL_PORT_NAME},${SERIAL_PORT_SPEED}"
  fi
  if [ "$CONSOLE_TYPE" = "normal" ] || \
     [ "$CONSOLE_TYPE" = "both" ]; then
    # Normal console
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST console=$CONSOLE_NAME"
  fi
  if [ "$IMAGE_BOOT_TYPE" = "bios" ] && \
     [ "$DEBUG" != true ]; then
    # With BIOS can disable graphics as "standard" VGA provides text output
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST nomodeset"
  fi
  if [ "$IMAGE_DISABLE_IPV6" = "true" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST ipv6.disable=1"
  fi
  if [ "$IMAGE_CLASS" = "cloud" ] || \
     [ "$IMAGE_CLASS" = "virtual" ]; then
    # Using tiny-power-button for Cloud/VMs but Busybox init doesn't
    # handle the usual signal this sends, so specify USR2 which Busybox
    # accepts for "poweroff" situations.
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST tiny_power_button.power_signal=12"
  fi
  if [ -n "${IMAGE_BOOTCHART+x}" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST chart"
  fi
  if [ "$IMAGE_HARDEN" = "true" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST lockdown=integrity"
  fi
  if [ "$DEBUG" != true ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST quiet"
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Update /etc/default/grub"
sed -i \
  -e 's|^GRUB_DISABLE_RECOVERY=.*$|GRUB_DISABLE_RECOVERY=false|g' \
  -e 's|^GRUB_TIMEOUT=.*$|GRUB_TIMEOUT=5|g' \
  /etc/default/grub
EOF

  cat <<EOF >> "$RUN_SCRIPT"
KERNEL_OPTS="$KERNEL_OPTS_LIST"
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # Add other LUKS-related cmdline entries
    cat <<'EOF' >> "$RUN_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS root=/dev/mapper/cryptroot"
KERNEL_OPTS="\$KERNEL_OPTS \$(define_cmdline_for_encryption)"
EOF

    if [ "$REMOTE_UNLOCK" != "true" ] && \
       [ "$NO_GRUB_ENCRYPTION" != "true" ]; then
      # Cryptkey is used for unlock rootfs without 2nd password prompt.
      # It doesn't apply when remote unlock is enabled as then /boot is
      # not encrypted for GRUB to manage, or when GRUB encryption is not
      # enabled at all.
      cat <<'EOF' >> "$RUN_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS cryptkey"
EOF
    fi
###  elif [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
###    # Add LVM-specific cmdline entry
###    cat <<'EOF' >> "$RUN_SCRIPT"
###KERNEL_OPTS="\$KERNEL_OPTS root=/dev/mapper/vg0-root"
###EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
{
  echo "GRUB_CMDLINE_LINUX_DEFAULT=\"\$KERNEL_OPTS\""
EOF

  if [ "$IMAGE_BOOT_REFERENCE" = "label" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
	echo 'GRUB_ENABLE_LINUX_LABEL=true'
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"
  echo 'GRUB_ENABLE_LINUX_LABEL=false'
EOF
  fi

  if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
  echo 'GRUB_GFXPAYLOAD_LINUX=text'
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
  echo 'GRUB_DISABLE_OS_PROBER=true'
  echo 'GRUB_RECORDFAIL_TIMEOUT=20'
} >> /etc/default/grub
EOF

  if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
if ! grep -q "^GRUB_TERMINAL=" /etc/default/grub; then
  echo 'GRUB_TERMINAL=console' >> /etc/default/grub
fi
EOF
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ] && \
     [ "$REMOTE_UNLOCK" != "true" ] && \
     [ "$NO_GRUB_ENCRYPTION" != "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
echo 'GRUB_ENABLE_CRYPTODISK=y' >> /etc/default/grub
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"
echo 'GRUB_ENABLE_CRYPTODISK=n' >> /etc/default/grub
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
  diff /etc/default/grub-orig /etc/default/grub \
    >> /chroot.log \
    || true
  rm /etc/default/grub-orig

  # Fudge
  sed -i -e 's|^set -e$|set -ex|' /usr/sbin/grub-mkconfig
}
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

####chmod g=,o= /etc/default/grub

write_log "  Generating GRUB config"
grub-mkconfig -o /boot/grub/grub.cfg >> /chroot.log 2>&1
EOF

  cat <<'EOF' >> "$RUN_SCRIPT"
write_log "  Checking GRUB config"
grub-script-check /boot/grub/grub.cfg >> /chroot.log

chmod g=,o= /boot/grub/grub.cfg
EOF
}


#
# Setup the config files used by Raspberry Pi bootloader
#
configure_bootloader_rpi() {
  local CMDLINE EXTRA_MODULES MODULES

  ###MODULES="sd-mod,usb-storage"
  MODULES=""
  EXTRA_MODULES="$(define_cmdline_for_modules)"
  if [ -n "${EXTRA_MODULES}" ]; then
    if [ -z "${MODULES}" ]; then
      MODULES="$EXTRA_MODULES"
    else
      MODULES="$MODULES,$EXTRA_MODULES"
    fi
  fi
  CMDLINE="rootfstype=$IMAGE_FS_TYPE ro"
  if [ -n "${MODULES}" ]; then
    CMDLINE="$CMDLINE modules=$MODULES"
  fi
  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    CMDLINE="$CMDLINE root=/dev/mapper/cryptroot \$(define_cmdline_for_encryption)"
  elif [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    CMDLINE="$CMDLINE root=/dev/mapper/vg0-root"
  else
    CMDLINE="$CMDLINE root=/dev/mmcblk0p${ROOT_PART_NUM}"
  fi
  if [ "$IMAGE_DISABLE_IPV6" = "true" ]; then
	  CMDLINE="$CMDLINE ipv6.disable=1"
	fi
  if [ -n "${IMAGE_BOOTCHART+x}" ]; then
    CMDLINE="$CMDLINE chart"
  fi
  if [ "$IMAGE_HARDEN" = "true" ]; then
    CMDLINE="$CMDLINE lockdown=integrity"
  fi
  CMDLINE="$CMDLINE console=${CONSOLE_NAME} quiet"

  cat <<EOF >> "$RUN_SCRIPT"

write_log "Create RPI bootloader configuration"

write_log "  Creating /boot/cmdline.txt"
cat <<-_SCRIPT_ > /boot/cmdline.txt
	$CMDLINE
	_SCRIPT_
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  write_debug_log "  /boot/cmdline.txt contents:"
  cat /boot/cmdline.txt >> /chroot.log
}
EOF
  fi

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Creating /boot/config.txt"
cat <<-_SCRIPT_ > /boot/config.txt
EOF

  if [ "$PHYSICAL_TYPE" = "rpi2" ] || \
     [ "$PHYSICAL_TYPE" = "all-rpi" ]; then
	  # RPI 2
	  cat <<'EOF' >> "$RUN_SCRIPT"
	[pi2]
	kernel=vmlinuz-rpi
	initramfs initramfs-rpi
EOF
  fi

  if [ "$PHYSICAL_TYPE" = "rpi3" ] || \
     [ "$PHYSICAL_TYPE" = "all-rpi" ]; then
	  # RPI 3
	  cat <<'EOF' >> "$RUN_SCRIPT"
	[pi3]
	kernel=vmlinuz-rpi
	initramfs initramfs-rpi
	[pi3+]
	kernel=vmlinuz-rpi
	initramfs initramfs-rpi
EOF
  fi

  if [ "$PHYSICAL_TYPE" = "rpi4" ] || \
     [ "$PHYSICAL_TYPE" = "all-rpi" ]; then
	  # RPI 4
	  cat <<'EOF' >> "$RUN_SCRIPT"
	[pi4]
	enable_gic=1
	kernel=vmlinuz-rpi4
	initramfs initramfs-rpi4
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	[all]
EOF

  if [ "$IMAGE_ARCH" = "aarch64" ]; then
	  cat <<'EOF' >> "$RUN_SCRIPT"
	arm_64bit=1
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	# Set GPU memory to 16MB when using cutdown bootloader
	gpu_mem=16
	include usercfg.txt
	_SCRIPT_
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
{

  # Debug
  write_debug_log "  /boot/config.txt contents:"
  cat /boot/config.txt >> /chroot.log
}
EOF
  fi

  if [ "$PHYSICAL_TYPE" != "all-rpi" ]; then
    if [ "$PHYSICAL_TYPE" != "rpi4" ]; then
	    # RPI 2 or RPI 3
      FIXUP_FILE="fixup_cd.dat"
      START_FILE="start_cd.elf"
    else
	    # RPI 4
      FIXUP_FILE="fixup4cd.dat"
      START_FILE="start4cd.elf"
  	fi
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Creating /boot/usercfg.txt"
cat <<-_SCRIPT_ > /boot/usercfg.txt
	fixup_file=$FIXUP_FILE
	start_file=$START_FILE
	
	# Default is 1
	boot_delay=1
	
	# Do not display rainbow screen.
	disable_splash=1
	
	# Prevent GPU ever going into turbo mode
	disable_auto_turbo=1
	
	# Rotate HDMI output 90 degrees clockwise
	###display_hdmi_rotate=1
	
	# Don't send CEC message during boot
	hdmi_ignore_cec_init=1
	
	# Enable I2C
	dtparam=i2c_arm=on
	
	# Disable Bluetooth
	dtoverlay=disable-bt
	# Disable Wifi
	dtoverlay=disable-wifi

	# Disable audio
	dtparam=audio=off
	
	# Disable I2S
	dtparam=i2s=off
	
	# Disable SPI
	dtparam=spi=off
	
	# Disable UART
	enable_uart=0	
	_SCRIPT_
EOF
  fi

  if [ "$RPI_RTC" = "true" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Adding RTC configuration to /boot/usercfg.txt"
cat <<-_SCRIPT_ >> /boot/usercfg.txt
	
	# Enable hardware I2C-based RTC
	dtoverlay=i2c-rtc,ds1307
	_SCRIPT_
EOF
  fi

  if [  -n "${RPI_POE_HAT+x}" ]; then
    cat <<EOF >> "$RUN_SCRIPT"
	
write_log "  Adding PoE HAT configuration to /boot/usercfg.txt"
cat <<-_SCRIPT_ >> /boot/usercfg.txt
	# PoE Hat Fan Speeds - start at 50, full speed by 80
	dtparam=poe_fan_temp0=50000
	dtparam=poe_fan_temp1=60000
	dtparam=poe_fan_temp2=70000
	dtparam=poe_fan_temp3=80000
	_SCRIPT_
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
{

  # Debug
  write_debug_log "  /boot/usercfg.txt contents:"
  cat /boot/usercfg.txt >> /chroot.log
}
EOF
  fi
}


#
# Configure Syslinux
#
configure_bootloader_syslinux() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Configuring Syslinux"
mkdir -p /boot
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
# Debug
cp /etc/update-extlinux.conf /etc/update-extlinux.conf-orig

EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
write_log "  Updating update-extlinux.conf"
EOF

  KERNEL_OPTS_LIST="rootfstype=$IMAGE_FS_TYPE"
  if [ "$CONSOLE_TYPE" = "serial" ] || \
     [ "$CONSOLE_TYPE" = "both" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST console=${SERIAL_PORT_NAME},${SERIAL_PORT_SPEED}"
  fi
  if [ "$CONSOLE_TYPE" = "normal" ] || \
     [ "$CONSOLE_TYPE" = "both" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST console=${CONSOLE_NAME}"
  fi
  if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST nomodeset"
  fi
  if [ "$IMAGE_DISABLE_IPV6" = "true" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST ipv6.disable=1"
  fi
  if [ -n "${IMAGE_BOOTCHART+x}" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST chart"
  fi
  if [ "$IMAGE_HARDEN" = "true" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST lockdown=integrity"
  fi
  KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST quiet"

  cat <<EOF >> "$RUN_SCRIPT"
KERNEL_OPTS="$KERNEL_OPTS_LIST"
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS \$(define_cmdline_for_encryption)"
EOF
  fi

  MODULES_LIST="$IMAGE_FS_TYPE"
  EXTRA_MODULES="$(define_cmdline_for_modules)"
  if [ -n "${EXTRA_MODULES}" ]; then
    MODULES_LIST="$MODULES_LIST,$EXTRA_MODULES"
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
FS_REFERENCE="/dev/mapper/cryptroot"
EOF
  elif [ "$IMAGE_BOOT_REFERENCE" = "label" ]; then
    # Use LABELs to refer to filesystems
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      cat <<EOF >> "$RUN_SCRIPT"
###FS_REFERENCE="LABEL=SYSTEM_EFI"
FS_REFERENCE="LABEL=$DEFAULT_ROOTFS_LABEL"
EOF
    else
      cat <<EOF >> "$RUN_SCRIPT"
FS_REFERENCE="LABEL=$DEFAULT_ROOTFS_LABEL"
EOF
    fi
  else
    # Use UUIDs to refer to filesystems
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
###FS_REFERENCE="UUID=$ESP_FS_UUID"
FS_REFERENCE="UUID=$ROOT_FS_UUID"
EOF
    else
      cat <<'EOF' >> "$RUN_SCRIPT"
FS_REFERENCE="UUID=$ROOT_FS_UUID"
EOF
    fi
  fi

  cat <<EOF >> "$RUN_SCRIPT"
MODULES="$MODULES_LIST"
EOF

  cat <<'EOF' >> "$RUN_SCRIPT"
sed -i \
  -e 's|^overwrite=(.*)\$|overwrite=1|g' \
  -e 's|^hidden=.*\$|hidden=0|g' \
  -e 's|^timeout=.*\$|timeout=3|g' \
  -e "s|^default_kernel_opts=.*\$|default_kernel_opts=\"\$KERNEL_OPTS\"|g" \
  -e "s|^root=.*\$|root=\$FS_REFERENCE|g" \
  /etc/update-extlinux.conf
if [ -n "${MODULES}" ]; then
  sed -i \
    -e "s|^modules=.*\$|modules=\$MODULES|g" \
    /etc/update-extlinux.conf
fi
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
  write_debug_log "  diff update-extlinux.conf"
  diff /etc/update-extlinux.conf-orig /etc/update-extlinux.conf \
    >> /chroot.log \
    || true
  rm /etc/update-extlinux.conf-orig
  write_debug_log "  update-extlinux.conf contents:"
  cat /etc/update-extlinux.conf >> /chroot.log
}
EOF
  fi
}


#
# Configure cloud-init
#
configure_cloud_init() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Configuring cloud-init"

write_log "  Running setup-cloud-init"
setup-cloud-init >> /chroot.log 2>&1
EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    define_cloud_settings
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    DATASOURCE_LIST="'NoCloud'"
  else
    # VM
    define_virtual_settings
  fi
  if [ -z "${DATASOURCE_LIST+x}" ]; then
    DATASOURCE_LIST="'None'"
  else
    DATASOURCE_LIST="$DATASOURCE_LIST,'None'"
  fi

  # Need to sort out serial console settings at this stage, after specific
  # clouds/VM types may/may not have overriden the defaults.
  if [ "$CONSOLE_TYPE" = "serial" ] || \
     [ "$CONSOLE_TYPE" = "both" ]; then
    if [ -z "${SERIAL_PORT_NUMBER+x}" ]; then
      SERIAL_PORT_NUMBER=$DEFAULT_SERIAL_PORT_NUMBER
      SERIAL_PORT_NAME=$DEFAULT_SERIAL_PORT_NAME
    fi
    if [ -z "${SERIAL_PORT_SPEED+x}" ]; then
      SERIAL_PORT_SPEED=$DEFAULT_SERIAL_PORT_SPEED
    fi
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/cloud/cloud.cfg /etc/cloud/cloud.cfg-orig

EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
cat <<-_SCRIPT_ > /etc/cloud/cloud.cfg
	# Tailored config file
	
	users:
	   - default
	_SCRIPT_
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Unlocking the root account"
cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	   - name: root
	     lock_passwd: False
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Locking the root account"
cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	   - name: root
	     lock_passwd: True
EOF
  fi

  if [ -n "${IMAGE_DEFAULT_USER_PASSWORD+x}" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
	_SCRIPT_

write_log "  Setting the default user's password"
cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	
	# The password for the default user account, changing it is forced on login.
	password: $DEFAULT_USER_PASSWORD
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	
	mount_default_fields: [~, ~, 'auto', 'defaults,nofail', '0', '2']
	resize_rootfs_tmp: /dev
	
	preserve_hostname: False
	
	# Modules that run in 'init' stage
	cloud_init_modules:
	  - migrator
	  - seed_random
	  - bootcmd
	  - write-files
	  - growpart
	  - resizefs
	  - disk_setup
	  - mounts
	  - set_hostname
	  - update_hostname
	  - update_etc_hosts
	  - resolv_conf
	  - ca-certs
	  - rsyslog
	  - users-groups
	  - ssh

	# Modules that run in 'config' stage
	cloud_config_modules:
	  - locale
	  - set-passwords
	  - apk-configure
	  - ntp
	  - timezone
	  - disable-ec2-metadata
	  - runcmd
	
	# Modules that run in 'final' stage
	cloud_final_modules:
	  - package-update-upgrade-install
	  - scripts-vendor
	  - scripts-per-once
	  - scripts-per-boot
	  - scripts-per-instance
	  - scripts-user
	  - ssh-authkey-fingerprints
	  - keys-to-console
	  - phone-home
	  - final-message
	  - power-state-change

	system_info:
	  distro: alpine
	  default_user:
EOF

  cat <<EOF >> "$RUN_SCRIPT"
	_SCRIPT_

write_log "  Setting the default username to '$IMAGE_ADMIN_USERNAME'"
cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	    name: $IMAGE_ADMIN_USERNAME
EOF

  if [ "$IMAGE_AUTH_CONTROL" = "doas" ] || \
     [ "$IMAGE_AUTH_CONTROL" = "both" ]; then
  cat <<EOF >> "$RUN_SCRIPT"
	    doas: ["permit persist $IMAGE_ADMIN_USERNAME"]
EOF
  fi

  if [ -n "${IMAGE_DEFAULT_USER_PASSWORD+x}" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
	_SCRIPT_

write_log "  Ensure default user's account is not locked as password is set"
cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	    lock_passwd: False
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"
	_SCRIPT_

write_log "  Ensure default user's account is locked (for password access)"
cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	    lock_passwd: True
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	    gecos: Default cloud-init user
EOF

  if [ "$IMAGE_AUTH_CONTROL" = "sudo" ] || \
     [ "$IMAGE_AUTH_CONTROL" = "both" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"
	    groups: [adm, sudo, wheel]
	    sudo: ["ALL=(ALL) NOPASSWD:ALL"]
EOF
  else
  cat <<'EOF' >> "$RUN_SCRIPT"
	    groups: [adm, wheel]
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	    shell: /bin/ash
	  paths:
	    cloud_dir: /var/lib/cloud/
	    templates_dir: /etc/cloud/templates/
EOF

  if [ "$IMAGE_SSH_SERVER" = "openssh" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"
	  ssh_svcname: sshd
EOF
  elif [ "$IMAGE_SSH_SERVER" = "tinyssh" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"
	  ssh_svcname: tinysshd
EOF
  fi

  cat <<EOF >> "$RUN_SCRIPT"
	_SCRIPT_

write_log "  Setting up DataSources list"
cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	
	datasource_list: [$DATASOURCE_LIST]
EOF

  if [ -n "${DATASOURCE_SETTINGS+x}" ]; then
    cat <<EOF >> "$RUN_SCRIPT"
	
	datasource:
	  $DATASOURCE_SETTINGS
EOF
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    case $CLOUD_TYPE in
      # Enable network interface hotplug for supported DataSources
      aws )
        cat <<'EOF' >> "$RUN_SCRIPT"
	
	updates:
	  network:
	    when: ['boot','hotplug']
EOF
        ;;
    esac
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	
	##############################################################
	#            SSH settings
	##############################################################
	
	# Prevent SSH access to root user
	disable_root: True
	
	# Delete any pre-existing SSH hosts keys
	ssh_deletekeys: True
	
	# Only create ED25519 SSH host key
	ssh_genkeytypes: ["ed25519"]
	
	# Disable SSH password authentication
	ssh_pwauth: False
	
	ssh:
	  # Show SSH host keys and their fingerprints on console
	  emit_keys_to_console: True
	# Do not show following SSH host key types on console (DSA is never shown)
	ssh_key_console_blacklist: [ "ssh-ecdsa", "ssh-ed25519", "rsa" ]
	
	# Display users' SSH key fingerprints on console/write to logfile.
	no_ssh_fingerprints: False
	
	##############################################################
	
	_SCRIPT_
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/cloud/cloud.cfg-orig \
    /etc/cloud/cloud.cfg \
    >> /chroot.log \
    || true
  rm /etc/cloud/cloud.cfg-orig

  cp /etc/cloud/cloud.cfg.d/05_logging.cfg \
    /etc/cloud/cloud.cfg.d/05_logging.cfg-orig
}
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Enabling cloud-init debugging"
sed -i \
  -E '\$!N; s/(class=.*Handler\n[[:space:]]*)level=INFO/\1level=DEBUG/g ;P;D' \
  /etc/cloud/cloud.cfg.d/05_logging.cfg
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Disabling cloud-init debugging"
sed -i \
  -E '\$!N; s/(class=.*Handler\n[[:space:]]*)level=DEBUG/\1level=INFO/g ;P;D' \
  /etc/cloud/cloud.cfg.d/05_logging.cfg
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/cloud/cloud.cfg.d/05_logging.cfg-orig \
    /etc/cloud/cloud.cfg.d/05_logging.cfg \
    >> /chroot.log \
    || true
  rm /etc/cloud/cloud.cfg.d/05_logging.cfg-orig
}
EOF
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    case $CLOUD_TYPE in
      azure )
        create_etc_filesystems "ISO"
        ;;
    esac
  elif [ "$IMAGE_CLASS" = "virtual" ]; then
    # Virtual machine
    create_etc_filesystems "ISO"
  else
    # Physical
    create_etc_filesystems "VFAT"
  fi

  if [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    create_cloud_init_yaml_files
  fi
}


#
# Place entries in /etc/fstab for various filesystems
#
configure_fstab() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Add /etc/fstab entries"
EOF

  # Root filesystem
  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry DEVICE "/dev/mapper/cryptroot" "/" "$IMAGE_FS_TYPE" "rw,relatime" "rootfs"
EOF
  elif [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry DEVICE "/dev/mapper/vg0-root" "/" "$IMAGE_FS_TYPE" "rw,relatime" "rootfs"
add_fstab_entry DEVICE "/dev/mapper/vg0-logs" "/var/log" "$IMAGE_FS_TYPE" "rw,relatime" "logsfs"
EOF
  else
    if [ "$IMAGE_CLASS" = "physical" ] && \
       [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      # RPI
      cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry LABEL "$DEFAULT_ROOTFS_LABEL" "/" "$IMAGE_FS_TYPE" "rw,relatime" "rootfs"
EOF
    else
      # Non-RPI
      case $IMAGE_BOOT_REFERENCE in
        label )
          cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry LABEL "$DEFAULT_ROOTFS_LABEL" "/" "$IMAGE_FS_TYPE" "rw,relatime" "rootfs"
EOF
          ;;
        * )
          cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry UUID "\$ROOT_FS_UUID" "/" "$IMAGE_FS_TYPE" "rw,relatime" "rootfs"
EOF
          ;;
      esac
    fi
  fi

  # UEFI ESP
	if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    local MOUNTPOINT="/efi"

    case $IMAGE_BOOT_REFERENCE in
      label )
        cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry LABEL "SYSTEM_EFI" "${MOUNTPOINT}" "vfat" "rw" "ESP filesystem"
EOF
        ;;
		  *)
        cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry UUID "\$ESP_FS_UUID" "${MOUNTPOINT}" "vfat" "rw" "ESP filesystem"
EOF
        ;;
		esac

    if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
add_fstab_entry BIND "/efi/EFI/boot" "/boot" "none" "rw,relatime" "/boot ESP bind-mount"
EOF
    fi
	fi

  # /boot
  if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
    if [ "$IMAGE_CLASS" = "physical" ] && \
       [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      # RPI 2, 3, or 4
      cat <<'EOF' >> "$RUN_SCRIPT"
mkdir /media/sdcard
add_fstab_entry LABEL "RPIBOOT" "/media/sdcard" "vfat" "rw,relatime" "/media/sdcard"
add_fstab_entry BIND "/media/sdcard" "/boot" "none" "rw,relatime" "/boot bind-mount"
EOF
    else
      # Not RPI 2, 3, or 4
      if [ "$IMAGE_BOOT_REFERENCE" = "label" ]; then
        cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry LABEL "$DEFAULT_BOOTFS_LABEL" "/boot" "$IMAGE_FS_TYPE" "rw,relatime" "boot"
EOF
      else
        cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry UUID "\$BOOT_FS_UUID" "/boot" "$IMAGE_FS_TYPE" "rw,relatime" "boot"
EOF
      fi
    fi
  elif [ -n "${IMAGE_LVM_ROOTFS+x}" ] && \
       [ "$NEEDS_BOOT_PARTITION" != "true" ]; then
    cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry DEVICE "/dev/mapper/vg0-boot" "/boot" "$IMAGE_FS_TYPE" "rw,relatime" "boot"
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  write_debug_log "  Resultant /etc/fstab contents:"
  cat /etc/fstab >> "/chroot.log"
}
EOF
  fi
}


#
# Configure mkinitfs so that only the modules necessary for the relevant
# image type are placed in the initramfs file.
#
configure_mkinitfs() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Configuring mkinitfs"

write_log "  Setting up mkinitfs.conf"
EOF

  if [ "$DEBUG" = "true" ]; then

    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/mkinitfs/mkinitfs.conf /etc/mkinitfs/mkinitfs.conf-orig

EOF
  fi

  FEATURES_LIST="base keymap network"
  if [ "$IMAGE_CLASS" != "physical" ] || \
     [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -eq 0 ]; then
    # For all except RPIs
    FEATURES_LIST="$FEATURES_LIST kms"
  fi
  FEATURES_LIST="$FEATURES_LIST $IMAGE_FS_TYPE"

  if [ -n "${IMAGE_BOOTCHART+x}" ]; then
    FEATURES_LIST="$FEATURES_LIST bootchart"
  fi
  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    FEATURES_LIST="$FEATURES_LIST lvm"
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud

    FEATURES_LIST="$FEATURES_LIST virtio"

    if [ "$CLOUD_TYPE" = "aws" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # AWS
      FEATURES_LIST="$FEATURES_LIST ena nvme"
    fi

  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical machine

    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      FEATURES_LIST="$FEATURES_LIST ata nvme scsi usb"
    elif [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      # Raspberry Pi
      FEATURES_LIST="$FEATURES_LIST mmc usb"
    fi

  elif [ "$IMAGE_CLASS" = "virtual" ]; then
    # Virtual Machine
    FEATURES_LIST="$FEATURES_LIST scsi virtio"
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    if [ "$IMAGE_BOOTLOADER" = "grub" ] && \
       [ "$REMOTE_UNLOCK" != "true" ] && \
       [ "$NO_GRUB_ENCRYPTION" != "true" ]; then
      # cryptkey is only needed when using GRUB encrypted /boot
      # to avoid being prompted both by GRUB and by initramfs for
      # the passphrase twice.
      FEATURES_LIST="$FEATURES_LIST cryptkey"
    fi
    # cryptsetup is required in all rootfs encryption situations
    FEATURES_LIST="$FEATURES_LIST cryptsetup"
    if [ "$REMOTE_UNLOCK" = "true" ]; then
      # enable SSH remote unlock functionality
      FEATURES_LIST="$FEATURES_LIST remote_unlock_luks"
    fi
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  mkinitfs features list is: $FEATURES_LIST"
EOF
  fi

  cat <<EOF >> "$RUN_SCRIPT"
sed -i \
  -e "s|^features=\".*\"|features=\"$FEATURES_LIST\"|" \
  /etc/mkinitfs/mkinitfs.conf
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/mkinitfs.conf-orig \
    /etc/mkinitfs/mkinitfs.conf \
    >> /chroot.log \
    || true

  cp /etc/mkinitfs/features.d/ata.modules \
    /etc/mkinitfs/features.d/ata.modules-orig
}
EOF
  fi

  # ata.modules
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/ata.modules"
EOF

  initialise_initramfs_entry "ata"
  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "ata" "# This file is empty for Cloud machines"
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical machine
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      add_initramfs_entry "ata" "kernel/drivers/ata/ahci.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/ahci_platform.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/ata_generic.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/ata_piix.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/libahci.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/libahci_platform.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/libata.ko"
    elif [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      add_initramfs_entry "ata" "# This file is empty for Raspberry Pi machines"
    fi
  elif [ "$IMAGE_CLASS" = "virtual" ]; then
    # Virtual Machine
    add_initramfs_entry "ata" "# This file is empty for Virtual machines"
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/ata.modules-orig \
    /etc/mkinitfs/features.d/ata.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/ata.modules-orig

  cp /etc/mkinitfs/features.d/base.modules \
    /etc/mkinitfs/features.d/base.modules-orig
}
EOF
  fi

  # base.modules
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/base.modules"
EOF

  initialise_initramfs_entry "base"
  if [ "$IMAGE_ARCH" != "aarch86" ] || \
     [ "$IMAGE_CLASS" != "virtual" ]; then
    # jitterentropy_rng is a module for all machines except for
    # aarch64 VMs where it is compiled into the linux-virt kernel.
    ###add_initramfs_entry "base" "kernel/crypto/jitterentropy_rng.ko"
    add_initramfs_entry "base" "# No jitterentropy_rng for now."
  fi

  if [ "$IMAGE_ARCH" = "aarch64" ]; then
    if [ "$IMAGE_CLASS" = "cloud" ] || \
       [ "$IMAGE_CLASS" = "virtual" ]; then
      # aarch64 Cloud and Virtual machines use minimal button module
      add_initramfs_entry "base" "kernel/drivers/acpi/tiny-power-button.ko"
    fi
  fi

  if [ "$IMAGE_ARCH" = "x86" ] || \
     [ "$IMAGE_ARCH" = "x86_64" ]; then
    if [ "$IMAGE_CLASS" = "cloud" ] || \
       [ "$IMAGE_CLASS" = "virtual" ]; then
      # x86 and x86_64 Cloud and Virtual machines use minimal button module
      add_initramfs_entry "base" "kernel/drivers/acpi/tiny-power-button.ko"
    else
      # x86 and x86_64 Physical machines use the normal button module
      add_initramfs_entry "base" "kernel/drivers/acpi/button.ko"
    fi
  fi

  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/base.modules-orig \
    /etc/mkinitfs/features.d/base.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/base.modules-orig
}
EOF
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ] && \
     [ "$IMAGE_BOOTLOADER" = "grub" ] && \
     [ "$REMOTE_UNLOCK" != "true" ] && \
     [ "$NO_GRUB_ENCRYPTION" != "true" ]; then
    # cryptkey.files

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/cryptkey.files \
    /etc/mkinitfs/features.d/cryptkey.files-orig
EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/cryptkey.files"
echo "/etc/crypttab" \
  >> /etc/mkinitfs/features.d/cryptkey.files
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/cryptkey.files-orig \
    /etc/mkinitfs/features.d/cryptkey.files \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/cryptkey.files-orig
}
EOF
    fi

  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # cryptsetup.modules

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/cryptsetup.modules \
    /etc/mkinitfs/features.d/cryptsetup.modules-orig
EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/cryptsetup.modules"
EOF

    initialise_initramfs_entry "cryptsetup"
    case $IMAGE_ARCH in
      aarch64 )
        add_initramfs_entry "cryptsetup" "kernel/arch/arm64/crypto/aes-arm64.ko"
        if [ "$IMAGE_CLASS" = "cloud" ]; then
          # Add Arm Crypto Extension modules for ARM64 servers
          add_initramfs_entry "cryptsetup" "kernel/arch/arm64/crypto/*-ce*.ko"
        fi

        ;;
      x86 | x86_64 )
        if [ -z ${IMAGE_GRAPHICS_VENDOR+X} ] || \
           [ "$IMAGE_GRAPHICS_VENDOR" = "intel" ]; then
          add_initramfs_entry "cryptsetup" "kernel/arch/x86/crypto/aesni-intel.ko"
          ##add_initramfs_entry "cryptsetup" "kernel/arch/x86/crypto/crc32c_intel.ko"
          ##add_initramfs_entry "cryptsetup" "kernel/arch/x86/crypto/ghash-clmulni-intel.ko"
        fi
        #add_initramfs_entry "cryptsetup" "kernel/arch/x86/crypto/*"
        ;;
    esac
    add_initramfs_entry "cryptsetup" "kernel/drivers/md/dm-crypt.ko"
    finish_initramfs_entry

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/cryptsetup.modules-orig \
    /etc/mkinitfs/features.d/cryptsetup.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/cryptsetup.modules-orig
}
EOF
    fi
  fi

  # kms.modules
  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/kms.modules \
  /etc/mkinitfs/features.d/kms.modules-orig
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/kms.modules"
EOF

  initialise_initramfs_entry "kms"
  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "kms" "kernel/drivers/gpu/drm/virtio"

    if [ "$CLOUD_TYPE" = "azure" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # Azure
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/hyperv_fb.ko"
    fi
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical machine
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      add_initramfs_entry "kms" "kernel/drivers/char/agp/agpgart.ko"
      if [ -z ${IMAGE_GRAPHICS_VENDOR+X} ] || \
         [ "$IMAGE_GRAPHICS_VENDOR" = "amd" ]; then
        add_initramfs_entry "kms" "kernel/drivers/char/agp/amd64-agp.ko"
        add_initramfs_entry "kms" "kernel/drivers/gpu/drm/amd"
        add_initramfs_entry "kms" "kernel/drivers/gpu/drm/radeon"
        add_initramfs_entry "kms" "kernel/drivers/video/fbdev/aty/radeonfb.ko"
      fi
      if [ -z ${IMAGE_GRAPHICS_VENDOR+X} ] || \
         [ "$IMAGE_GRAPHICS_VENDOR" = "intel" ]; then
        add_initramfs_entry "kms" "kernel/drivers/char/agp/intel-agp.ko"
        add_initramfs_entry "kms" "kernel/drivers/char/agp/intel-gtt.ko"
        add_initramfs_entry "kms" "kernel/drivers/gpu/drm/gma500"
        add_initramfs_entry "kms" "kernel/drivers/gpu/drm/i915"
        add_initramfs_entry "kms" "kernel/drivers/video/fbdev/intelfb"
      fi
      if [ -z ${IMAGE_GRAPHICS_VENDOR+X} ] || \
         [ "$IMAGE_GRAPHICS_VENDOR" = "nvidia" ]; then
        add_initramfs_entry "kms" "kernel/drivers/gpu/drm/nouveau"
        add_initramfs_entry "kms" "kernel/drivers/video/fbdev/nvidia"
      fi
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/i2c"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/scheduler"
      ###add_initramfs_entry "kms" "kernel/drivers/i2c/busses/i2c-amd*.ko"
      ###add_initramfs_entry "kms" "kernel/drivers/i2c/busses/i2c-piix4.ko"
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/uvesafb.ko"
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/vga16fb.ko"
    elif [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      add_initramfs_entry "kms" "# This file is empty for RPI machines"
      ###add_initramfs_entry "kms" "kernel/drivers/gpu/drm/vc4/vc4.ko"
      ###add_initramfs_entry "kms" "kernel/drivers/i2c"
      ###add_initramfs_entry "kms" "kernel/drivers/i2c/busses/i2c-bcm2708.ko"
    fi
  elif [ "$IMAGE_CLASS" = "virtual" ]; then
    # Virtual Machine
    if [ "$VM_TYPE" = "hyperv" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # Hyper-V
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/hyperv_fb.ko"
    fi

    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "proxmox" ] || \
       [ "$VM_TYPE" = "qemu" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # libvirtd / Proxmox / QEMU
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/bochs/bochs-drm.ko"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/virtio"
    fi

    if [ "$VM_TYPE" = "virtualbox" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # Virtualbox
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/vboxvideo/vboxvideo.ko"
    fi
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/kms.modules-orig \
    /etc/mkinitfs/features.d/kms.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/kms.modules-orig
}
EOF
  fi

  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then

    # lvm.modules
    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/lvm.modules \
    /etc/mkinitfs/features.d/lvm.modules-orig

EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/lvm.modules"
EOF

    initialise_initramfs_entry "lvm"
    add_initramfs_entry "lvm" "kernel/drivers/md/dm-mod.ko"
    add_initramfs_entry "lvm" "kernel/drivers/md/dm-snapshot.ko"
    add_initramfs_entry "lvm" "kernel/drivers/md/dm-thin-pool.ko"
    finish_initramfs_entry

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/lvm.modules-orig \
    /etc/mkinitfs/features.d/lvm.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/lvm.modules-orig
}
EOF
    fi
  fi

  # network.files
  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/network.files \
  /etc/mkinitfs/features.d/network.files-orig
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/network.files"
echo "# This file is empty for cloud/physical/virtual machines" \
  > /etc/mkinitfs/features.d/network.files
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/network.files-orig \
    /etc/mkinitfs/features.d/network.files \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/network.files-orig

  cp /etc/mkinitfs/features.d/network.modules \
    /etc/mkinitfs/features.d/network.modules-orig
}
EOF
  fi

  # network.modules
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/network.modules"
EOF

  initialise_initramfs_entry "network"
  add_initramfs_entry "network" "kernel/net/packet/af_packet.ko"

  if [ "$IMAGE_DISABLE_IPV6" != "true" ]; then
    add_initramfs_entry "network" "kernel/net/ipv6/ipv6.ko"
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "network" "kernel/drivers/net/virtio_net.ko"

    if [ "$CLOUD_TYPE" = "aws" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # AWS
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/amazon/ena"
    fi

    if [ "$CLOUD_TYPE" = "azure" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # Azure
      add_initramfs_entry "network" "kernel/drivers/net/hyperv"
    fi
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical machine
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      if [ -n "${IMAGE_ETHERNET_MODULE+x}" ]; then
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/${IMAGE_ETHERNET_MODULE}.ko"
        if [ "$IMAGE_ETHERNET_MODULE" = "realtek/r8169" ]; then
          add_initramfs_entry "network" "kernel/drivers/net/phy/realtek.ko"
        fi
      else
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/atheros/alx"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/broadcom/tg3.ko"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/e1000"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/e1000e"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/i40e"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/ice"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/igb"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/igbvf"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/igc"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/ixgb"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/ixgbe"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/ixgbevf"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/nvidia"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/realtek/r8169.ko"
        add_initramfs_entry "network" "kernel/drivers/net/phy/realtek.ko"
      fi
      add_initramfs_entry "network" "kernel/drivers/net/mii.ko"
    elif [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      add_initramfs_entry "network" "# No additions for Raspberry Pi machines"
    fi
  elif [ "$IMAGE_CLASS" = "virtual" ]; then
    # Virtual machine
    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "proxmox" ] || \
       [ "$VM_TYPE" = "qemu" ] || \
       [ "$VM_TYPE" = "virtualbox" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # libvirtd / Proxmox / QEMU / Virtualbox
      add_initramfs_entry "network" "kernel/drivers/net/virtio_net.ko"
    fi

    if [ "$VM_TYPE" = "hyperv" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # Hyper-V
      add_initramfs_entry "network" "kernel/drivers/net/hyperv"
    fi

    if [ "$VM_TYPE" = "vmware" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # VMware
      add_initramfs_entry "network" "kernel/drivers/net/vmxnet3"
    fi
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/network.modules-orig \
    /etc/mkinitfs/features.d/network.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/network.modules-orig

  cp /etc/mkinitfs/features.d/nvme.modules \
    /etc/mkinitfs/features.d/nvme.modules-orig
}
EOF
  fi

  # nvme.modules
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/nvme.modules"
EOF

  initialise_initramfs_entry "nvme"
  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    if [ "$CLOUD_TYPE" = "aws" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # AWS
      add_initramfs_entry "nvme" "kernel/drivers/nvme/host/nvme.ko"
    else
      add_initramfs_entry "nvme" "# This file is empty for non-AWS Cloud machines"
    fi
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      add_initramfs_entry "nvme" "kernel/drivers/nvme/host/nvme.ko"
    elif [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      add_initramfs_entry "nvme" "# This file is empty for Raspberry Pi machines"
    fi
  elif [ "$IMAGE_CLASS" = "virtual" ]; then
    # Virtual machine
    add_initramfs_entry "nvme" "# This file is empty for Virtual machines"
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/nvme.modules-orig \
    /etc/mkinitfs/features.d/nvme.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/nvme.modules-orig

  cp /etc/mkinitfs/features.d/scsi.modules \
    /etc/mkinitfs/features.d/scsi.modules-orig
}
EOF
fi

  # scsi.modules
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/scsi.modules"
EOF

  initialise_initramfs_entry "scsi"
  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "scsi" "kernel/drivers/scsi/scsi_mod.ko"
    add_initramfs_entry "scsi" "kernel/drivers/scsi/sd_mod.ko"
    add_initramfs_entry "scsi" "kernel/drivers/scsi/virtio_scsi.ko"
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      ###add_initramfs_entry "scsi" "kernel/drivers/scsi/scsi_mod.ko"
      add_initramfs_entry "scsi" "kernel/drivers/scsi/sd_mod.ko"
      add_initramfs_entry "scsi" "kernel/drivers/scsi/ses.ko"
      add_initramfs_entry "scsi" "kernel/drivers/scsi/sg.ko"
      #######add_initramfs_entry "scsi" "kernel/drivers/scsi/sr_mod.ko"
    elif [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      add_initramfs_entry "scsi" "kernel/drivers/scsi/ses.ko"
    fi
  elif [ "$IMAGE_CLASS" = "virtual" ]; then
    # Virtual machine
    add_initramfs_entry "scsi" "kernel/drivers/scsi/sd_mod.ko"
    add_initramfs_entry "scsi" "kernel/drivers/scsi/virtio_scsi.ko"
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/scsi.modules-orig \
    /etc/mkinitfs/features.d/scsi.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/scsi.modules-orig

  cp /etc/mkinitfs/features.d/usb.modules \
    /etc/mkinitfs/features.d/usb.modules-orig
}
EOF
  fi

  # usb.modules
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/usb.modules"
EOF

  initialise_initramfs_entry "usb"
  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "usb" "# This file is empty for Cloud machines"
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      ###add_initramfs_entry "usb" "kernel/drivers/usb/storage/uas.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/usbhid"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-generic.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-cherry.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-apple.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/ehci-hcd.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/ehci-pci.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/ehci-platform.ko"
      if [ -z "${IMAGE_CPU_VENDOR+x}" ] || \
         [ "$IMAGE_CPU_VENDOR" != "intel" ]; then
        add_initramfs_entry "usb" "kernel/drivers/usb/host/ohci-hcd.ko"
        add_initramfs_entry "usb" "kernel/drivers/usb/host/ohci-pci.ko"
        add_initramfs_entry "usb" "kernel/drivers/usb/host/ohci-platform.ko"
      else
        add_initramfs_entry "usb" "kernel/drivers/usb/host/uhci-hcd.ko"
      fi
      add_initramfs_entry "usb" "kernel/drivers/usb/host/xhci-hcd.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/xhci-pci.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/storage/usb-storage.ko"
      add_initramfs_entry "usb" "kernel/fs/fat"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_cp*ko"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_iso8859*ko"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_utf8*ko"
    elif [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      add_initramfs_entry "usb" "kernel/drivers/usb/storage/uas.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/usbhid"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-generic.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-cherry.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-apple.ko"
      add_initramfs_entry "usb" "kernel/fs/fat"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_cp*ko"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_iso8859*ko"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_utf8*ko"
    fi
  elif [ "$IMAGE_CLASS" = "virtual" ]; then
    # Virtual machine
    add_initramfs_entry "usb" "# This file is empty for Virtual machines"
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/usb.modules-orig \
    /etc/mkinitfs/features.d/usb.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/usb.modules-orig

  cp /etc/mkinitfs/features.d/virtio.modules \
    /etc/mkinitfs/features.d/virtio.modules-orig
}
EOF
  fi

  # virtio.modules
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/virtio.modules"
EOF

  initialise_initramfs_entry "virtio"
  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "virtio" "kernel/drivers/block/virtio_blk.ko"
    if [ "$CONSOLE_TYPE" = "normal" ] || \
       [ "$CONSOLE_TYPE" = "both" ]; then
      add_initramfs_entry "virtio" "kernel/drivers/char/virtio_console.ko"
    fi
    add_initramfs_entry "virtio" "kernel/drivers/char/hw_random/virtio-rng.ko"
    add_initramfs_entry "virtio" "kernel/drivers/crypto/virtio*"
    add_initramfs_entry "virtio" "kernel/drivers/virtio/virtio_pci.ko"
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    add_initramfs_entry "virtio" "# This file is empty for Physical machines"
  elif [ "$IMAGE_CLASS" = "virtual" ]; then
    # Virtual machine
    add_initramfs_entry "virtio" "kernel/drivers/crypto/virtio*"
    add_initramfs_entry "virtio" "kernel/drivers/virtio/virtio_pci.ko"
    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "proxmox" ] || \
       [ "$VM_TYPE" = "qemu" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # libvirtd / Proxmox / QEMU
      add_initramfs_entry "virtio" "kernel/drivers/block/virtio_blk.ko"
      if [ "$CONSOLE_TYPE" = "normal" ] || \
         [ "$CONSOLE_TYPE" = "both" ]; then
        add_initramfs_entry "virtio" "kernel/drivers/char/virtio_console.ko"
      fi
      add_initramfs_entry "virtio" "kernel/drivers/char/hw_random/virtio-rng.ko"
      add_initramfs_entry "virtio" "kernel/drivers/virtio"
    fi

    if [ "$VM_TYPE" = "virtualbox" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # Virtualbox
      add_initramfs_entry "virtio" "kernel/drivers/virt/vboxguest/vboxguest.ko"
      add_initramfs_entry "virtio" "kernel/drivers/virtio/virtio.ko"
      add_initramfs_entry "virtio" "kernel/drivers/virtio/virtio_ring.ko"
    fi
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/virtio.modules-orig \
    /etc/mkinitfs/features.d/virtio.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/virtio.modules-orig

  # Fudge
  sed -i -e 's|^set -e$|set -ex|' /sbin/mkinitfs
}
EOF
  fi
}


#
# Copy LUKS keyfile into place
#
copy_luks_keyfile_into_place() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Moving LUKS keyfile into chroot directory"
mv crypto_keyfile.bin "$CHROOT_DIRECTORY"/
chmod 400 "$CHROOT_DIRECTORY"/crypto_keyfile.bin
EOF
}


#
# For physical machines create the cloud-init YAML config files
#
create_cloud_init_yaml_files() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Creating cloud-init YAML files for physical machine"

write_log "  Create example YAML files"
mkdir /cidata/examples

cat <<-_SCRIPT_ > /cidata/examples/meta-data
	instance-id: iid-local0
	_SCRIPT_

cat <<-_SCRIPT_ > /cidata/examples/network-dhcp
	version: 2
	ethernets:
	  eth0:
	    dhcpv4: yes
	    dhcpv6: yes
	_SCRIPT_

cat <<-_SCRIPT_ > /cidata/examples/network-static
	version: 2
	ethernets:
	  eth0:
	    addresses:
	      - 192.168.0.2/24
	    gateway4: 192.168.0.1
	_SCRIPT_

cat <<-_SCRIPT_ > /cidata/examples/user-data
	#cloud-config
	
	apk_repos:
	  preserve_repositories: False
	  alpine_repo:
EOF

  cat <<EOF >> "$RUN_SCRIPT"
	    version: '$IMAGE_ALPINE_RELEASE'
	    base_url: $ALPINE_MIRROR_SITE
	    community_enabled: True
EOF

  if [ "$IMAGE_ALPINE_RELEASE" = "edge" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
	    testing_enabled: True
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"
	    testing_enabled: False
EOF
  fi

  if [ -n "${LOCAL_ALPINE_REPOSITORY+x}" ]; then
    cat <<EOF >> "$RUN_SCRIPT"
	  local_repo_base_url: $LOCAL_ALPINE_REPOSITORY
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	
	package_reboot_if_required: False
	package_update: False
	package_upgrade: False
	
	
	debug:
	  verbose: False
EOF

  if [ -n "${IMAGE_FULL_HOSTNAME+x}" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
	
	# Hostname including domain
	fqdn: $FULL_HOSTNAME
EOF
  elif [ -n "${IMAGE_SHORT_HOSTNAME+x}" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
	
	# Hostname without domain
	hostname: \$SHORT_HOSTNAME
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	
	locale: \$LOCALE
	timezone: \$TIMEZONE
	
	ntp:
	  enabled: True
	  servers:
	    - pool.ntp.org
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    if [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      LUKS_REAL_DEVICE="/dev/mmcblk0"
      LUKS_REAL_PARTITION="/dev/mmcblk0p${LUKS_PART_NUM}"
    else
      LUKS_REAL_DEVICE="/dev/sda"
      LUKS_REAL_PARTITION="/dev/sda${LUKS_PART_NUM}"
    fi

    cat <<EOF >> "$RUN_SCRIPT"
	
	# Growpart & resize does not work for LUKS (yet) so this
	# will be handled via runcmd instead.
	growpart:
	  mode: False
	resize_rootfs: False
	
	runcmd:
	  # Grow the LUKS partition to fill the disk
	  - parted --machine --script --align=optimal $LUKS_REAL_DEVICE resize $LUKS_PART_NUM 100%
	  # Grow LUKS to fill the partition
	  - cryptsetup resize cryptroot
EOF
    if [ "$IMAGE_FS_TYPE" = "btrfs" ]; then
      cat <<EOF >> "$RUN_SCRIPT"
	  # Resize the underlying BTRFS root filesystem
	  - btrfs filesystem resize max /
EOF
    elif [ "$IMAGE_FS_TYPE" = "ext4" ]; then
      cat <<EOF >> "$RUN_SCRIPT"
	  # Resize the underlying Ext4 root filesystem
	  - resize2fs /
EOF
    elif [ "${IMAGE_FS_TYPE}" = "f2fs" ]; then
      cat <<EOF >> "$RUN_SCRIPT"
	  # Resize the underlying F2FS root filesystem
	  - resize.f2fs $LUKS_REAL_PARTITION
EOF
    elif [ "$IMAGE_FS_TYPE" = "xfs" ]; then
      cat <<EOF >> "$RUN_SCRIPT"
	  # Resize the underlying XFS filesystem
	  - xfs_growfs $LUKS_REAL_PARTITION
EOF
    fi
  elif [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    if [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      LVM_REAL_DEVICE="/dev/mmcblk0"
      LVM_REAL_PARTITION="/dev/mmcblk0p${LVM_PART_NUM}"
    else
      LVM_REAL_DEVICE="/dev/sda"
      LVM_REAL_PARTITION="/dev/sda${LVM_PART_NUM}"
    fi

    cat <<EOF >> "$RUN_SCRIPT"
	
	# Growpart & resize does not work for LVM (yet) so this
	# will be handled via runcmd instead.
	growpart:
	  mode: False
	resize_rootfs: False
	
	runcmd:
	  # Grow the LVM partition to fill the disk
	  - parted --machine --script --align=optimal $LVM_REAL_DEVICE resize $LVM_PART_NUM 100%
	  # Grow the LVM PV to fill the partition
	  - pvresize $LVM_REAL_PARTITION
	  # Grow the logs LV by 10M
	  - lvextend -L +10m logs
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"
	
	ssh:
	  # Whether to show either host keys or their fingerprints on console
	  emit_keys_to_console: False
EOF
  fi

  if [ -n "${SSH_PUBLIC_KEY+x}" ]; then

    # shellcheck disable=SC2129
    cat <<'EOF' >> "$RUN_SCRIPT"
	
	ssh_authorized_keys:
EOF

    # shellcheck disable=SC2028
    echo "\t  - '$SSH_PUBLIC_KEY'" >> "$RUN_SCRIPT"
    # shellcheck disable=SC2028
    echo "\t" >> "$RUN_SCRIPT"

  else
    cat <<'EOF' >> "$RUN_SCRIPT"
	
	#ssh_authorized_keys:
	#  - '<insert public SSH key here>'
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	
	_SCRIPT_

write_log "  Creating meta-data"
cp /cidata/examples/meta-data \
  /cidata/meta-data

write_log "  Creating network-config"
cp /cidata/examples/network-dhcp \
  /cidata/network-config

write_log "  Creating user-data"
cp /cidata/examples/user-data \
  /cidata/user-data
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
{

  # Debug

  write_debug_log "  meta-data contents:"
  cat /cidata/meta-data >> /chroot.log

  write_debug_log "  network-config contents:"
  cat /cidata/network-config >> /chroot.log

  write_debug_log "  user-data contents:"
  cat /cidata/user-data >> /chroot.log
}
EOF
  fi
}


#
# Create an init.d script for preventing the loading of kernel modules
#
create_module_blocking_initd() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Creating init.d script for disabling kernel module loading"
cat <<-_SCRIPT_ > /etc/init.d/block-modules-loading
#!/sbin/openrc-run

description="Disable loading of kernel modules"

depend() {
	after *
}

start() {
	ebegin "Disabling loading of kernel modules"
	sysctl -q -w kernel.modules_disabled=1
	eend $?
}
_SCRIPT_
chmod a+x /etc/init.d/block-modules-loading
EOF
}


#
# Create /etc/filesystems for Busybox mount
#
create_etc_filesystems() {
  local CONFIG_FS_TYPE=$1

  # Busybox mount command requires the following config

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Setting up /etc/filesystems for $CONFIG_FS_TYPE mount"
cat <<-_SCRIPT_ > /etc/filesystems
	#
	# /etc/filesystems
	#
	
	# Needed for cloud-init cidata $CONFIG_FS_TYPE
EOF

  if [ "$CONFIG_FS_TYPE" = "ISO" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
	iso9660
	_SCRIPT_
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"
	vfat
	_SCRIPT_
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  write_debug_log "    /etc/filesystems content:"
  cat /etc/filesystems >> /chroot.log
}
EOF
  fi
}


#
# Create the comment block at the start of the runscript
#
create_runscript_header() {
  cat <<EOF > "$RUN_SCRIPT"
#!/bin/sh -eu

#############################################################################
# Generated by create-alpine-disk-image version $SCRIPT_VERSION using the
# following options:
#
# $FULL_COMMAND_OPTIONS
#
#############################################################################

if [ "\$(id -u)" -ne 0 ]; then
  echo
  echo "This script must be run as the root user!"
  echo
  exit 1
fi

EOF
}


#
# Define list of packages in addition to base Alpine
#
define_additional_packages() {
  INITIAL_PKGS="ca-certificates chrony cloud-init kbd-bkeymaps"
  INITIAL_PKGS="$INITIAL_PKGS logrotate musl-locales"
  INITIAL_PKGS="$INITIAL_PKGS rng-tools rsyslog"

  if [ "$DEBUG" = 'true' ]; then
    INITIAL_PKGS="$INITIAL_PKGS bloaty"
  fi

  if [ -n "${IMAGE_BOOTCHART+x}" ]; then
    INITIAL_PKGS="$INITIAL_PKGS acct"
  fi

  case $IMAGE_AUTH_CONTROL in
    doas )
      INITIAL_PKGS="$INITIAL_PKGS doas"
      ;;
    sudo )
      INITIAL_PKGS="$INITIAL_PKGS sudo"
      ;;
    both )
      INITIAL_PKGS="$INITIAL_PKGS doas sudo"
      ;;
  esac

  case $IMAGE_DHCP_CLIENT in
    dhclient )
      INITIAL_PKGS="$INITIAL_PKGS dhclient"
      ;;
    dhcpcd )
      INITIAL_PKGS="$INITIAL_PKGS dhcpcd"
      ;;
  esac

  if [ "$IMAGE_ENABLE_UTMP" = "true" ]; then
    INITIAL_PKGS="$INITIAL_PKGS utmps"
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    INITIAL_PKGS="$INITIAL_PKGS cryptsetup"
    if [ "$REMOTE_UNLOCK" = "true" ]; then
      INITIAL_PKGS="$INITIAL_PKGS dropbear-convert dropbear-unlockdisk"
    fi
  fi

  case $IMAGE_FIREWALL in
    awall )
      INITIAL_PKGS="$INITIAL_PKGS awall awall-masquerade awall-policies"
      ;;
    iptables )
      INITIAL_PKGS="$INITIAL_PKGS iptables"
      if [ "$IMAGE_DISABLE_IPV6" = "false" ]; then
        INITIAL_PKGS="$INITIAL_PKGS ip6tables"
      fi
      ;;
    nftables )
      INITIAL_PKGS="$INITIAL_PKGS nftables"
      ;;
  esac

  if [ "${IMAGE_FS_TYPE}" = "btrfs" ]; then
    INITIAL_PKGS="$INITIAL_PKGS btrfs-progs btrfs-progs-extra"
  elif [ "${IMAGE_FS_TYPE}" = "ext4" ]; then
    INITIAL_PKGS="$INITIAL_PKGS e2fsprogs-extra"
  elif [ "${IMAGE_FS_TYPE}" = "f2fs" ]; then
    INITIAL_PKGS="$INITIAL_PKGS f2fs-tools"
  elif [ "${IMAGE_FS_TYPE}" = "xfs" ]; then
    INITIAL_PKGS="$INITIAL_PKGS xfsprogs xfsprogs-extra"
  fi

  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    INITIAL_PKGS="$INITIAL_PKGS lvm2"
    ###INITIAL_PKGS="$INITIAL_PKGS lvm2-dmeventd"
  fi

  case $IMAGE_SSH_SERVER in
    dropbear )
      INITIAL_PKGS="$INITIAL_PKGS dropbear"
      ;;
    openssh )
      INITIAL_PKGS="$INITIAL_PKGS openssh-server-pam"
      ;;
    tinyssh )
      INITIAL_PKGS="$INITIAL_PKGS tinyssh openssh-sftp-server"
      ;;
  esac

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud Providers
    case $CLOUD_TYPE in
      aws )
        INITIAL_PKGS="${INITIAL_PKGS} aws-cli nvme-cli"
        ;;
      digitalocean )
        INITIAL_PKGS="${INITIAL_PKGS} doctl"
        ;;
      hetzner )
        INITIAL_PKGS="${INITIAL_PKGS} hcloud"
        ;;
      ###vultr )
      ###  INITIAL_PKGS="${INITIAL_PKGS} vultr-cli"
      ###  ;;
    esac
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical machine
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      if [ -n "${IMAGE_CPU_VENDOR+x}" ] && \
         [ "$IMAGE_CPU_VENDOR" = "amd" ]; then
        INITIAL_PKGS="${INITIAL_PKGS} amd-ucode"
      elif [ -n "${IMAGE_CPU_VENDOR+x}" ] && \
           [ "$IMAGE_CPU_VENDOR" = "intel" ]; then
        INITIAL_PKGS="${INITIAL_PKGS} intel-ucode"
      else
        INITIAL_PKGS="${INITIAL_PKGS} amd-ucode intel-ucode"
      fi
      INITIAL_PKGS="${INITIAL_PKGS} irqbalance nvme-cli"
    elif [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
	  	INITIAL_PKGS="${INITIAL_PKGS} irqbalance mmc-utils raspberrypi"
    fi
    # Packages for all types of physical machines
    INITIAL_PKGS="${INITIAL_PKGS} lm-sensors lm-sensors-sensord"
  elif [ "$IMAGE_CLASS" = "virtual" ]; then
    # Virtual Machine
    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "proxmox" ] || \
       [ "$VM_TYPE" = "qemu" ]; then
      INITIAL_PKGS="${INITIAL_PKGS} qemu-guest-agent"
    fi

    if [ "$VM_TYPE" = "virtualbox" ]; then
      INITIAL_PKGS="${INITIAL_PKGS} virtualbox-guest-additions"
    fi

    if [ "$VM_TYPE" = "vmware" ]; then
      INITIAL_PKGS="${INITIAL_PKGS} open-vm-tools open-vm-tools-guestinfo open-vm-tools-timesync open-vm-tools-vix"
    fi
  fi

  if [ -n "${ADD_PACKAGES_LIST+x}" ]; then
    INITIAL_PKGS="${INITIAL_PKGS} ${ADD_PACKAGES_LIST}"
  fi
}


#
# Define the cloud-init DataSource(s) to enable for the relevant Cloud type
#
define_cloud_settings() {
  case $CLOUD_TYPE in
    generic )
      DATASOURCE_LIST="'AliYun','Azure','BigStep','ConfigDrive','DigitalOcean','E24Cloud','Ec2','Exoscale','GCE','Hetzner','IBMCloud','Oracle','RbxCloud','Scaleway','UpCloud','Vultr'"
      ;;
    aliyun )
      DATASOURCE_LIST="'AliYun'"
      ;;
    aws )
      DATASOURCE_LIST="'Ec2'"
      if [ "$IMAGE_ARCH" = "aarch64" ]; then
        CONSOLE_NAME="ttyAMA1"
      fi
      CONSOLE_TYPE="both"
      if [ "$CONSOLE_TYPE" = "serial" ] || \
         [ "$CONSOLE_TYPE" = "both" ]; then
        SERIAL_PORT_NUMBER="0"
        if [ "$IMAGE_ARCH" = "aarch64" ]; then
          SERIAL_PORT_NAME="ttyAMA${SERIAL_PORT_NUMBER}"
        else
          SERIAL_PORT_NAME="ttyS${SERIAL_PORT_NUMBER}"
        fi
      fi
      ;;
    azure )
      DATASOURCE_LIST="'Azure'"
      ;;
    bigstep )
      DATASOURCE_LIST="'Bigstep'"
      ;;
    brightbox )
      DATASOURCE_LIST="'Ec2'"
      ;;
    digitalocean )
      DATASOURCE_LIST="'DigitalOcean'"
      CONSOLE_TYPE="both"
      SERIAL_PORT_NUMBER="0"
      SERIAL_PORT_NAME="ttyS${SERIAL_PORT_NUMBER}"
      ;;
    e24 )
      DATASOURCE_LIST="'E24Cloud'"
      ;;
    exoscale )
      DATASOURCE_LIST="'Exoscale'"
      ;;
    google )
      DATASOURCE_LIST="'GCE'"
      ;;
    hetzner )
      DATASOURCE_LIST="'Ec2'"
      ;;
    hyperone )
      DATASOURCE_LIST="'RbxCloud'"
      ;;
    ibmcloud )
      DATASOURCE_LIST="'IBMCloud'"
      ;;
    oracle )
      DATASOURCE_LIST="'Oracle'"
      if [ "$IMAGE_ARCH" = "aarch64" ]; then
        CONSOLE_NAME="ttyAMA1"
      fi
      CONSOLE_TYPE="both"
      if [ "$CONSOLE_TYPE" = "serial" ] || \
         [ "$CONSOLE_TYPE" = "both" ]; then
        SERIAL_PORT_NUMBER="0"
        if [ "$IMAGE_ARCH" = "aarch64" ]; then
          SERIAL_PORT_NAME="ttyAMA${SERIAL_PORT_NUMBER}"
        else
          SERIAL_PORT_NAME="ttyS${SERIAL_PORT_NUMBER}"
        fi
      fi
      ;;
    rootbox )
      DATASOURCE_LIST="'RbxCloud'"
      ;;
    scaleway )
      DATASOURCE_LIST="'Scaleway'"
      ;;
    tencent )
      DATASOURCE_LIST="'ConfigDrive'"
      ;;
    upcloud )
      DATASOURCE_LIST="'UpCloud'"
      ;;
    vultr )
      DATASOURCE_LIST="'Vultr'"
      CONSOLE_TYPE="normal"
      ;;
  esac
}


#
# Define entries for kernel command line modules list
#
define_cmdline_for_modules() {
  local MODULES_LIST

  ###MODULES_LIST="jitterentropy_rng"
  MODULES_LIST=""

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # Add modules entry for dm-crypt
    if [ -n "${MODULES_LIST}" ]; then
      MODULES_LIST="$MODULES_LIST,dm-crypt"
    else
      MODULES_LIST="dm-crypt"
    fi

    if [ "$REMOTE_UNLOCK" = "true" ]; then
      # Add network module(s) need for remote encryption unlock
      case $IMAGE_CLASS in
        cloud | virtual )
          if [ "$IMAGE_CLASS" = "virtual" ] && \
             [ "$VM_TYPE" = "vmware" ]; then
            MODULES_LIST="$MODULES_LIST,vmxnet3"
          else
            # virtio_pci is *needed* even though its not a dep of virtio_net
            MODULES_LIST="$MODULES_LIST,virtio_net,virtio_pci"
          fi
          ;;
        physical )
          if [ "$PHYSICAL_TYPE" = "pc" ] && \
             [ -n "${REMOTE_UNLOCK_NETWORK_MODULE}" ]; then
            MODULES_LIST="$MODULES_LIST,$REMOTE_UNLOCK_NETWORK_MODULE"
          else
            MODULES_LIST="$MODULES_LIST,e1000"
          fi
          ;;
      esac
      if [ "$IMAGE_DISABLE_IPV6" != "true" ]; then
        MODULES_LIST="$MODULES_LIST,ipv6"
      fi
    fi
  fi

  echo "$MODULES_LIST"
}


#
# Define the cloud-init DataSource(s) to enable for the relevant VM type
#
define_virtual_settings() {
  case $VM_TYPE in
    generic )
      DATASOURCE_LIST="'AltCloud','ConfigDrive','Opennebula','Openstack','NoCloud','OVF'"
      ;;
    opennebula )
      DATASOURCE_LIST="'Opennebula'"
      ;;
    openstack )
      DATASOURCE_LIST="'Openstack'"
      ;;
    libvirtd | proxmox | qemu )
      DATASOURCE_LIST="'NoCloud'"
      if { [ "$CONSOLE_TYPE" = "serial" ] || \
           [ "$CONSOLE_TYPE" = "both" ]; } && \
         { [ "$IMAGE_ARCH" = "armv7" ] || \
           [ "$IMAGE_ARCH" = "aarch64" ]; }; then
        SERIAL_PORT_NUMBER="0"
        SERIAL_PORT_NAME="ttyAMA${SERIAL_PORT_NUMBER}"
      fi
      ;;
    rhevm )
      DATASOURCE_LIST="'AltCloud'"
      ;;
    ###test )
    ###  DATASOURCE_LIST="'NoCloud'"
    ###  DATASOURCE_LIST="$DATASOURCE_LIST,'AliYun','Azure','BigStep','CloudSigma','CloudStack','DigitalOcean','Ec2','Exoscale','GCE','Hetzner','IBMCloud','Oracle','RbxCloud','Scaleway','SmartOS','UpCloud','Vultr'"
    ###  DATASOURCE_LIST="$DATASOURCE_LIST,'AltCloud',ConfigDrive','MAAS','OpenNebula','OpenStack','OVF'"
    ###
    ###  DATASOURCE_SETTINGS=$(printf %s\\n "Ec2:" "  timeout: 5")
    ###  ;;
    virtualbox )
      DATASOURCE_LIST="'NoCloud'"
      ;;
    vmware )
      DATASOURCE_LIST="'OVF'"
      ;;
    vsphere )
      DATASOURCE_LIST="'AltCloud'"
      ;;
  esac
}


#
# Delete unnecessary users & groups
#
delete_users_groups() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Delete unnecessary users"
for unrequired_user in cyrus ftp games guest halt lp man news ntp operator \
            postmaster shutdown smmsp squid sync vpopmail
do
  deluser \$unrequired_user 2> /dev/null
done

write_log "Delete unnecessary groups"
for unrequired_group in abuild audio cdrom cdrw floppy kvm tape video
do
  delgroup \$unrequired_group
done
EOF
}


#
# Disable most of the gettys normally configured to run
#
disable_extra_getty() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Disabling extra getty processes"
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/inittab /etc/inittab-orig

EOF
  fi

  if [ "$IMAGE_CLASS" = "cloud" ] || \
     [ "$IMAGE_CLASS" = "virtual" ]; then
    # Only have 1 getty for cloud/virtual machines
    FIRST_GETTY_TO_DISABLE="2"
  else
    # Keep 2 gettys for physical machines
    FIRST_GETTY_TO_DISABLE="3"
  fi

  cat <<EOF >> "$RUN_SCRIPT"
sed -i -E -e 's|^tty([${FIRST_GETTY_TO_DISABLE}-6].*)|#tty\1|g' /etc/inittab
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/inittab-orig /etc/inittab \
    >> /chroot.log \
    || true
  rm /etc/inittab-orig
}
EOF
  fi
}


#
# Disable a specific kernel module
#
disable_kernel_module() {
  local MODULE_NAME=$1

  cat <<EOF >> "$RUN_SCRIPT"
	install ${MODULE_NAME} /bin/true
EOF
}


#
# Disable non-server specific kernel modules
#
disable_kernel_modules() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Disable non-server kernel modules"
EOF

  initialise_disable_kernel_modules "drivers"

  if [ "$IMAGE_CLASS" = "physical" ] && \
     [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -ne 0 ]; then
    # RPI has no ACPI so neither 'button' nor 'tiny-power-button' are used
    disable_kernel_module "button"
    disable_kernel_module "tiny-power-button"
    # RPI as server does not need multimedia-related modules
    disable_kernel_module "backlight"
    disable_kernel_module "bcm2835_codec"
    disable_kernel_module "bcm2835_isp"
    disable_kernel_module "bcm2835_mmal_vchiq"
    disable_kernel_module "bcm2835_v4l2"
    disable_kernel_module "cec"
    disable_kernel_module "drm"
    disable_kernel_module "drm_kms_helper"
    disable_kernel_module "drm_panel_orientiation_quirks"
    disable_kernel_module "fb_sys_fops"
    disable_kernel_module "i2c-bcm2708"
    disable_kernel_module "input_leds"
    disable_kernel_module "mc"
    disable_kernel_module "snd"
    disable_kernel_module "snd-pcm"
    disable_kernel_module "snd-pcm-dmaengine"
    disable_kernel_module "snd-soc-core"
    disable_kernel_module "snd-timer"
    disable_kernel_module "syscopyarea"
    disable_kernel_module "sysfillrect"
    disable_kernel_module "sysimgblt"
    disable_kernel_module "uio"
    disable_kernel_module "uio_pdrv_genirq"
    disable_kernel_module "vc_sm_cma"
    disable_kernel_module "vc4"
    disable_kernel_module "videobuf2_common"
    disable_kernel_module "videobuf2_dma_contig"
    disable_kernel_module "videobuf2_memops"
    disable_kernel_module "videobuf2_vmalloc"
    disable_kernel_module "videobuf2_v4l2"
    disable_kernel_module "videodev"
    disable_kernel_module "v4l2_mem2mem"
  elif [ "$IMAGE_CLASS" = "cloud" ] || \
       [ "$IMAGE_CLASS" = "virtual" ]; then
    # 'tiny-power-button' is used on Cloud and VM images
    disable_kernel_module "button"
  else
    # 'button' is used on rest of images
    disable_kernel_module "tiny-power-button"
  fi

  disable_kernel_module "evdev"
  disable_kernel_module "mousedev"
  disable_kernel_module "psmouse"
  disable_kernel_module "usbmouse"
  disable_kernel_module "xen-scsiback"
  disable_kernel_module "xen-scsifront"

  if [ "$IMAGE_CLASS" = "cloud" ] || \
     [ "$IMAGE_CLASS" = "virtual" ]; then
    disable_kernel_module "ac"
    disable_kernel_module "battery"
    disable_kernel_module "hid"
    disable_kernel_module "hid_generic"
    disable_kernel_module "i2c-piix4"
    disable_kernel_module "ehci_hcd"
    disable_kernel_module "ehci_pci"
    disable_kernel_module "ehci_platform"
    disable_kernel_module "ohci_hcd"
    disable_kernel_module "ohci_pci"
    disable_kernel_module "ohci_platform"
    disable_kernel_module "uhci_pci"
    disable_kernel_module "usb_common"
    disable_kernel_module "usb_storage"
    disable_kernel_module "usbcore"
    disable_kernel_module "usbhid"
    disable_kernel_module "usbmon"
    disable_kernel_module "xhci_hcd"
    disable_kernel_module "xhci_pci"
  fi

  if [ "$IMAGE_CLASS" = "virtual" ]; then
    if [ "$VM_TYPE" != "hyperv" ]; then
      disable_kernel_module "hid-hyperv"
      disable_kernel_module "hv_netvsc"
      disable_kernel_module "hv_vmbus"
      disable_kernel_module "hyperv-keyboard"
      disable_kernel_module "hyperv_fb"
      disable_kernel_module "pci-hyperv"
      disable_kernel_module "pci-hyperv-intf"
    fi
    if [ "$VM_TYPE" != "virtualbox" ] && \
       [ "$VM_TYPE" != "vmware" ]; then
      disable_kernel_module "vmwgfx"
    fi
    if [ "$VM_TYPE" != "vmware" ]; then
      disable_kernel_module "ptp_vmw"
      disable_kernel_module "vmw_balloon"
      disable_kernel_module "vmw_vmci"
      disable_kernel_module "vmw_vsock_virtio_transport"
      disable_kernel_module "vmw_vsock_virtio_transport_common"
      disable_kernel_module "vmw_vsock_vmci_transport"
      disable_kernel_module "vmxnet3"
      disable_kernel_module "vsock"
      disable_kernel_module "vsock_diag"
      disable_kernel_module "vsock_loopback"
    fi
    case $VM_TYPE in
      virtualbox )
        disable_kernel_module "ptp_kvm"
        disable_kernel_module "virtio_rng"
        ;;
    esac
  fi

  finish_disable_kernel_modules "drivers"
}


#
# Download tarball of statically compiled apk tool
#
download_static_apk() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Downloading statically built APK tool"
wget \
  -q \
  -O $TMPDIR/apk-tools-${APK_STATIC_VERSION}-x86_64-linux.tar.gz \
  ${APK_STATIC_URL}/apk-tools-${APK_STATIC_VERSION}-x86_64-linux.tar.gz \
  2>> "\$LOGFILE"
tar \
  --extract \
  -C \$TMPDIR \
  -z \
  -f \$TMPDIR/apk-tools-${APK_STATIC_VERSION}-x86_64-linux.tar.gz \
  >> "\$LOGFILE"
rm -f $TMPDIR/apk-tools-${APK_STATIC_VERSION}-x86_64-linux.tar.gz
EOF
}


#
# Enable getty for serial console
#
enable_serial_console() {
  if [ "$DEBUG" = "true" ]; then

    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/inittab /etc/inittab-orig
EOF

    if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
      # GRUB
      cat <<'EOF' >> "$RUN_SCRIPT"

cp /etc/default/grub /etc/default/grub-orig
EOF
    elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
      # Syslinux
      cat <<'EOF' >> "$RUN_SCRIPT"

cp /etc/update-extlinux.conf /etc/update-extlinux.conf-orig
EOF
    fi

  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Enable serial console"
EOF

  cat <<EOF >> "$RUN_SCRIPT"
write_log "  Enabling getty on ${SERIAL_PORT_NAME} for serial console"
sed -i \
  -e 's|^[#]*ttyS0::.*$|${SERIAL_PORT_NAME}::respawn:/sbin/getty -L ${SERIAL_PORT_NAME} ${SERIAL_PORT_SPEED} vt100|g' \
  /etc/inittab
EOF

  if [ "$DEBUG" = "true" ]; then

    cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
  diff /etc/inittab-orig /etc/inittab \
    >> /chroot.log \
    || true
  rm /etc/inittab-orig
}
EOF

  fi

  if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
    # GRUB
    cat <<EOF >> "$RUN_SCRIPT"
write_log "  Configure GRUB serial command"
echo 'GRUB_SERIAL_COMMAND="serial --unit=${SERIAL_PORT_NUMBER} --speed=${SERIAL_PORT_SPEED}"' \
  >> /etc/default/grub
write_log "  Configure GRUB for serial console"
EOF

    if [ "$CONSOLE_TYPE" = "both" ]; then
      cat <<EOF >> "$RUN_SCRIPT"
echo 'GRUB_TERMINAL="serial console"' \
  >> /etc/default/grub
EOF
    else
      cat <<EOF >> "$RUN_SCRIPT"
echo 'GRUB_TERMINAL="serial"' \
  >> /etc/default/grub
EOF
    fi

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
  diff /etc/default/grub-orig /etc/default/grub \
    >> /chroot.log \
    || true
  rm /etc/default/grub-orig
}
EOF
    fi

  elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
    # Syslinux
    cat <<EOF >> "$RUN_SCRIPT"
write_log "  Configure Syslinux serial port and speed"
sed -i \
  -e "s|^serial_port=.*|serial_port=${SERIAL_PORT_NUMBER}|g" \
  -e "s|^serial_baud=.*|serial_baud=${SERIAL_PORT_SPEED}|g" \
  /etc/update-extlinux.conf
EOF

    if [ "$CONSOLE_TYPE" = "serial" ]; then
      cat <<EOF >> "$RUN_SCRIPT"
write_log "  Disable normal Syslinux console"
sed -i -e "s|^console=.*|console=0|g" \
  /etc/update-extlinux.conf
EOF
    fi

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
  diff /etc/update-extlinux.conf-orig /etc/update-extlinux.conf \
    >> /chroot.log \
    || true
  rm /etc/update-extlinux.conf-orig
}
EOF
    fi

  fi
}


#
# Finish disabling specific kernel modules
#
finish_disable_kernel_modules() {
  local MODULE_SECTION=$1

  cat <<EOF >> "$RUN_SCRIPT"
	_SCRIPT_

  sort -o /etc/modprobe.d/disable-${MODULE_SECTION}-modules.conf \
    /etc/modprobe.d/disable-${MODULE_SECTION}-modules.conf
EOF
}


#
# Complete adding entries to the specified /etc/mkinitfs/features.d/*.modules file
#
finish_initramfs_entry() {
  cat <<EOF >> "$RUN_SCRIPT"
	_SCRIPT_
EOF
}


#
# Prep for disabling a specific kernel modules
#
initialise_disable_kernel_modules() {
  local MODULE_SECTION=$1

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Disabling ${MODULE_SECTION} kernel modules"
cat <<-_SCRIPT_ > /etc/modprobe.d/disable-${MODULE_SECTION}-modules.conf
EOF
}


#
# Prep adding entries to the specified /etc/mkinitfs/features.d/*.modules file
#
initialise_initramfs_entry() {
  local modules_file=$1

  cat <<EOF >> "$RUN_SCRIPT"
cat <<-_SCRIPT_ > /etc/mkinitfs/features.d/${modules_file}.modules
EOF
}


#
# Install additional packages
#
install_additional_packages() {
  cat <<EOF >> "$RUN_SCRIPT"

INITIAL_PACKAGES="$INITIAL_PKGS"
EOF

  cat <<'EOF' >> "$RUN_SCRIPT"
write_log "Install additional packages: \$INITIAL_PACKAGES"
apk add \$INITIAL_PACKAGES >> /chroot.log 2>&1
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  write_debug_log "Full installed packages list:"
  apk info | sort >> /chroot.log
}
EOF
  fi
}


#
# Install base Alpine system
#
install_alpine_base() {
  BASE_PACKAGES="alpine-base"
  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    BASE_PACKAGES="$BASE_PACKAGES efivar"
  fi

  # RPI alpine-base doesn't depend on mkinitfs so add it to list.
  if [ "$IMAGE_CLASS" = "physical" ] && \
     [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
    BASE_PACKAGES="$BASE_PACKAGES mkinitfs"
  fi

  # Define bootloader-related packages
  if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
    BOOTLOADER_PACKAGES="grub"
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      BOOTLOADER_PACKAGES="$BOOTLOADER_PACKAGES dosfstools grub-efi"
    else
      BOOTLOADER_PACKAGES="$BOOTLOADER_PACKAGES grub-bios"
    fi
    BASE_PACKAGES="$BASE_PACKAGES $BOOTLOADER_PACKAGES"
  elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
    BOOTLOADER_PACKAGES="syslinux"
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      BOOTLOADER_PACKAGES="$BOOTLOADER_PACKAGES dosfstools"
    fi
    BASE_PACKAGES="$BASE_PACKAGES $BOOTLOADER_PACKAGES"
  elif [ "$IMAGE_CLASS" = "physical" ] && \
       [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
    BOOTLOADER_PACKAGES="dosfstools raspberrypi-bootloader raspberrypi-bootloader-cutdown"
    BASE_PACKAGES="$BASE_PACKAGES $BOOTLOADER_PACKAGES"
  else
    BOOTLOADER_PACKAGES="none"
  fi

  cat <<EOF >> "$RUN_SCRIPT"

write_log "Bootloader packages to be installed are: $BOOTLOADER_PACKAGES"

write_log "Install base Alpine (plus bootloader packages) inside chroot"
# shellcheck disable=SC2086
\$TMPDIR/apk-tools-${APK_STATIC_VERSION}/apk \
  --arch "${IMAGE_ARCH}" \
  --initdb \
  --allow-untrusted \
  --root \$CHROOT_DIRECTORY \
  --update-cache \
  add \
  ${BASE_PACKAGES} \
  >> "\$LOGFILE" 2>&1
RET_CODE=\$?
if [ \$RET_CODE != 0 ]; then
  write_log "Failure while installing base Alpine, error code: \$RET_CODE"
  exit 1
fi
EOF
}


#
# Install GRUB onto disk
#
install_grub() {
  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  write_debug_log "grub.cfg contents:"
  cat /boot/grub/grub.cfg \
    >> /chroot.log \
    || true
}
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    GRUB_OPTIONS="--verbose"
  else
    GRUB_OPTIONS=""
  fi
  GRUB_EFI_OPTIONS="--bootloader-id=alpine --efi-directory=/efi --no-nvram"

  GRUB_MODULES_LIST="acpi disk echo elf gzio linux loadenv minicmd normal probe search test video_colors video_fb"
  if [ "$IMAGE_FS_TYPE" = "ext4" ]; then
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST ext2"
  else
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST $IMAGE_FS_TYPE"
  fi
  if [ "$IMAGE_ENCRYPTED" = "true" ] && \
     [ "$REMOTE_UNLOCK" != "true" ] && \
     [ "$NO_GRUB_ENCRYPTION" != "true" ]; then
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST gcry_rijndael gcry_sha256"
    if [ "$IMAGE_LUKS_VERSION" = 1 ]; then
      GRUB_MODULES_LIST="$GRUB_MODULES_LIST luks"
    else
      GRUB_MODULES_LIST="$GRUB_MODULES_LIST luks2"
    fi
  fi
  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST lvm"
  fi
  if [ -n "${IMAGE_BOOTLOADER_PASSWORD+x}" ]; then
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST password_pbkdf2"
  fi
  if [ "$CONSOLE_TYPE" = "serial" ] || \
     [ "$CONSOLE_TYPE" = "both" ]; then
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST serial"
  fi

  if [ "$IMAGE_CLASS" = "physical" ] && \
     [ "$PHYSICAL_TYPE" = "pc" ]; then
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST ahci at_keyboard scsi usb usb_keyboard"
    if [ -z "${IMAGE_CPU_VENDOR+x}" ] || \
       [ "$IMAGE_CPU_VENDOR" = "amd" ]; then
      GRUB_MODULES_LIST="$GRUB_MODULES_LIST ohci"
    fi
    if [ -z "${IMAGE_CPU_VENDOR+x}" ] || \
       [ "$IMAGE_CPU_VENDOR" = "intel" ]; then
      GRUB_MODULES_LIST="$GRUB_MODULES_LIST uhci"
    fi
  fi

  if [ "$IMAGE_ARCH" = "aarch64" ] && [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    GRUB_TARGET="arm64-efi"
    GRUB_OPTIONS="$GRUB_OPTIONS $GRUB_EFI_OPTIONS"
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST all_video efi_gop efifwsetup gfxterm part_gpt"
  elif [ "$IMAGE_ARCH" = "x86" ]; then
    GRUB_TARGET="i386-pc"
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST biosdisk part_msdos vga vga_text"
    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "qemu" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      GRUB_MODULES_LIST="$GRUB_MODULES_LIST video_bochs"
    fi
  elif [ "$IMAGE_ARCH" = "x86_64" ] && [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    GRUB_TARGET="i386-pc"
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST biosdisk part_msdos vga vga_text"
    if [ "$IMAGE_CLASS" = "cloud" ] || \
       { [ "$IMAGE_CLASS" = "virtual" ] && \
         { [ "$VM_TYPE" = "libvirtd" ] || \
           [ "$VM_TYPE" = "libvirtd" ] || \
           [ "$VM_TYPE" = "qemu" ] || \
           [ "$VM_TYPE" = "generic" ]; }; }; then
      GRUB_MODULES_LIST="$GRUB_MODULES_LIST video_bochs"
    fi
  else
    GRUB_TARGET="x86_64-efi"
    GRUB_OPTIONS="$GRUB_OPTIONS $GRUB_EFI_OPTIONS"
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST all_video efi_gop efifwsetup gfxterm part_gpt"
  fi

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Installing GRUB bootloader"
grub-install \
  $GRUB_OPTIONS \
  --install-modules="$GRUB_MODULES_LIST" \
  --target=$GRUB_TARGET \
  \$LOOP_DEVICE \
  >> /chroot.log \
  2>&1
EOF

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

mkdir -p /efi/EFI/boot
EOF

    case $IMAGE_ARCH in
      aarch64 )
        EFI_ARCH_FILE_INSERT="aa64"
        ;;
      x86_64 )
        EFI_ARCH_FILE_INSERT="x64"
        ;;
    esac
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Creating UEFI default boot file"
cp /efi/EFI/alpine/grub${EFI_ARCH_FILE_INSERT}.efi \
  /efi/EFI/boot/boot${EFI_ARCH_FILE_INSERT}.efi
EOF
  fi
}


#
# Install relevant kernel package
#
install_kernel() {
  if [ "$IMAGE_CLASS" = "cloud" ] || \
     [ "$IMAGE_CLASS" = "virtual" ]; then
    # Cloud or Virtual machine
    if [ "$IMAGE_KERNEL_TYPE" = "edge" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Installing kernel linux-edge-virt"
apk add linux-edge-virt >> /chroot.log 2>&1
EOF
    else
      cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Installing kernel linux-virt"
apk add linux-virt >> /chroot.log 2>&1
EOF
    fi
  else
    # Physical machine
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      # PC
      if [ "$IMAGE_KERNEL_TYPE" = "edge" ]; then
        cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Installing kernel linux-edge"
apk add linux-edge linux-firmware-none >> /chroot.log 2>&1
EOF
      else
        cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Installing kernel linux-lts"
apk add linux-lts linux-firmware-none >> /chroot.log 2>&1
EOF
      fi
    elif [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      # Raspberry Pi
      case $PHYSICAL_TYPE in
        rpi2 | rpi3 )
          if [ "$IMAGE_ARCH" = "armv7" ]; then
            RPI_KERNEL="linux-rpi2"
          else
            RPI_KERNEL="linux-rpi"
          fi ;;
        rpi4 )
          RPI_KERNEL="linux-rpi4" ;;
      esac
      RPI_KERNEL="$RPI_KERNEL linux-firmware-none"
      cat <<EOF >> "$RUN_SCRIPT"

write_log "Installing kernel $RPI_KERNEL"
apk add $RPI_KERNEL >> /chroot.log 2>&1
EOF

    fi
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

KERNEL_VERSION=\$(get_kernel_version)
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_debug_log "Kernel is: \$KERNEL_VERSION"
EOF
  fi
}


#
# Install Syslinux onto disk
#
install_syslinux() {
 if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /boot/extlinux.conf /boot/extlinux.conf-orig
write_debug_log "/boot/extlinux.conf contents at start:"
cat /boot/extlinux.conf >> /chroot.log
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Installing Syslinux"
EOF

  if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    # BIOS
    cat <<'EOF' >> "$RUN_SCRIPT"
write_log "  Installing BIOS MBR"
dd \
  bs=440 \
  count=1 \
  conv=notrunc \
  if=/usr/share/syslinux/mbr.bin \
  of="$LOOP_DEVICE" \
  >> /chroot.log 2>&1
write_log "  Installing Syslinux files in /boot directory"
extlinux --install /boot/ >> /chroot.log 2>&1
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
write_debug_log "/boot/extlinux.conf contents after extlinux --install:"
cat /boot/extlinux.conf >> /chroot.log
EOF
    fi

  else
    # UEFI
    cat <<'EOF' >> "$RUN_SCRIPT"
###write_log "  Installing Syslinux files in EFI/boot"
###mkdir -p /boot/EFI/BOOT
###cp \
###  /usr/share/syslinux/efi64/syslinux.efi \
###  /boot/EFI/boot/bootx64.efi
###cp \
###  /boot/initramfs-* \
###  /boot/vmlinuz-* \
###  /usr/share/syslinux/efi64/ldlinux.e64 \
###  /boot/EFI/alpine/*.c32 \
###  /boot/EFI/boot/

write_log "  Installing Syslinux UEFI files in EFI/BOOT aka /boot"
cp \
  /usr/share/syslinux/efi64/syslinux.efi \
  /boot/bootx64.efi
rm \
  /boot/*.c32
cp \
  /usr/share/syslinux/efi64/syslinux.c32 \
  /usr/share/syslinux/efi64/ldlinux.e64 \
  /usr/share/syslinux/efi64/libcom32.c32 \
  /usr/share/syslinux/efi64/libutil.c32 \
  /usr/share/syslinux/efi64/mboot.c32 \
  /usr/share/syslinux/efi64/menu.c32 \
  /usr/share/syslinux/efi64/vesamenu.c32 \
  /boot/
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
write_debug_log "  After installing Syslinux UEFI files"
ls -ltrR /boot/ >> /chroot.log
write_debug_log "/boot/extlinux.conf contents:"
cat /boot/extlinux.conf >> /chroot.log

EOF
    fi

  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
write_debug_log "  Before update-extlinux"
ls -ltrR /boot/ >> /chroot.log

EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
write_log "  Updating extlinux.conf file"
update-extlinux --verbose --warn-only >> /chroot.log 2>&1
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
write_debug_log "/boot/extlinux.conf contents after update-extlinux:"
cat /boot/extlinux.conf >> /chroot.log

EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
write_log "  Fix permissions on extlinux.conf files"
chmod g=,o= /boot/extlinux.conf*
EOF

  if [ "$DEBUG" = "true" ]; then

    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      # UEFI
      cat <<'EOF' >> "$RUN_SCRIPT"

write_debug_log "/boot/extlinux.conf contents after everything:"
cat /boot/extlinux.conf >> /chroot.log
write_debug_log "  /boot contents:"
ls -ltrR /boot/ >> /chroot.log
EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"

diff /boot/extlinux.conf-orig /boot/extlinux.conf \
  >> /chroot.log \
  || true
rm /boot/extlinux.conf-orig

write_debug_log "  extlinux.conf contents:"
cat /boot/extlinux.conf >> /chroot.log

EOF
  fi
}


#
# Create relevant filesystems for the disk image and mount these
# inside the chroot directory.
#
format_and_mount_fs() {
	cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Formatting and mounting filesystems"
EOF

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    # Machines booting via UEFI have ESP partition
    cat <<EOF >> "$RUN_SCRIPT"

UEFI_PART_DEVICE="\${LOOP_DEVICE}p${UEFI_PART_NUM}"

write_log "  Formatting FAT32 filesystem on ESP partition"
mkfs.fat -F32 -n SYSTEM_EFI "\$UEFI_PART_DEVICE" >> "\$LOGFILE" 2>&1
EOF

    if [ "$IMAGE_BOOT_REFERENCE" = "uuid" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
ESP_FS_UUID="$(get_uuid_from_device "$UEFI_PART_DEVICE")"
EOF
    fi
  fi

  if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

BOOT_PART_DEVICE="\${LOOP_DEVICE}p${BOOT_PART_NUM}"
EOF

    if [ "$IMAGE_CLASS" = "physical" ] && \
       [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Formatting FAT32 filesystem on RPI boot partition"
# Ensure that RPI boot filesystem label is *not* called "boot" due to
# https://github.com/raspberrypi/firmware/issues/1529
###mkfs.fat -F16 -s 4 -S 512 -n RPIBOOT "$BOOT_PART_DEVICE" \
mkfs.fat -F32 -n RPIBOOT "$BOOT_PART_DEVICE" \
	>> "$LOGFILE" 2>&1
EOF
    else
      if [ "$IMAGE_FS_TYPE" = "btrfs" ]; then
        cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting Btrfs filesystem on boot partition"
# shellcheck disable=SC2086
mkfs.btrfs -q -L $DEFAULT_BOOTFS_LABEL \
  "\$BOOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF
      elif [ "$IMAGE_FS_TYPE" = "ext4" ]; then
        # Ensure EXT4 inode size is 256 bytes rather than 128 in order to
        # avoid Year 2038 problems/warning.
        bootfs_options="-I 256"
        if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
          # Syslinux requires 64bit flag be disabled for boot filesystem
          bootfs_options="$bootfs_options -O ^64bit"
        fi

        cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting Ext4 filesystem on boot partition"
# shellcheck disable=SC2086
mkfs.ext4 -q -L $DEFAULT_BOOTFS_LABEL $bootfs_options \
  "\$BOOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF
      elif [ "$IMAGE_FS_TYPE" = "f2fs" ]; then
        cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting F2FS filesystem on boot partition"
# shellcheck disable=SC2086
mkfs.f2fs -q -l $DEFAULT_BOOTFS_LABEL \
  "\$BOOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF
      elif [ "$IMAGE_FS_TYPE" = "xfs" ]; then
        # Force attr2 to avoid dmesg warning
        bootfs_options="-i attr2"
        # Ensure XFS avoids Year 2038 problem.
        bootfs_options="$bootfs_options -m bigtime=1"

        cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting XFS filesystem on boot partition"
# shellcheck disable=SC2086
mkfs.xfs -q -L $DEFAULT_BOOTFS_LABEL $bootfs_options \
  "\$BOOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF
      fi

      if [ "$IMAGE_BOOT_REFERENCE" = "uuid" ]; then
        cat <<'EOF' >> "$RUN_SCRIPT"
BOOT_FS_UUID="$(get_uuid_from_device "$BOOT_PART_DEVICE")"
EOF
      fi
    fi
  fi

  if [ "$IMAGE_CLASS" = "physical" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

CIDATA_PART_DEVICE="\${LOOP_DEVICE}p${CIDATA_PART_NUM}"

write_log "  Formatting FAT16 filesystem on cidata partition"
mkfs.fat -F16 -s 1 -S 512 -n CIDATA "\$CIDATA_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

ROOT_PART_DEVICE="/dev/mapper/cryptroot"
EOF
  elif [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

ROOT_PART_DEVICE="/dev/mapper/vg0-root"
EOF

if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
BOOT_PART_DEVICE="/dev/mapper/vg0-boot"
EOF
fi

    cat <<'EOF' >> "$RUN_SCRIPT"
LOGS_PART_DEVICE="/dev/mapper/vg0-logs"
EOF
  else
    cat <<EOF >> "$RUN_SCRIPT"

ROOT_PART_DEVICE="\${LOOP_DEVICE}p${ROOT_PART_NUM}"
EOF
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    ROOT_ON="LUKS device"
  elif [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    ROOT_ON="LVM logical volume"
  else
	  ROOT_ON="root partition"
  fi

  if [ "$IMAGE_FS_TYPE" = "btrfs" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting Btrfs filesystem on ${ROOT_ON}"
# shellcheck disable=SC2086
mkfs.btrfs -q -L $DEFAULT_ROOTFS_LABEL "\$ROOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF

    if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
      # boot LV
      cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting Btrfs boot filesystem on LVM logical volume"
# shellcheck disable=SC2086
mkfs.btrfs -q -L $DEFAULT_BOOTFS_LABEL "\$BOOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1

write_log "  Formatting Btrfs logs filesystem on LVM logical volume"
# shellcheck disable=SC2086
mkfs.btrfs -q -L $DEFAULT_LOGSFS_LABEL "\$LOGS_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF
    fi
  elif [ "$IMAGE_FS_TYPE" = "ext4" ]; then
    # Ensure EXT4 inode size is 256 bytes rather than 128 in order to avoid
    # Year 2038 problems/warning.
    rootfs_options="-I 256"
    if [ "$IMAGE_BOOTLOADER" = "syslinux" ] && \
       [ -z "${IMAGE_LVM_ROOTFS+x}" ]; then
      # Syslinux requires 64bit flag be disabled for boot filesystem
      rootfs_options="$rootfs_options -O ^64bit"
    fi

    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting Ext4 root filesystem on ${ROOT_ON}"
# shellcheck disable=SC2086
mkfs.ext4 -q -L $DEFAULT_ROOTFS_LABEL $rootfs_options "\$ROOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF

    if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then

      if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
        # boot LV

        # Ensure EXT4 inode size is 256 bytes rather than 128 in order to avoid
        # Year 2038 problems/warning.
        bootfs_options="-I 256"
        if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
          # Syslinux requires 64bit flag be disabled for boot filesystem
          bootfs_options="$bootfs_options -O ^64bit"
        fi

        cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting Ext4 boot filesystem on LVM logical volume"
# shellcheck disable=SC2086
mkfs.ext4 -q -L $DEFAULT_BOOTFS_LABEL $bootfs_options "\$BOOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF
      fi

      # logs LV

      # Ensure EXT4 inode size is 256 bytes rather than 128 in order to avoid
      # Year 2038 problems/warning.
      logsfs_options="-I 256"

      cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting Ext4 logs filesystem on LVM logical volume"
# shellcheck disable=SC2086
mkfs.ext4 -q -L $DEFAULT_LOGSFS_LABEL $logsfs_options "\$LOGS_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF
    fi

  elif [ "$IMAGE_FS_TYPE" = "f2fs" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting F2FS filesystem on ${ROOT_ON}"
# shellcheck disable=SC2086
mkfs.f2fs -q -l $DEFAULT_ROOTFS_LABEL "\$ROOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF

    if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
      # boot and logs LVs
      cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting F2FS boot filesystem on LVM logical volume"
# shellcheck disable=SC2086
mkfs.f2fs -q -L $DEFAULT_BOOTFS_LABEL "\$BOOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1

write_log "  Formatting F2FS logs filesystem on LVM logical volume"
# shellcheck disable=SC2086
mkfs.f2fs -q -L $DEFAULT_LOGSFS_LABEL "\$LOGS_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF
    fi

  elif [ "$IMAGE_FS_TYPE" = "xfs" ]; then
    # Force attr2 to avoid dmesg warning.
    rootfs_options="-i attr=2"
    # Ensure XFS avoids Year 2038 problem.
    rootfs_options="$rootfs_options -m bigtime=1"

    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting XFS filesystem on ${ROOT_ON}"
# shellcheck disable=SC2086
mkfs.xfs -q -L $DEFAULT_ROOTFS_LABEL $rootfs_options "\$ROOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF

    if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
      # boot and logs LVs

      # Force attr2 to avoid dmesg warning.
      bootfs_options="-i attr=2"
      # Ensure XFS avoids Year 2038 problem.
      bootfs_options="$bootfs_options -m bigtime=1"

      # Force attr2 to avoid dmesg warning.
      logsfs_options="-i attr=2"
      # Ensure XFS avoids Year 2038 problem.
      logsfs_options="$logsfs_options -m bigtime=1"

      cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting XFS boot filesystem on LVM logical volume"
# shellcheck disable=SC2086
mkfs.xfs -q -L $DEFAULT_BOOTFS_LABEL $bootfs_options "\$BOOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1

write_log "  Formatting XFS logs filesystem on LVM logical volume"
# shellcheck disable=SC2086
mkfs.xfs -q -L $DEFAULT_LOGSFS_LABEL $logsfs_options "\$LOGS_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF
    fi
  fi

  if [ "$IMAGE_BOOT_REFERENCE" = "uuid" ] && \
     { [ "$IMAGE_CLASS" != "physical" ] || \
       [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -eq 0 ]; } && \
     [ "$IMAGE_ENCRYPTED" = "false" ] && \
     { [ -z "${IMAGE_LVM_ROOTFS+x}" ] || \
       [ "$IMAGE_BOOTLOADER" = "syslinux" ]; }; then
    cat <<'EOF' >> "$RUN_SCRIPT"
ROOT_FS_UUID="$(get_uuid_from_device "$ROOT_PART_DEVICE")"
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Mounting root filesystem onto $CHROOT_DIRECTORY"
mkdir -p "$CHROOT_DIRECTORY"
mount -o private "$ROOT_PART_DEVICE" "$CHROOT_DIRECTORY" >> "$LOGFILE" 2>&1
EOF

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Mounting ESP filesystem onto $CHROOT_DIRECTORY/efi"
mkdir -p "$CHROOT_DIRECTORY"/efi
mount -o private "$UEFI_PART_DEVICE" "$CHROOT_DIRECTORY"/efi \
  >> "$LOGFILE" 2>&1
EOF
  fi

  if [ "$NEEDS_BOOT_PARTITION" = "true" ] || \
     { [ -n "${IMAGE_LVM_ROOTFS+x}" ] && \
       { [ "$IMAGE_BOOT_TYPE" != "uefi" ] || \
         [ "$IMAGE_BOOTLOADER" != "syslinux" ]; }; }; then
    # Needs a boot partition or else is LVM but not Syslinux-based UEFI
    # (where boot is part of ESP partition)
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Mounting boot filesystem onto $CHROOT_DIRECTORY/boot"
mkdir -p "$CHROOT_DIRECTORY"/boot
mount -o private "$BOOT_PART_DEVICE" "$CHROOT_DIRECTORY"/boot \
  >> "$LOGFILE" 2>&1
EOF
  elif [ "$IMAGE_BOOT_TYPE" = "uefi" ] && \
       [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
    # When using Syslinux with UEFI then, as kernel & initramfs files need
    # to be in EFI/BOOT directory of ESP partition, EFI/BOOT directory of
    # ESP partition is bind-mounted to /boot. This ensures that kernel,
    # initramfs, and extlinux.conf files are in ESP partition.
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Bind mounting ESP filesystem's EFI/boot onto $CHROOT_DIRECTORY/boot"
mkdir -p "$CHROOT_DIRECTORY"/efi/EFI/boot
mkdir -p "$CHROOT_DIRECTORY"/boot
mount -t none -o bind "$CHROOT_DIRECTORY"/efi/EFI/boot \
  "$CHROOT_DIRECTORY"/boot >> "$LOGFILE" 2>&1
EOF
  fi

  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Mounting logs filesystem onto $CHROOT_DIRECTORY/var/logs"
mkdir -p "$CHROOT_DIRECTORY"/var/log
mount -o private "$LOGS_PART_DEVICE" "$CHROOT_DIRECTORY"/var/log >> "$LOGFILE" 2>&1
EOF
  fi

  if [ "$IMAGE_CLASS" = "physical" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Mounting cloud-init YAML filesystem onto $CHROOT_DIRECTORY/cidata"
mkdir -p "$CHROOT_DIRECTORY"/cidata
mount -o private "$CIDATA_PART_DEVICE" "$CHROOT_DIRECTORY"/cidata >> "$LOGFILE"
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
write_debug_log "  Filesystems' UUIDs"
lsblk --ascii --fs "$LOOP_DEVICE" >> "$LOGFILE" 2>&1

EOF
  fi
}


#
# Parse options given on the command line
#
parse_cli_options() {
  IMAGE_DISABLE_IPV4=false
  IMAGE_DISABLE_IPV6=false

  if ! CLI=$(getopt -s sh \
    -o h \
    -l add-packages:,apk-static-url:,apk-static-version:,arch:,auth-control:,boot-by-label,bootchart,bootloader:,bootloader-password:,boottype:,chroot-directory:,cloud:,cpu-vendor:,create-boot-partition,debug,dhcp-client:,disable-normal-console,disable-serial-console,disable-unnecessary-modules,disk-image-size:,enable-utmp,encrypt,encrypt-passphrase:,encrypt-remote-unlock,ethernet-module:,firewall:,for-ssd,fs-type:,full-hostname:,graphics-vendor:,harden,help,image-filename:,images-directory:,ipv4only,ipv6only,kernel-type:,keymap:,local-repo:,local-repo-sig-file:,locale:,lvm,minimise-users-groups,mirror:,no-grub-encryption,password:,physical:,ramdisk-directory:,release:,remote-unlock-network-module:,remote-unlock-ssh-port:,remote-unlock-static-gateway:,remote-unlock-static-interface:,remote-unlock-static-ip:,remote-unlock-static-netmask:,rpi-poe-hat,rpi-rtc,script-filename:,short-hostname:,ssh-public-key:,ssh-server:,timezone:,use-ramdisk,username:,virtual: \
    -n "$0" -- "$@"); then
    echo
    echo "Terminating..." >&2
    echo
    exit 2
  fi

  eval set -- "$CLI"

  while true; do
    case "$1" in
      --add-packages )
        ADD_PACKAGES_LIST="$(echo $2 | sed -e 's|,| |g')"
        shift 2
        ;;
      --apk-static-url )
        APK_STATIC_URL="$2"
        shift 2
        ;;
      --apk-static-version )
        APK_STATIC_VERSION="$2"
        shift 2
        ;;
      --arch )
        case $2 in
          aarch64 | armv7 | x86 | x86_64 )
            IMAGE_ARCH=$2
            ;;
          * )
            echo
            echo "Unknown arch!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --auth-control )
        case $2 in
          doas | sudo | both )
            IMAGE_AUTH_CONTROL=$2
            ;;
          * )
            echo
            echo "Unknown auth control mechanism!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --boot-by-label )
        IMAGE_BOOT_REFERENCE="label"
        shift
        ;;
      --bootchart )
        IMAGE_BOOTCHART="true"
        shift
        ;;
      --bootloader )
        case $2 in
          grub | rpi | syslinux )
            IMAGE_BOOTLOADER=$2
            ;;
          * )
            echo
            echo "Unknown bootloader, valid values are 'grub', 'rpi', and 'syslinux'"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --bootloader-password )
        IMAGE_BOOTLOADER_PASSWORD="$2"
        shift 2
        ;;
      --boottype )
        case $2 in
          bios | rpi | uefi )
            IMAGE_BOOT_TYPE=$2
            ;;
          * )
            echo
            echo "Unknown boot type, valid values are 'bios', 'rpi', and 'uefi'"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --chroot-directory )
        CHROOT_DIRECTORY="$2"
        shift 2
        ;;
      --cloud )
        IMAGE_CLASS="cloud"
        case $2 in
          aliyun | aws | azure | bigstep | brightbox | digitalocean | e24 | exoscale | generic | google | hetzner | hyperone | ibmcloud | oracle | rootbox | scaleway | tencent | upcloud | vultr )
            CLOUD_TYPE=$2
            ;;
          *)
            echo
            echo "Unknown cloud type!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --cpu-vendor )
        IMAGE_CPU_VENDOR="$2"
        shift 2
        ;;
      --create-boot-partition )
        CREATE_BOOT_PARTITION=true
        shift
        ;;
      --debug )
        DEBUG=true
        shift
        ;;
      --dhcp-client )
        IMAGE_DHCP_CLIENT="$2"
        shift 2
        ;;
      --disable-normal-console )
        CONSOLE_TYPE="serial"
        shift
        ;;
      --disable-serial-console )
        CONSOLE_TYPE="normal"
        shift
        ;;
      --disable-unnecessary-modules )
        DISABLE_UNNECESSARY_MODULES="true"
        shift
        ;;
      --disk-image-size )
        DISK_IMAGE_SIZE="$2"
        shift 2
        ;;
      --enable-utmp )
        IMAGE_ENABLE_UTMP="true"
        shift
        ;;
      --encrypt )
        IMAGE_ENCRYPTED=true
        shift
        ;;
      --encrypt-passphrase )
        IMAGE_ENCRYPTION_PASSPHRASE="$2"
        shift 2
        ;;
      --encrypt-remote-unlock )
        IMAGE_ENCRYPTED=true
        REMOTE_UNLOCK=true
        shift
        ;;
      --ethernet-module )
        IMAGE_ETHERNET_MODULE="$2"
        shift 2
        ;;
      --firewall )
        case $2 in
          awall | iptables | nftables )
            IMAGE_FIREWALL=$2
            ;;
          * )
            echo
            echo "Unknown or unsupported firewall!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --for-ssd )
        IMAGE_FOR_SSD=true
        shift
        ;;
      --fs-type )
        case $2 in
          btrfs | ext4 | f2fs | xfs )
            IMAGE_FS_TYPE="$2"
            ;;
          * )
            echo
            echo "Unsupported filesystem type!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --full-hostname )
        IMAGE_FULL_HOSTNAME="$2"
        shift 2
        ;;
      --graphics-vendor )
        IMAGE_GRAPHICS_VENDOR="$2"
        shift 2
        ;;
      --harden )
        IMAGE_HARDEN=true
        DELETE_UNNECESSARY_USERS_GROUPS=true
        DISABLE_UNNECESSARY_MODULES="true"
        shift
        ;;
      -h | --help )
        usage
        exit 0
        ;;
      --image-filename )
        IMAGE_FILENAME="$2"
        shift 2
        ;;
      --images-directory )
        IMAGES_DIRECTORY="$2"
        shift 2
        ;;
      --ipv4only )
        IMAGE_DISABLE_IPV4=false
        IMAGE_DISABLE_IPV6=true
        shift
        ;;
      --ipv6only )
        IMAGE_DISABLE_IPV4=true
        IMAGE_DISABLE_IPV6=false
        shift
        ;;
      --kernel-type )
        case $2 in
          normal | edge )
            IMAGE_KERNEL_TYPE=$2
            ;;
          * )
            echo
            echo "Kernel type can only be 'edge' or 'normal'!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --keymap )
        IMAGE_KEYMAP="$2"
        shift 2
        ;;
      --local-repo )
        LOCAL_ALPINE_REPOSITORY="$2"
        shift 2
        ;;
      --local-repo-sig-file )
        LOCAL_REPO_SIGNATURE_FILE="$2"
        shift 2
        ;;
      --locale )
        IMAGE_LOCALE="$2"
        shift 2
        ;;
      --lvm )
        IMAGE_LVM_ROOTFS=true
        shift
        ;;
      --minimise-users-groups )
        DELETE_UNNECESSARY_USERS_GROUPS=true
        shift
        ;;
      --mirror )
        ALPINE_MIRROR_SITE="$2"
        shift 2
        ;;
      --no-grub-encryption )
        NO_GRUB_ENCRYPTION=true
        shift
        ;;
      --password )
        IMAGE_DEFAULT_USER_PASSWORD="$2"
        shift 2
        ;;
      --physical )
        IMAGE_CLASS="physical"
        case $2 in
          pc | all-rpi | rpi2 | rpi3 | rpi4 )
            PHYSICAL_TYPE=$2
            ;;
          * )
            echo
            echo "Unknown physical machine type!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --ramdisk-directory )
        RAMDISK_DIRECTORY="$2"
        shift 2
        ;;
      --release )
        case $2 in
          3.13 | 3.14 )
            IMAGE_ALPINE_RELEASE=v$2
            ;;
          edge )
            IMAGE_ALPINE_RELEASE=$2
            ;;
          * )
            echo
            echo "Unknown or unsupported Alpine release!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --remote-unlock-network-module )
        REMOTE_UNLOCK_NETWORK_MODULE="$2"
        shift 2
        ;;
      --remote-unlock-ssh-port )
        REMOTE_UNLOCK_SSH_PORT="$2"
        shift 2
        ;;
      --remote-unlock-static-gateway )
        REMOTE_UNLOCK_STATIC_GATEWAY="$2"
        shift 2
        ;;
      --remote-unlock-static-interface )
        REMOTE_UNLOCK_STATIC_INTERFACE="$2"
        shift 2
        ;;
      --remote-unlock-static-ip )
        REMOTE_UNLOCK_STATIC_IP="$2"
        shift 2
        ;;
      --remote-unlock-static-netmask )
        REMOTE_UNLOCK_STATIC_NETMASK="$2"
        shift 2
        ;;
      --rpi-poe-hat )
        RPI_POE_HAT=true
        shift
        ;;
      --rpi-rtc )
        RPI_RTC=true
        shift
        ;;
      --script-filename )
        SCRIPT_FILENAME=$2
        shift 2
        ;;
      --short-hostname )
        IMAGE_SHORT_HOSTNAME="$2"
        shift 2
        ;;
      --ssh-public-key )
        if [ -f "$2" ]; then
          SSH_PUBLIC_KEY=$(cat "$2")
        else
          echo
          echo "SSH keyfile $2 not found!"
          echo
          exit 2
        fi
        shift 2
        ;;
      --ssh-server )
        case $2 in
          dropbear | openssh | tinyssh )
            IMAGE_SSH_SERVER=$2
            ;;
          * )
            echo
            echo "Unknown SSH server software, must be one of 'dropbear', 'openssh', or 'tinyssh'!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --timezone )
        IMAGE_TIMEZONE=$2
        shift 2
        ;;
      --use-ramdisk )
        USE_RAMDISK=true
        shift
        ;;
      --username )
        IMAGE_ADMIN_USERNAME=$2
        shift 2
        ;;
      --virtual )
        IMAGE_CLASS="virtual"
        case $2 in
          generic | hyperv | libvirtd | proxmox | qemu | virtualbox | vmware )
            VM_TYPE=$2
            ;;
          * )
            echo
            echo "Unknown virtual machine type!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      -- )
        shift
        break
        ;;
    esac
  done
}


#
# Partition the disk image for booting via BIOS
#
partition_bios() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Partitioning disk image for BIOS"

write_debug_log "  Creating MSDOS disk label"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME mklabel msdos \
  >> "\$LOGFILE" 2>&1
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # Disk encryption

    if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
      # When using Syslinux with encrypted rootfs or when using remote
      # unlock (whether with Grub or Syslinux) we need to create a separate
      # boot partition which will be unencrypted.
      BOOT_PART_NUM=1
      BOOT_PART_START="0%"
      BOOT_PART_END="${IMAGE_BOOT_PART_SIZE}MiB"

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_BOOT_PART_SIZE}MiB boot partition with boot flag on"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${BOOT_PART_START} "${BOOT_PART_END}" \
  set $BOOT_PART_NUM boot on \
  >> "\$LOGFILE" 2>&1
EOF

      if [ "$IMAGE_CLASS" = "physical" ]; then
        CIDATA_PART_NUM=2
        CIDATA_PART_START="${IMAGE_BOOT_PART_SIZE}MiB"
        CIDATA_PART_END="$((IMAGE_BOOT_PART_SIZE+CIDATA_PART_SIZE))MiB"

        cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$CIDATA_PART_START" ${CIDATA_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

        LUKS_PART_NUM=3
        LUKS_PART_START="$((IMAGE_BOOT_PART_SIZE+CIDATA_PART_SIZE))MiB"
        LUKS_PART_END="100%"
      else
        LUKS_PART_NUM=2
        LUKS_PART_START="${IMAGE_BOOT_PART_SIZE}MiB"
        LUKS_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_LUKS_PART_SIZE}MiB LUKS partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$LUKS_PART_START" ${LUKS_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF
    else
      # GRUB and no remote unlock enabled

      if [ "$IMAGE_CLASS" = "physical" ]; then
        CIDATA_PART_NUM=1
        CIDATA_PART_START="0%"
        CIDATA_PART_END="${CIDATA_PART_SIZE}MiB"

        cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} ${CIDATA_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

        LUKS_PART_NUM=2
        LUKS_PART_START="${CIDATA_PART_SIZE}MiB"
        LUKS_PART_END="100%"

      else
        LUKS_PART_NUM=1
        LUKS_PART_START="0%"
        LUKS_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_LUKS_PART_SIZE}MiB LUKS partition with boot flag on"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${LUKS_PART_START} ${LUKS_PART_END} \
  set $LUKS_PART_NUM boot on \
  >> "\$LOGFILE" 2>&1
EOF
    fi

  elif [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    # LVM

    if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
      # When using Syslinux with LVM rootfs we need to create a separate
      # boot partition.
      BOOT_PART_NUM=1
      BOOT_PART_START="0%"
      BOOT_PART_END="${IMAGE_BOOT_PART_SIZE}MiB"

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_BOOT_PART_SIZE}MiB boot partition with boot flag on"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${BOOT_PART_START} "${BOOT_PART_END}" \
  set $BOOT_PART_NUM boot on \
  >> "\$LOGFILE" 2>&1
EOF

      if [ "$IMAGE_CLASS" = "physical" ]; then
        # Also create a seperate partition for cloud-init config
        CIDATA_PART_NUM=2
        CIDATA_PART_START="${IMAGE_BOOT_PART_SIZE}MiB"
        CIDATA_PART_END="$((IMAGE_BOOT_PART_SIZE+CIDATA_PART_SIZE))MiB"

        cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$CIDATA_PART_START" ${CIDATA_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

        LVM_PART_NUM=3
        LVM_PART_START="$((IMAGE_BOOT_PART_SIZE+CIDATA_PART_SIZE))MiB"
        LVM_PART_END="100%"
      else
        LVM_PART_NUM=2
        LVM_PART_START="${IMAGE_BOOT_PART_SIZE}MiB"
        LVM_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_LVM_PART_SIZE}MiB LVM partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$LVM_PART_START" ${LVM_PART_END} \
  set $LVM_PART_NUM lvm on \
  >> "\$LOGFILE" 2>&1
EOF
    else
      # no seperate boot partition

      if [ "$IMAGE_CLASS" = "physical" ]; then
        # Create a seperate partition for cloud-init config
        CIDATA_PART_NUM=1
        CIDATA_PART_START="0%"
        CIDATA_PART_END="${CIDATA_PART_SIZE}MiB"

        cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} ${CIDATA_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

        LVM_PART_NUM=2
        LVM_PART_START="${CIDATA_PART_SIZE}MiB"
        LVM_PART_END="100%"

      else
        LVM_PART_NUM=1
        LVM_PART_START="0%"
        LVM_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_LVM_PART_SIZE}MiB LVM partition with boot flag on"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${LVM_PART_START} ${LVM_PART_END} \
  set $LVM_PART_NUM lvm on \
  set $LVM_PART_NUM boot on \
  >> "\$LOGFILE" 2>&1
EOF
    fi
  else
    # No disk encryption, no LVM

    if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
      # A separate boot partition is to be created.
      BOOT_PART_NUM=1
      BOOT_PART_START="0%"
      BOOT_PART_END="${IMAGE_BOOT_PART_SIZE}MiB"

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_BOOT_PART_SIZE}MiB boot partition with boot flag on"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${BOOT_PART_START} "${BOOT_PART_END}" \
  set $BOOT_PART_NUM boot on \
  >> "\$LOGFILE" 2>&1
EOF

      if [ "$IMAGE_CLASS" = "physical" ]; then
        CIDATA_PART_NUM=2
        CIDATA_PART_START="${IMAGE_BOOT_PART_SIZE}MiB"
        CIDATA_PART_END="$((IMAGE_BOOT_PART_SIZE+CIDATA_PART_SIZE))MiB"

        cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} ${CIDATA_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

        ROOT_PART_NUM=3
        ROOT_PART_START="$((IMAGE_BOOT_PART_SIZE+CIDATA_PART_SIZE))MiB"
        ROOT_PART_END="100%"
      else
        ROOT_PART_NUM=2
        ROOT_PART_START="${IMAGE_BOOT_PART_SIZE}MiB"
        ROOT_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_ROOT_PART_SIZE}MiB root partition with boot flag on"
parted --machine --script --align=optimal "\$IMAGE_FULL_FILENAME" \
  unit MiB \
  mkpart primary ${ROOT_PART_START} ${ROOT_PART_END} \
  set $ROOT_PART_NUM boot on \
  >> "\$LOGFILE" 2>&1
EOF

    else
      # No boot partition created

      if [ "$IMAGE_CLASS" = "physical" ]; then
        CIDATA_PART_NUM=1
        CIDATA_PART_START="0%"
        CIDATA_PART_END="${CIDATA_PART_SIZE}MiB"

        cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} ${CIDATA_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

        ROOT_PART_NUM=2
        ROOT_PART_START="${CIDATA_PART_SIZE}MiB"
        ROOT_PART_END="100%"
      else
        ROOT_PART_NUM=1
        ROOT_PART_START="0%"
        ROOT_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_ROOT_PART_SIZE}MiB root partition with boot flag on"
parted --machine --script --align=optimal "\$IMAGE_FULL_FILENAME" \
  unit MiB \
  mkpart primary ${ROOT_PART_START} ${ROOT_PART_END} \
  set $ROOT_PART_NUM boot on \
  >> "\$LOGFILE" 2>&1
EOF
    fi
  fi
}


#
# Partition for Raspberry Pi use
#
partition_rpi() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Partitioning disk image for Raspberry Pi"

write_debug_log "  Creating MSDOS disk label"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME mklabel msdos \
  >> "\$LOGFILE" 2>&1
EOF

  BOOT_PART_NUM="1"
  BOOT_PART_START="0%"
  BOOT_PART_END="${IMAGE_BOOT_PART_SIZE}MiB"

  # Create partition for RPI built-in bootloader
  cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_BOOT_PART_SIZE}MiB boot partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary fat32 ${BOOT_PART_START} "${BOOT_PART_END}" \
  >> "\$LOGFILE" 2>&1
EOF

  CIDATA_PART_NUM="2"
  CIDATA_PART_START="${IMAGE_BOOT_PART_SIZE}MiB"
  CIDATA_PART_END="$((IMAGE_BOOT_PART_SIZE + CIDATA_PART_SIZE))MiB"

  # Create partition for cloud-init use
  cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$CIDATA_PART_START" "${CIDATA_PART_END}" \
  >> "\$LOGFILE" 2>&1
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # Disk encryption
    LUKS_PART_NUM=3
    LUKS_PART_START="$((IMAGE_BOOT_PART_SIZE + CIDATA_PART_SIZE))MiB"
    LUKS_PART_END="100%"

    cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_LUKS_PART_SIZE}MiB LUKS partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$LUKS_PART_START" ${LUKS_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF
  elif [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    # LVM
    LVM_PART_NUM=3
    LVM_PART_START="$((IMAGE_BOOT_PART_SIZE + CIDATA_PART_SIZE))MiB"
    LVM_PART_END="100%"

    cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_LVM_PART_SIZE}MiB LVM partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$LVM_PART_START" ${LVM_PART_END} \
  set $LVM_PART_NUM lvm on \
  >> "\$LOGFILE" 2>&1
EOF
  else
    # No disk encryption
    ROOT_PART_NUM="3"
    ROOT_PART_START="$((IMAGE_BOOT_PART_SIZE + CIDATA_PART_SIZE))MiB"
    ROOT_PART_END="100%"

    cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_ROOT_PART_SIZE}MiB root parition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$ROOT_PART_START" ${ROOT_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF
  fi
}


# 
# Partition the disk image for booting via UEFI
#
partition_uefi() {
  local UEFI_PART_START UEFI_PART_END

  cat <<EOF >> "$RUN_SCRIPT"

write_log "Partitioning disk image for UEFI"

write_debug_log "  Creating GPT disk label"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME mklabel gpt \
  >> "\$LOGFILE" 2>&1
EOF

  UEFI_PART_NUM=1
  UEFI_PART_START="0%"
  UEFI_PART_END="${IMAGE_UEFI_PART_SIZE}MiB"

  # Create EFI partition
  cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating ${IMAGE_UEFI_PART_SIZE}MiB ESP partition"
parted --machine --script --align optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary fat32 ${UEFI_PART_START} ${UEFI_PART_END} \
  set $UEFI_PART_NUM esp on \
  >> "\$LOGFILE" 2>&1
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # Disk encryption

    if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
      # When using remote unlock with GRUB we need to create a separate boot
      # partition which will be unencrypted. This is not needed for Syslinux
      # as in that case the EFI partition contains the boot files.
      BOOT_PART_NUM=2
      BOOT_PART_START="${UEFI_PART_END}"
      BOOT_PART_END="$((BOOT_PART_START + IMAGE_BOOT_PART_SIZE))MiB"

      cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating ${IMAGE_BOOT_PART_SIZE}MiB boot partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${BOOT_PART_START} "${BOOT_PART_END}" \
  >> "\$LOGFILE" 2>&1
EOF

      if [ "$IMAGE_CLASS" = "physical" ]; then
        CIDATA_PART_NUM=3
        CIDATA_PART_START="${BOOT_PART_END}"
        CIDATA_PART_END="$((CIDATA_PART_START + CIDATA_PART_SIZE))MiB"

        cat <<EOF >> "$RUN_SCRIPT"

# shellcheck disable=SC2003
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} "${CIDATA_PART_END}" \
  >> "\$LOGFILE" 2>&1
EOF

        LUKS_PART_NUM=4
        LUKS_PART_START="${CIDATA_PART_END}"
        LUKS_PART_END="100%"
      else
        LUKS_PART_NUM=3
        LUKS_PART_START="${BOOT_PART_END}"
        LUKS_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating ${IMAGE_LUKS_PART_SIZE}MiB LUKS partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${LUKS_PART_START} ${LUKS_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

    else
      if [ "$IMAGE_CLASS" = "physical" ]; then
        CIDATA_PART_NUM=2
        CIDATA_PART_START="${UEFI_PART_END}"
        CIDATA_PART_END="$((CIDATA_PART_START + CIDATA_PART_SIZE))MiB"

        cat <<EOF >> "$RUN_SCRIPT"

# shellcheck disable=SC2003
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} "${CIDATA_PART_END}" \
  >> "\$LOGFILE" 2>&1
EOF

        LUKS_PART_NUM=3
        LUKS_PART_START="${CIDATA_PART_END}"
        LUKS_PART_END="100%"
      else
        LUKS_PART_NUM=2
        LUKS_PART_START="${UEFI_PART_END}"
        LUKS_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating ${IMAGE_LUKS_PART_SIZE}MiB LUKS partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${LUKS_PART_START} ${LUKS_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF
    fi
  elif [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    # LVM

    if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
      # When using Syslinux with LVM rootfs we need to create a separate
      # boot partition.
      BOOT_PART_NUM=2
      BOOT_PART_START="${UEFI_PART_END}"
      BOOT_PART_END="$((BOOT_PART_START + IMAGE_BOOT_PART_SIZE))MiB"

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_BOOT_PART_SIZE}MiB boot partition with boot flag on"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${BOOT_PART_START} "${BOOT_PART_END}" \
  set $BOOT_PART_NUM boot on \
  >> "\$LOGFILE" 2>&1
EOF

      if [ "$IMAGE_CLASS" = "physical" ]; then
        # Also create a seperate partition for cloud-init config
        CIDATA_PART_NUM=3
        CIDATA_PART_START="${BOOT_PART_END}MiB"
        CIDATA_PART_END="$((CIDATA_PART_START + CIDATA_PART_SIZE))MiB"

        cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$CIDATA_PART_START" ${CIDATA_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

        LVM_PART_NUM=4
        LVM_PART_START="${CIDATA_PART_END}MiB"
        LVM_PART_END="100%"
      else
        LVM_PART_NUM=3
        LVM_PART_START="${BOOT_PART_END}MiB"
        LVM_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_LVM_PART_SIZE} LVM partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$LVM_PART_START" ${LVM_PART_END} \
  set $LVM_PART_NUM lvm on \
  >> "\$LOGFILE" 2>&1
EOF
    else
      # no separate boot partition

      if [ "$IMAGE_CLASS" = "physical" ]; then
        # Create a seperate partition for cloud-init config
        CIDATA_PART_NUM=2
        CIDATA_PART_START="${UEFI_PART_END}"
        CIDATA_PART_END="$((CIDATA_PART_START + CIDATA_PART_SIZE))MiB"

        cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} ${CIDATA_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

        LVM_PART_NUM=2
        LVM_PART_START="${CIDATA_PART_END}MiB"
        LVM_PART_END="100%"
      else
        LVM_PART_NUM=1
        LVM_PART_START="${UEFI_PART_END}MiB"
        LVM_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_LVM_PART_SIZE}MiB LVM partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${LVM_PART_START} ${LVM_PART_END} \
  set $LVM_PART_NUM lvm on \
  >> "\$LOGFILE" 2>&1
EOF
    fi
  else
    # No disk encryption, no LVM

    if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
      # A separate boot partition is to be created.
      BOOT_PART_NUM=2
      BOOT_PART_START="${UEFI_PART_END}"
      BOOT_PART_END="$((BOOT_PART_START + IMAGE_BOOT_PART_SIZE))MiB"

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${IMAGE_BOOT_PART_SIZE}MiB boot partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${BOOT_PART_START} "${BOOT_PART_END}" \
  >> "\$LOGFILE" 2>&1
EOF

      if [ "$IMAGE_CLASS" = "physical" ]; then
        CIDATA_PART_NUM=3
        CIDATA_PART_START="${BOOT_PART_END}"
        CIDATA_PART_END="$((CIDATA_PART_START + CIDATA_PART_SIZE))MiB"

        cat <<EOF >> "$RUN_SCRIPT"

# shellcheck disable=SC2003
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} "${CIDATA_PART_END}" \
  >> "\$LOGFILE" 2>&1
EOF

        ROOT_PART_NUM=4
        ROOT_PART_START="${CIDATA_PART_END}"
        ROOT_PART_END="100%"
      else
        ROOT_PART_NUM=3
        ROOT_PART_START="${BOOT_PART_END}"
        ROOT_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating ${IMAGE_ROOT_PART_SIZE}MiB root partition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "${ROOT_PART_START}" ${ROOT_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

    else
      # No boot partition

      if [ "$IMAGE_CLASS" = "physical" ]; then
        CIDATA_PART_NUM=2
        CIDATA_PART_START="${UEFI_PART_END}"
        CIDATA_PART_END="$((CIDATA_PART_START + CIDATA_PART_SIZE))MiB"

        cat <<EOF >> "$RUN_SCRIPT"

# shellcheck disable=SC2003
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} "${CIDATA_PART_END}" \
  >> "\$LOGFILE" 2>&1
EOF

        ROOT_PART_NUM=3
        ROOT_PART_START="${CIDATA_PART_END}"
        ROOT_PART_END="100%"
      else
        ROOT_PART_NUM=2
        ROOT_PART_START="${UEFI_PART_END}"
        ROOT_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating ${IMAGE_ROOT_PART_SIZE}MiB root partition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "${ROOT_PART_START}" ${ROOT_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF
    fi
  fi
}


#
# Create the /etc/crypttab file
#
setup_crypttab() {
  CRYPTTAB_OPTIONS="luks"
  if [ "$IMAGE_FOR_SSD" = "true" ]; then
    CRYPTTAB_OPTIONS="$CRYPTTAB_OPTIONS,discard"
  fi
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Creating /etc/crypttab"
echo "cryptroot UUID=\${LUKS_PART_UUID} /crypto_keyfile.bin $CRYPTTAB_OPTIONS" > /etc/crypttab
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
write_debug_log "    /etc/crypttab contents:"
cat /etc/crypttab >> /chroot.log
EOF
  fi
}


#
# Create Dropbear authorized_keys file
#
setup_dropbear_authorized_keys() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Setup Dropbear authorized_keys file"
echo $SSH_PUBLIC_KEY > /etc/dropbear/authorized_keys
chown root:root /etc/dropbear/authorized_keys
chmod 600 /etc/dropbear/authorized_keys
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
write_debug_log "  Dropbear authorized_keys contents:"
cat /etc/dropbear/authorized_keys >> "$LOGFILE"
EOF
  fi
}


#
# Configure modules to be loaded upon boot
#
setup_etc_modules() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Setup /etc/modules"
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/modules /etc/modules-orig

EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
cat <<-_SCRIPT_ > /etc/modules
	af_packet
EOF

  if [ "$IMAGE_DISABLE_IPV6" != "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
	ipv6
EOF
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

	# LUKS
	dm-crypt
EOF
  fi

###  cat <<'EOF' >> "$RUN_SCRIPT"
###
###	# Used by rngd
###	jitterentropy_rng
###EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud machine
    cat <<'EOF' >> "$RUN_SCRIPT"

	# Cloud-specific modules
EOF

    case $CLOUD_TYPE in
      azure | generic )
        cat <<'EOF' >> "$RUN_SCRIPT"
	ptp_kvm
EOF
        ;;
    esac

    cat <<'EOF' >> "$RUN_SCRIPT"
	virtio-rng
EOF
  elif [ "$IMAGE_CLASS" = "virtual" ]; then
    # Virtual machine
    case $VM_TYPE in
      libvirtd | proxmox | qemu | generic )
        cat <<'EOF' >> "$RUN_SCRIPT"

	# VM-specific modules
	ptp_kvm
	virtio-rng
EOF
        ;;
      vmware )
        cat <<'EOF' >> "$RUN_SCRIPT"

	# VM-specific modules
	ptp_vmw
EOF
        ;;
    esac
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	_SCRIPT_
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/modules-orig \
    /etc/modules \
    >> /chroot.log \
    || true
  rm /etc/modules-orig
}
EOF
  fi
}


#
# Setup the LUKS device
#
setup_luks_device() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Setting up LUKS device"
LUKS_DEVICE="\${LOOP_DEVICE}p${LUKS_PART_NUM}"
EOF
  if [ "$IMAGE_ALPINE_RELEASE" = "v3.13" ]; then
    IMAGE_LUKS_VERSION="1"
  else
    if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
      IMAGE_LUKS_VERSION="2"
    else
      # For now only use LUKSv1 with Grub
      IMAGE_LUKS_VERSION="1"
      ###IMAGE_LUKS_VERSION="2"
    fi
  fi

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting partition as LUKS version ${IMAGE_LUKS_VERSION}"
echo "\$ENCRYPTION_PASSPHRASE" | \
  cryptsetup \
    -q \
    luksFormat \
      --cipher aes-xts-plain64 \
      --hash sha256 \
      --key-size 512 \
      --pbkdf pbkdf2 \
      --type luks$IMAGE_LUKS_VERSION \
    "\$LUKS_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF

###      --offset 8 \

  if [ "$IMAGE_BOOTLOADER" = "grub" ] && \
     [ "$REMOTE_UNLOCK" != "true" ] && \
     [ "$NO_GRUB_ENCRYPTION" != "true" ]; then
    # When bootloader is GRUB with GRUB encryption enabled and not enabling
    # Remote SSH Unlock, create keyfile - this will be placed in the
    # initramfs and used to unlock the rootfs - this prevents being prompted
    # for passphrase twice, once by GRUB and then again by initramfs.
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Creating keyfile for LUKS"
dd \
  bs=512 \
  count=4 \
  if=/dev/random \
  of=crypto_keyfile.bin \
  iflag=fullblock \
  >> "\$LOGFILE" 2>&1

write_log "  Adding keyfile to LUKS device"
echo "\$ENCRYPTION_PASSPHRASE" | \
  cryptsetup \
    luksAddKey \
    "\$LUKS_DEVICE" \
    ./crypto_keyfile.bin \
  >> "\$LOGFILE"

write_log "  Opening LUKS device"
cryptsetup \
  open \
    --type luks$IMAGE_LUKS_VERSION \
    --key-file ./crypto_keyfile.bin \
  "\$LUKS_DEVICE" \
  cryptroot
EOF
  else
    # Remote unlock enabled, use default passphrase to open
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Opening LUKS device"
echo "\$ENCRYPTION_PASSPHRASE" | \
  cryptsetup \
    open \
      --type luks$IMAGE_LUKS_VERSION \
    "\$LUKS_DEVICE" \
    cryptroot \
    -
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
LUKS_PART_UUID=$(get_uuid_from_device "$LUKS_DEVICE")
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Show LUKS device details"
cryptsetup luksDump "$LUKS_DEVICE" >> "$LOGFILE"
EOF
  fi
}


#
# Setup the LVM device
#
setup_lvm_device() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Setting up LVM device"
LVM_DEVICE="\${LOOP_DEVICE}p${LVM_PART_NUM}"
EOF

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Creating LVM physical volume"
pvcreate "\$LVM_DEVICE" \
  >> "\$LOGFILE"

write_log "  Creating LVM volume group"
vgcreate vg0 "\$LVM_DEVICE" \
  >> "\$LOGFILE"

write_log "  Creating $(calculate_lvm_root_lv_size)MiB LVM logical volume for rootfs"
lvcreate -L $(calculate_lvm_root_lv_size)m vg0 -n root \
  >> "\$LOGFILE" 2>&1
EOF

  if [ "$NEEDS_BOOT_PARTITION" != "true" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Creating $(calculate_lvm_boot_lv_size)MiB LVM logical volume for boot"
lvcreate -L $(calculate_lvm_boot_lv_size)m vg0 -n boot \
  >> "\$LOGFILE" 2>&1
EOF
  fi

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Creating $(calculate_lvm_logs_lv_size)MiB LVM logical volume for logs"
lvcreate -L $(calculate_lvm_logs_lv_size)m vg0 -n logs \
  >> "\$LOGFILE" 2>&1
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
lvscan >> "$LOGFILE" 2>&1
EOF
  fi
}


#
# Change the default OpenSSH server config to be more secure
#
tighten_sshd_configuration() {

  if [ "$IMAGE_SSH_SERVER" = "openssh" ]; then

    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Tighten the OpenSSH server configuration"
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/conf.d/sshd /etc/conf.d/sshd-orig
EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "    Only generate ED25519 & 3072bit RSA host keys"
sed -i \
  -e 's/^#key_types_to_generate=.*$/key_types_to_generate="ed25519 rsa"/' \
  -e 's/^#rsa_bit_size=.*$/rsa_bit_size="3072"/' \
  /etc/conf.d/sshd
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/conf.d/sshd-orig /etc/conf.d/sshd \
  >> /chroot.log \
  || true
  rm /etc/conf.d/sshd-orig

  cp /etc/ssh/sshd_config /etc/ssh/sshd_config-orig
}
EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"

# Configure sshd to:
#   - only use ED25519 & RSA host keys
#   - prevent root logins
#   - prevent password-based logins
#   - enable PAM
#   - use built-in SFTP server
write_log "    Prevent root login, prevent password logins"
sed -i \
  -e 's|^#HostKey /etc/ssh/ssh_host_ed25519_key$|HostKey /etc/ssh/ssh_host_ed25519_key|' \
  -e 's|^#HostKey /etc/ssh/ssh_host_rsa_key$|HostKey /etc/ssh/ssh_host_rsa_key|' \
  -e 's|^#PermitRootLogin .*$|PermitRootLogin no|' \
  -e 's|^#PasswordAuthentication .*$|PasswordAuthentication no|' \
  -e 's|^#UsePAM .*$|UsePAM yes|' \
  -e 's|^(#)*Subsystem .*sftp .*$|Subsystem sftp internal-sftp|' \
  /etc/ssh/sshd_config
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/ssh/sshd_config-orig /etc/ssh/sshd_config \
    >> /chroot.log \
    || true
  rm /etc/ssh/sshd_config-orig
}
EOF
    fi
  elif [ "$IMAGE_SSH_SERVER" = "tinyssh" ]; then

    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Configure TinySSH server"
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/conf.d/tinysshd /etc/conf.d/tinysshd-orig
EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "    Enable SFTP server"
sed -i \
  -e 's|^# OPTIONS=.*|OPTIONS="-l -v -x sftp=/usr/lib/ssh/sftp-server"|' \
  /etc/conf.d/tinysshd
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/conf.d/tinysshd-orig /etc/conf.d/tinysshd \
  >> /chroot.log \
  || true
  rm /etc/conf.d/tinysshd-orig
}
EOF
    fi
  fi
}


#
# Upgrade Alpine packages
#
update_upgrade_packages() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Updating package list"
apk update >> /chroot.log

write_log "Upgrading base packages if necessary"
apk -a upgrade >> /chroot.log
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
apk info | sort > /base-packages.list
EOF
  fi
}


#
# Help text
#
usage() {
  echo "Usage: $0 [ options ]"
  echo
  echo "When called with no options is equivalent to"
  echo "'--arch x86_64 --release edge --bootloader syslinux -virtual qemu'."
  echo
  echo "Options:"
  echo
  echo "  --apk-static-url < url >"
  echo
  echo "    Base url to download statically compiled APK tool from."
  echo
  echo "  --apk-static-version < version >"
  echo
  echo "    Version of the statically compiled APK tool to download/use."
  echo
  echo "  --arch < aarch64 | armv7 | x86 | x86_64 >"
  echo
  echo "    Defaults to x86_86, except when '--physical rpi*' specified when it"
  echo "    defaults to aarch64."
  echo
  echo "  --boot-by-label"
  echo
  echo "    Use Labels rather than UUIDs in /etc/fstab and bootloader to refer to"
  echo "    filesystems."
  echo
  echo "  --bootchart"
  echo
  echo "    Enables bootchart creation during boot."
  echo
  echo "  --bootloader < grub | syslinux >"
  echo
  echo "    Defaults to Syslinux. Not relevant for RPI physical machines."
  echo
  echo "  --bootloader-password < password >"
  echo
  echo "    Specify password to lock GRUB or Syslinux menu with. Not relevant for"
  echo "    RPI physical machines."
  echo
  echo "  --boottype < bios | uefi >"
  echo
  echo "    Defaults to UEFI."
  echo
  echo "  --chroot-directory < directory >"
  echo
  echo "    Directory to use for building the Alpine image. Defaults to './chroot'."
  echo
  echo "  --cloud <cloud type>"
  echo
  echo "    Valid values are:"
  echo "      generic aliyun aws azure bigstep brightbox digitalocean e24 exoscale"
  echo "      google hetzner hyperone ibmcloud oracle rootbox scaleway tencent"
  echo "      upcloud vultr"
  echo
  echo "  --cpu_vendor < amd | intel >"
  echo
  echo "    Used to decide if only AMD or Intel relevant microcode is installed and"
  echo "    whether vendor-specific kernal modules are included in the initramfs."
  echo
  echo "  --create-boot-partition"
  echo
  echo "    Create a separate /boot partition, even if not required."
  echo
  echo "  --debug"
  echo
  echo "    Enable debug-specific logging."
  echo
  echo "  --dhcp-client < dhclient | dhcpcd | udhcpc >"
  echo
  echo "    Specify the DHCP Client software to use. Defaults to 'udhcpc'."
  echo
  echo "  --disable-normal-console"
  echo
  echo "    Disable normal display-based Linux console. Can be used when serial"
  echo "    console is enabled if only serial is required."
  echo
  echo "  --disable-serial-console"
  echo
  echo "    Disable serial-based Linux console."
  echo
  echo "  --disable-unnecessary-modules"
  echo
  echo "    Prevent kernel modules from being loaded that are typically not relevant"
  echo "    for servers."
  echo
  echo "  --ethernet-module < module-name >"
  echo
  echo "    When remote unlocking of encrypted filesystem is enabled this parameter"
  echo "    is also required to specific the relevant kernel module for the ethernet"
  echo "    device as the driver must be included in the initramfs as (obviously) it"
  echo "    cannot be loaded from the (still encrypted at that point) rootfs."
  echo
  echo "  --encrypt"
  echo
  echo "    Enable encryption of the rootfs."
  echo
  echo "  --encrypt-passphrase < passphrase >"
  echo
  echo "    The passphrase to use for the encrypted filesystem. Defaults to"
  echo "    'InsecureDefault' if not specified."
  echo
  echo "  --encrypt-remote-unlock"
  echo
  echo "    Enable functionality for the remote-unlocking of encrypted filesystems"
  echo "    at boottime over SSH."
  echo
  echo "  --full-hostname < hostname >"
  echo
  echo "    Only for physical machines. The hostname, including domain, to place in the."
  echo "    generated user-data YAML file."
  echo
  echo "  --graphics-vendor < amd | intel | nvidia >"
  echo
  echo "    Indicate the vendor of server's graphics card so that the initramfs can"
  echo "    be generated containing only that vendor's drivers and firmware."
  echo
  echo "  --harden"
  echo
  echo "    Enabled kernel lockdown mode, and delete unnecessary users & groups and"
  echo "    also disable unnecessary kernel modules."
  echo
  echo "  --image-filename < filename >"
  echo
  echo "    Filename to use for the created Alpine disk image."
  echo
  echo "  --images-directory < directory >"
  echo
  echo "    The directory where to store the created disk image."
  echo
  echo "  --ipv4only"
  echo
  echo "    Do not enable IPv6 in the created disk image."
  echo
  echo "  --ipv6only"
  echo
  echo "    Do not enable IPv4 in the created disk image."
  echo
  echo "  --keymap '< keymap >'"
  echo
  echo "    Defaults to 'us us'."
  echo
  echo "  --local-repo < url >"
  echo
  echo "    Local Alpine repository for *additional* packages."
  echo
  echo "  --local-repo-sig-file < filename >"
  echo
  echo "    Signature file used to sign packages in local Alpine repository."
  echo
  echo "  --locale < locale >"
  echo
  echo "    Defaults to 'en_US'."
  echo
  echo "  --lvm"
  echo
  echo "    Use LVM for root filesystem. If '--encrypt' is also specified then"
  echo "    create LVM-on-LUKS filesystem."
  echo
  echo "  --minimise-users-groups"
  echo
  echo "    Delete any unnecessary users & groups."
  echo
  echo "  --mirror < mirror url >"
  echo
  echo "    URL of Alpine mirror site to use."
  echo
  echo "  --no-grub-encryption"
  echo
  echo "    Do not enable GRUB's own encryption (distinct from whether LUKS is"
  echo "    in use or not)."
  echo
  echo "  --password < password >"
  echo
  echo "    Password for default user created upon 1st boot. If this option is"
  echo "    not specified then the account password is locked (but SSH access"
  echo "    via SSH key, if configured using '--ssh-public-key', is still"
  echo "    possible."
  echo
  echo "  --physical < pc | rpi2 | rpi3 | rpi4 >"
  echo
  echo "    The type of physical machine to be created."
  echo
  echo "  --ramdisk-directory < directory >"
  echo
  echo "    When '--use-ramdisk' is also specified this value indicates the directory"
  echo "    in which to store the ramdisk file."
  echo
  echo "  --release < 3.13 | 3.14 | edge >"
  echo
  echo "    Which Alpine Release to use for the disk image. If not specified then"
  echo "    defaults to 'edge'."
  echo
  echo "  --remote-unlock-network-module < kernel module name >"
  echo
  echo "    Specifies the name of the network device kernel module to be loaded."
  echo
  echo "  --remote-unlock-ssh-port < port number >"
  echo
  echo "    Specifies the TCP port that the temporary SSH daemon should listen on."
  echo "    If not specified then defaults to '22'."
  echo
  echo "  --remote-unlock-static-gateway < IP address >"
  echo
  echo "    Specifies the IP address of the local router. Only applicable when"
  echo "    '--remote-unlock-static-ip' has also been specified."
  echo
  echo "  --remote-unlock-static-interface < interface name >"
  echo
  echo "    Specifies the network interface name. Only applicable when"
  echo "    '--remote-unlock-static-ip' has also been specified."
  echo
  echo "  --remote-unlock-static-ip < IP addrss >"
  echo
  echo "    Specifies the (temporary) IP address for the machine to use for remote"
  echo "    unlock functionality. If not specified then DHCP is used instead."
  echo
  echo "  --remote-unlock-static-netmask < netmask >"
  echo
  echo "    Specifies the network netmask to use. Only applicable when"
  echo "    '--remote-unlock-static-ip' has also been specified."
  echo
  echo "  --rpi-rtc"
  echo
  echo "    When creating an image for a Raspberry Pi (i.e. '--physical rpi2') indicates"
  echo "    that the RPI has a hardware RTC fitted."
  echo
  echo "  --script-filename < filename >"
  echo
  echo "    The filename of the script to be created."
  echo
  echo "  --short-hostname < hostname >"
  echo
  echo "    Only for physical machines. The hostname, without domain, to place in the."
  echo "    generated user-data YAML file."
  echo
  echo "  --ssh-public-key < filename >"
  echo
  echo "    File containing the SSH public key that is permitted to log in as the"
  echo "    default user and also, when remote encryption unlocking is enabled, to"
  echo "    connect to the temporary SSH server used for unlocking of disk"
  echo "    encryption."
  echo
  echo "  --timezone < zonename >"
  echo
  echo "    Only for physical machines. Timezone to place in the generated user-data"
  echo "    YAML file. Example value: 'Europe/London'."
  echo
  echo "  --use-ramdisk"
  echo
  echo "    Indicates to use a (temporary) ramdisk when creating the disk image to"
  echo "    speed up creation and/or to reduce disk writes (i.e. on SSD)."
  echo
  echo "  --username <username>"
  echo
  echo "    Name of the default account to create upon 1st boot. Defaults to 'alpine'."
  echo
  echo "  --virtual <vm type>"
  echo
  echo "    Valid values are:  generic hyperv libvirtd openstack proxmox qemu"
  echo "                       virtualbox vmware"
  echo
}


#
# Check that the combination of CLI options make sense
#
validate_cli_options() {
  # If --debug not specified then debug defaults to off
  if [ -z ${DEBUG+x} ]; then
    DEBUG=false
  fi

  if [ -z "$SCRIPT_FILENAME" ]; then
    echo
    echo "You must specify a filename for the script to be created!"
    echo
    exit 2
  fi

  # Don't harden image by default
  if [ -z ${IMAGE_HARDEN+x} ]; then
    IMAGE_HARDEN=false
  fi

  # If Filesystem type not specified, use default.
  if [ -z ${IMAGE_FS_TYPE+x} ]; then
    IMAGE_FS_TYPE=$DEFAULT_FS_TYPE
  fi

  # Don't disable unnecessary modules by default
  if [ -z ${DISABLE_UNNECESSARY_MODULES+x} ]; then
    DISABLE_UNNECESSARY_MODULES=false
  fi

  # If console name not specified then assume default
  if [ -z ${CONSOLE_NAME+x} ]; then
    CONSOLE_NAME=$DEFAULT_CONSOLE_NAME
  fi

  # If console type not specified then assume default
  if [ -z ${CONSOLE_TYPE+x} ]; then
    CONSOLE_TYPE="normal"
  fi

  # If Alpine release not specified then assume default
  if [ -z ${IMAGE_ALPINE_RELEASE+x} ]; then
    IMAGE_ALPINE_RELEASE=$DEFAULT_ALPINE_RELEASE
  fi

  # If arch not specified then assume default
  if [ -z ${IMAGE_ARCH+x} ]; then
    IMAGE_ARCH=$DEFAULT_ARCH
  fi

  # If neither Cloud / VM / Physical specified then assume QEMU VM
  if [ -z ${IMAGE_CLASS+x} ]; then
    IMAGE_CLASS="virtual"
    VM_TYPE="qemu"
  fi

  if [ -z ${IMAGE_KERNEL_TYPE+x} ]; then
    IMAGE_KERNEL_TYPE="normal"
  fi

  if [ -z "${IMAGE_FILENAME+x}" ]; then
    IMAGE_BASE_FILENAME="alpine-$IMAGE_ALPINE_RELEASE-$IMAGE_ARCH-$IMAGE_CLASS"
    case $IMAGE_CLASS in
      cloud )
        IMAGE_FILENAME="$IMAGE_BASE_FILENAME-$CLOUD_TYPE.img"
        ;;
      physical )
        IMAGE_FILENAME="$IMAGE_BASE_FILENAME-$PHYSICAL_TYPE.img"
        ;;
      virtual )
        IMAGE_FILENAME="$IMAGE_BASE_FILENAME-$VM_TYPE.img"
        ;;
    esac
  fi

  # Log filename is based on image filename
  LOGFILE=$(echo $IMAGE_FILENAME | sed -e 's|\.img$|\.log|')

  # If version of APK-static is not specified then assume default
  if [ -z ${APK_STATIC_VERSION+x} ]; then
    APK_STATIC_VERSION=$DEFAULT_APK_STATIC_VERSION
  fi

  # If URL to download APK-static is not specified then assume default
  if [ -z ${APK_STATIC_URL+x} ]; then
    APK_STATIC_URL=$DEFAULT_APK_STATIC_URL
  fi

  # If chroot directory not specified then assume default
  if [ -z ${CHROOT_DIRECTORY+x} ]; then
    CHROOT_DIRECTORY=$DEFAULT_CHROOT_DIRECTORY
  fi

  # If images directory not specified then assume default
  if [ -z ${IMAGES_DIRECTORY+x} ]; then
    IMAGES_DIRECTORY=$DEFAULT_IMAGES_DIRECTORY
  fi

  # If USE_RAMDISK specified then assume disabled
  if [ -n "${USE_RAMDISK+x}" ]; then
    if [ -z "${RAMDISK_DIRECTORY+x}" ]; then
      # If ramdisk directory not specified then assume default
      RAMDISK_DIRECTORY=$DEFAULT_RAMDISK_DIRECTORY
    fi
  else
    USE_RAMDISK=false
  fi

  # If Alpine repo mirror site not specified then assume default
  if [ -z ${ALPINE_MIRROR_SITE+x} ]; then
    ALPINE_MIRROR_SITE=$DEFAULT_MIRROR_SITE
  fi

  if [ -z ${IMAGE_AUTH_CONTROL+x} ]; then
    IMAGE_AUTH_CONTROL=$DEFAULT_AUTH_CONTROL
  fi

  # If boot_by_label not specified then assume default
  if [ -z ${IMAGE_BOOT_REFERENCE+x} ]; then
    IMAGE_BOOT_REFERENCE=$DEFAULT_BOOT_REFERENCE
  fi

  if [ -z ${IMAGE_ADMIN_USERNAME+x} ]; then
    IMAGE_ADMIN_USERNAME=$DEFAULT_ADMIN_USERNAME
  fi

  if [ -z ${IMAGE_DHCP_CLIENT+x} ]; then
    IMAGE_DHCP_CLIENT=$DEFAULT_DHCP_CLIENT
  fi

  if [ -z ${IMAGE_ENABLE_UTMP+x} ]; then
    IMAGE_ENABLE_UTMP=false
  fi

  if [ -z ${IMAGE_ENCRYPTED+x} ]; then
    IMAGE_ENCRYPTED=false
  fi

  if [ -z ${IMAGE_FIREWALL+x} ]; then
    IMAGE_FIREWALL=$DEFAULT_FIREWALL
  fi

  if [ -z ${IMAGE_KEYMAP+x} ]; then
    IMAGE_KEYMAP=$DEFAULT_KEYMAP
  fi

  if [ -z ${IMAGE_LOCALE+x} ]; then
    IMAGE_LOCALE=$DEFAULT_LOCALE
  fi

  # If SSH server software not specified then assume default
  if [ -z ${IMAGE_SSH_SERVER+x} ]; then
    IMAGE_SSH_SERVER=$DEFAULT_SSH_SERVER
  fi

  if [ -z ${IMAGE_TIMEZONE+x} ] && \
     [ "$IMAGE_CLASS" = "physical" ]; then
    IMAGE_TIMEZONE=$DEFAULT_TIMEZONE
  fi

  if [ -z ${IMAGE_FOR_SSD+x} ]; then
    IMAGE_FOR_SSD=false
  fi

  if [ -z ${REMOTE_UNLOCK+x} ]; then
    REMOTE_UNLOCK=false
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    if [ "$IMAGE_CLASS" = "cloud" ] && \
       [ "$CLOUD_TYPE" = "aws" ]; then
      echo
      echo "For AWS you should use an encrypted EBS device!"
      echo
      exit 2
    fi

    if [ -z "${IMAGE_ENCRYPTION_PASSPHRASE+x}" ]; then
      IMAGE_ENCRYPTION_PASSPHRASE="$DEFAULT_LUKS_PASSPHRASE"
    fi
  fi

  if [ "$REMOTE_UNLOCK" = "true" ]; then
    if [ "$IMAGE_CLASS" = "cloud" ]; then
      echo
      echo "Remote unlocking of encrypted rootfs is not supported in cloud!"
      echo
      exit 2
    fi
  fi

  if [ "$IMAGE_FOR_SSD" = "true" ] && \
     [ "$IMAGE_CLASS" != "physical" ]; then
    echo
    echo "--for-ssd setting only applies to physical machines!"
    echo
    exit 2
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Check for cloud machines that other specified settings make sense
    case $IMAGE_ARCH in
      aarch64 )
        if [ -n "${IMAGE_BOOTLOADER+x}" ]; then
          if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
            echo
            echo "aarch64 cloud machine can only use Grub bootloader!"
            echo
            exit 2
          fi
        else
          IMAGE_BOOTLOADER="grub"
        fi
        case $CLOUD_TYPE in
          aws | oracle )
            ;;
          * )
            echo
            echo "aarch64 cloud images cannot be created for this cloud provider!"
            echo
            exit 2
            ;;
        esac
        # aarch VMs always use UEFI
        IMAGE_BOOT_TYPE="uefi"
        ;;

      x86_64 )
        case $CLOUD_TYPE in
          oracle )
            IMAGE_BOOT_TYPE="bios"
            IMAGE_BOOTLOADER="syslinux"
            ;;
          vultr )
            IMAGE_BOOT_TYPE="bios"
            IMAGE_BOOTLOADER="syslinux"
            ;;
          * )
            IMAGE_BOOT_TYPE="bios"
            IMAGE_BOOTLOADER="grub"
            ;;
        esac
        ;;
    esac
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Check for physical machines that other specified settings make sense
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      if [ "$IMAGE_ARCH" = "x86" ]; then
        # x86
        if [ -z "${IMAGE_BOOTLOADER+x}" ]; then
          IMAGE_BOOTLOADER="syslinux"
        fi
        if [ -n "${IMAGE_BOOT_TYPE+x}" ]; then
          IMAGE_BOOT_TYPE="bios"
        elif [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
          echo
          echo "UEFI is not supported for x86!"
          echo
          exit 2
        fi
      else
        # x86_64
        if [ -z "${IMAGE_BOOT_TYPE+x}" ]; then
          IMAGE_BOOT_TYPE="uefi"
          if [ -z "${IMAGE_BOOTLOADER+x}" ]; then
            IMAGE_BOOTLOADER="grub"
          fi
        fi
        if [ -z "${IMAGE_BOOTLOADER+x}" ]; then
          IMAGE_BOOTLOADER="syslinux"
        fi
      fi
    elif [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
      # Raspberry Pi
      if [ -z "${IMAGE_BOOTLOADER+x}" ]; then
        IMAGE_BOOTLOADER="rpi"

        if [ -z ${IMAGE_BOOT_TYPE+x} ]; then
          IMAGE_BOOT_TYPE="rpi"
        elif [ "$IMAGE_BOOT_TYPE" != "rpi" ]; then
          echo
          echo "An invalid boot type was specified! For an RPI only 'rpi' is valid"
          echo
          exit 2
        fi
      elif [ "${IMAGE_BOOTLOADER}" != "rpi" ]; then
        echo
        echo "An invalid bootloader was specified!"
        echo
        exit 2
      fi

      if [ -z "${RPI_RTC+x}" ]; then
        RPI_RTC=false
      fi
    fi
  elif [ "$IMAGE_CLASS" = "virtual" ]; then
    # Check for Virtual Machines that other specified settings make sense
    case $IMAGE_ARCH in
      armv7 )
        echo
        echo "armv7 virtual machines are not supported!"
        echo
        exit 2
        ;; 
      aarch64 )
        if [ -n "${IMAGE_BOOTLOADER+x}" ]; then
          if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
            echo
            echo "aarch64 virtual machine can only use Grub bootloader!"
            echo
            exit 2
          fi
        else
          IMAGE_BOOTLOADER="grub"
        fi

        if [ "$VM_TYPE" = "virtualbox" ]; then
          echo
          echo "aarch64 Virtualbox images cannont be created!"
          echo
          exit 2
        fi

        # aarch VMs always use UEFI
        IMAGE_BOOT_TYPE="uefi"
        ;;
      x86 )
        if [ -z "${IMAGE_BOOTLOADER+x}" ]; then
          IMAGE_BOOTLOADER="syslinux"
        fi

        if [ -n "${IMAGE_BOOT_TYPE+x}" ]; then
          IMAGE_BOOT_TYPE="bios"
        elif [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
          echo
          echo "UEFI is not supported for x86!"
          echo
          exit 2
        fi
        ;;
      x86_64 )
        if [ -z ${IMAGE_BOOTLOADER+x} ]; then
          if [ -z ${IMAGE_BOOT_TYPE+x} ]; then
            IMAGE_BOOTLOADER="syslinux"
            IMAGE_BOOT_TYPE="uefi"
          elif [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
            IMAGE_BOOTLOADER="syslinux"
          else
            IMAGE_BOOTLOADER="syslinux"
          fi
        elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
          if [ -z ${IMAGE_BOOT_TYPE+x} ]; then
            IMAGE_BOOT_TYPE="uefi"
          fi
        else
          if [ -z ${IMAGE_BOOT_TYPE+x} ]; then
            IMAGE_BOOT_TYPE="uefi"
          fi
        fi
        ;;
    esac
  fi

  if [ -z ${CREATE_BOOT_PARTITION+x} ]; then
    CREATE_BOOT_PARTITION=false
  fi

  if [ "$CREATE_BOOT_PARTITION" = "true" ] && \
       [ "$IMAGE_BOOTLOADER" = "grub" ]; then
    # By creating a separate boot partition this means that
    # GRUB should also not enable its own encryption support.
    NO_GRUB_ENCRYPTION=true
  fi

  if [ -z ${NO_GRUB_ENCRYPTION+x} ]; then
    NO_GRUB_ENCRYPTION=false
  fi

  if { [ "$IMAGE_CLASS" = "physical" ] && \
       [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; } || \
     { [ "$IMAGE_BOOTLOADER" = "syslinux" ]  && \
       [ "$IMAGE_BOOT_TYPE" = "bios" ] && \
       { [ "$IMAGE_ENCRYPTED" = "true" ] || \
         [ -n "${IMAGE_LVM_ROOTFS+x}" ]; } } || \
     { [ "$IMAGE_BOOTLOADER" = "grub" ] && \
       [ "$IMAGE_ENCRYPTED" = "true" ] && \
       [ "$REMOTE_UNLOCK" = "true" ]; } || \
     { [ "$IMAGE_BOOTLOADER" = "grub" ] && \
       [ "$IMAGE_ENCRYPTED" = "true" ] && \
       [ "$NO_GRUB_ENCRYPTION" = "true" ]; } || \
     [ "$CREATE_BOOT_PARTITION" = "true" ]; then
    # A separate boot partition is required in the following situations:
    # (a) its a Raspberry Pi
    # (b) Syslinux is used as bootloader for BIOS with encrypted rootfs or LVM rootfs
    # (c) GRUB is used as bootloader with remote unlock of encrypted rootfs
    # (d) GRUB is used as bootloader with encrypted rootfs but unencrypted boot partition
    # (e) a separate boot partition is explicitly requested
    NEEDS_BOOT_PARTITION=true
  else
    NEEDS_BOOT_PARTITION=false
  fi

  # Sort out partition sizing
  case $IMAGE_CLASS in
    cloud )
      BOOT_PART_SIZE=$CLOUD_BOOT_PART_SIZE
      ROOT_PART_SIZE=$CLOUD_ROOT_PART_SIZE
      UEFI_PART_SIZE=$CLOUD_UEFI_PART_SIZE
      ;;
    physical )
      if [ "$PHYSICAL_TYPE" = "pc" ]; then
        # PC
        BOOT_PART_SIZE=$PHYSICAL_BOOT_PART_SIZE
        ROOT_PART_SIZE=$PHYSICAL_ROOT_PART_SIZE
        UEFI_PART_SIZE=$PHYSICAL_UEFI_PART_SIZE
      else
        # Raspberry Pi
        BOOT_PART_SIZE=$RPI_BOOT_PART_SIZE
        ROOT_PART_SIZE=$RPI_ROOT_PART_SIZE
      fi
      ;;
    virtual )
      BOOT_PART_SIZE=$VIRTUAL_BOOT_PART_SIZE
      ROOT_PART_SIZE=$VIRTUAL_ROOT_PART_SIZE
      UEFI_PART_SIZE=$VIRTUAL_UEFI_PART_SIZE
      ;;
  esac

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    IMAGE_LUKS_PART_SIZE=$(calculate_luks_part_size)
  elif [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    IMAGE_LVM_PART_SIZE=$(calculate_lvm_vg_size)
  else
    IMAGE_ROOT_PART_SIZE=$(calculate_root_part_size)
  fi

  IMAGE_BOOT_PART_SIZE=$(calculate_boot_part_size)

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    IMAGE_UEFI_PART_SIZE=$(calculate_uefi_part_size)
  fi
}

#############################################################################
##		Main Section
#############################################################################

FULL_COMMAND_OPTIONS="$*"

echo
echo "create-alpine-disk-image version $SCRIPT_VERSION"

parse_cli_options "$@"
validate_cli_options

echo
echo "Using the following settings:"
echo "  Image arch: $IMAGE_ARCH"
echo "  Image class: $IMAGE_CLASS"
case $IMAGE_CLASS in
  cloud )
    echo "  Cloud type: $CLOUD_TYPE"
    ;;
  physical )
    echo "  Physical machine type: $PHYSICAL_TYPE"
    ;;
  virtual )
    echo "  VM type: $VM_TYPE"
    ;;
esac
echo "  Alpine release: $IMAGE_ALPINE_RELEASE"
echo "  Boot Type: $IMAGE_BOOT_TYPE"
echo "  Bootloader: $IMAGE_BOOTLOADER"
echo "  Filesystem type: $IMAGE_FS_TYPE"
if [ "$IMAGE_ENCRYPTED" = "true" ]; then
  echo "  Image LUKS partition size: $IMAGE_LUKS_PART_SIZE"
elif [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
  echo "  Image LVM partition size: $IMAGE_LVM_PART_SIZE"
else
  echo "  Image root partition size: $IMAGE_ROOT_PART_SIZE"
fi

#############################################################################
##		Prepare the run script
#############################################################################

RUN_SCRIPT=$SCRIPT_FILENAME
create_runscript_header
add_runscript_functions

cat <<EOF >> "$RUN_SCRIPT"

check_for_required_packages
check_binfmt_packages $IMAGE_ARCH

mkdir -p \$IMAGES_DIRECTORY

EOF

if [ "$USE_RAMDISK" = "true" ]; then
  cat <<EOF >> "$RUN_SCRIPT"
write_log "Setting up ramdisk"
mkdir -p \$RAMDISK_DIRECTORY
mount -t tmpfs -o size=$RAMDISK_SIZE tmpfs \$RAMDISK_DIRECTORY >> \$LOGFILE
EOF
fi

if [ -z ${DISK_IMAGE_SIZE+x} ]; then
   DISK_IMAGE_SIZE=$(calculate_image_size)
fi

cat <<EOF >> "$RUN_SCRIPT"
write_log "Creating sparse disk image of ${DISK_IMAGE_SIZE}MiB"
truncate -s ${DISK_IMAGE_SIZE}M \$IMAGE_FULL_FILENAME >> \$LOGFILE
EOF

if [ "$IMAGE_BOOT_TYPE" = "rpi" ]; then
  partition_rpi
elif [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
  partition_bios
else
  partition_uefi
fi

if [ "$DEBUG" = "true" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"

write_debug_log "  Resultant partition layout:"
parted --machine --script --align=optimal $IMAGE_FULL_FILENAME \
  unit MiB \
  print \
  >> $LOGFILE
EOF
fi

cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Setting up loop device for disk image"
LOOP_DEVICE=$(losetup -P --show -f $IMAGE_FULL_FILENAME 2>> $LOGFILE)
if [ -z "$LOOP_DEVICE" ]; then
  echo
  echo "There was a problem creating the loop device. Aborting!"
  echo
  exit 1
fi
EOF

if [ "$IMAGE_ENCRYPTED" = "true" ]; then
  setup_luks_device
elif [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
  setup_lvm_device
fi

format_and_mount_fs

if [ "$IMAGE_ENCRYPTED" = "true" ] && \
   [ "$IMAGE_BOOTLOADER" = "grub" ] && \
   [ "$REMOTE_UNLOCK" != "true" ] && \
   [ "$NO_GRUB_ENCRYPTION" != "true" ]; then
  # LUKS keyfile is only used with GRUB when GRUB's own Cryptodisk is
  # enabled (so does not apply when Remote Unlock enabled).
  copy_luks_keyfile_into_place
  setup_crypttab
fi

download_static_apk

cat <<EOF >> "$RUN_SCRIPT"

mkdir -p "\$CHROOT_DIRECTORY"/etc

write_log "Copying system's /etc/resolv.conf into chroot filesystem"
cp /etc/resolv.conf "\$CHROOT_DIRECTORY"/etc/

mkdir -p "\$CHROOT_DIRECTORY"/etc/apk/keys
write_log "Creating /etc/apk/repositories file inside chroot"
echo \
  "$ALPINE_MIRROR_SITE/$IMAGE_ALPINE_RELEASE/main" \
  > "\$CHROOT_DIRECTORY"/etc/apk/repositories
EOF

if [ -n "${LOCAL_REPO_SIGNATURE_FILE+x}" ]; then
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Copy local repo key to /etc/apk/keys/ directory inside chroot"
cp "$LOCAL_REPO_SIGNATURE_FILE" "\$CHROOT_DIRECTORY"/etc/apk/keys/
EOF
fi

install_alpine_base

cat <<EOF >> "$RUN_SCRIPT"

rm -Rf \$TMPDIR/apk-tools-$APK_STATIC_VERSION

write_log "Mounting /proc, /sys, and /dev special filesystems in chroot"
{
  mount -v -t proc none \$CHROOT_DIRECTORY/proc
  mount -v -t none -o rbind /sys \$CHROOT_DIRECTORY/sys
  mount -v --make-rprivate \$CHROOT_DIRECTORY/sys
  mount -v -t none -o rbind /dev \$CHROOT_DIRECTORY/dev
  mount -v --make-rprivate \$CHROOT_DIRECTORY/dev
EOF

if [ "$DEBUG" = "true" ]; then
  cat <<EOF >> "$RUN_SCRIPT"
  mount | grep \$CHROOT_DIRECTORY
EOF
fi

cat <<EOF >> "$RUN_SCRIPT"
} >> \$LOGFILE 2>&1
EOF

define_additional_packages

# shellcheck disable=SC2129
cat <<'EOF' >> "$RUN_SCRIPT"

#############################################################################
##		Start of Chroot section
#############################################################################

chroot "$CHROOT_DIRECTORY" /bin/sh -eu <<EOT

EOF

if [ -n "${IMAGE_SHORT_HOSTNAME+x}" ]; then
  cat <<EOF >> "$RUN_SCRIPT"
SHORT_HOSTNAME="$IMAGE_SHORT_HOSTNAME"

EOF
elif [ -n "${IMAGE_FULL_HOSTNAME+x}" ]; then
  cat <<EOF >> "$RUN_SCRIPT"
FULL_HOSTNAME="$IMAGE_FULL_HOSTNAME"

EOF
fi
cat <<EOF >> "$RUN_SCRIPT"
KEYMAP="$IMAGE_KEYMAP"
LOCALE="$IMAGE_LOCALE"
EOF

if [ "$IMAGE_CLASS" = "physical" ]; then
  cat <<EOF >> "$RUN_SCRIPT"
TIMEZONE="$IMAGE_TIMEZONE"
EOF
fi

cat <<'EOF' >> "$RUN_SCRIPT"

############################################################################
##		Chroot Functions
############################################################################

add_fstab_entry() {
  local ENTRY_TYPE=\$1
  local ENTRY_VALUE=\$2
  local MOUNT_POINT=\$3
  local FS_TYPE=\$4
  local FS_OPTIONS=\$5
  local ENTRY_LOG=\$6

  if [ "\$ENTRY_TYPE" = "BIND" ]; then
    local FS_OPTIONS="bind,\${FS_OPTIONS}"
    local FS_PASSNO="0"
  elif [ "\$MOUNT_POINT" = "/" ]; then
    local FS_PASSNO="1"
  else
    local FS_PASSNO="2"
  fi

  if [ "\$ENTRY_TYPE" = "BIND" ] ||
     [ "\$ENTRY_TYPE" = "DEVICE" ]; then
    FSTAB_ENTRY="\${ENTRY_VALUE}"
  else
    FSTAB_ENTRY="\${ENTRY_TYPE}=\${ENTRY_VALUE}"
  fi
  FSTAB_ENTRY="\${FSTAB_ENTRY}\t\${MOUNT_POINT}\t\${FS_TYPE}\t\${FS_OPTIONS} 0 \${FS_PASSNO}"

  write_log "  Add \${ENTRY_LOG} entry"
  # shellcheck disable=SC2169,SC3036
  echo -e "\${FSTAB_ENTRY}" >> /etc/fstab
}
EOF

if [ "$IMAGE_ENCRYPTED" = "true" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"


define_cmdline_for_encryption() {
  local CMDLINE

EOF

  CMDLINE_LIST="cryptroot=UUID=\${LUKS_PART_UUID} cryptdm=cryptroot"

  if [ "$REMOTE_UNLOCK" = "true" ]; then
    if [ -n "${REMOTE_UNLOCK_STATIC_IP+x}" ]; then
      # Indicate the IP address to use by initramfs for configuring
      # the ethernet interface for Dropbear to listen on.
      if [ -n "${REMOTE_UNLOCK_STATIC_GATEWAY+x}" ]; then
        STATIC_GATEWAY=$REMOTE_UNLOCK_STATIC_GATEWAY
      else
        STATIC_GATEWAY=""
      fi
      if [ -n "${REMOTE_UNLOCK_STATIC_INTERFACE+x}" ]; then
        STATIC_INTERFACE=$REMOTE_UNLOCK_STATIC_INTERFACE
      else
        STATIC_INTERFACE=""
      fi
      if [ -n "${REMOTE_UNLOCK_STATIC_NETMASK+x}" ]; then
        STATIC_NETMASK=$REMOTE_UNLOCK_STATIC_NETMASK
      else
        STATIC_NETMASK=""
      fi
      CMDLINE_LIST="$CMDLINE_LIST ip=$REMOTE_UNLOCK_STATIC_IP::$STATIC_GATEWAY:$STATIC_NETMASK::$STATIC_INTERFACE:none:"
    else
      # Indicate that DHCP should be used by initramfs' init.
      CMDLINE_LIST="$CMDLINE_LIST ip=dhcp"
    fi

    # Indicate that Dropbear should be run by initramfs' init.
    CMDLINE_LIST="$CMDLINE_LIST remote_unlock_luks"

    if [ -n "${REMOTE_UNLOCK_SSH_PORT+x}" ]; then
      # Indicate the port that Dropbear should listen on
      CMDLINE_LIST="$CMDLINE_LIST remote_unlock_luks_ssh_port=$REMOTE_UNLOCK_SSH_PORT"
    fi
  fi

  cat <<EOF >> "$RUN_SCRIPT"
  CMDLINE="$CMDLINE_LIST"
EOF

  cat <<'EOF' >> "$RUN_SCRIPT"
  echo "\$CMDLINE"
}
EOF
fi

cat <<'EOF' >> "$RUN_SCRIPT"


get_kernel_version() {
EOF

case $IMAGE_CLASS in
  cloud | virtual )
    KERNEL_PACKAGE="virt" ;;
  physical )
    case $PHYSICAL_TYPE in
      pc )
        KERNEL_PACKAGE="lts" ;;
      rpi2 | rpi3 )
        if [ "$IMAGE_ARCH" = "armv7" ]; then
          KERNEL_PACKAGE="rpi2"
        else
          KERNEL_PACKAGE="rpi"
        fi
        ;;
      rpi4 )
        KERNEL_PACKAGE="rpi4" ;;
    esac
    ;;
esac

cat <<EOF >> "$RUN_SCRIPT"
  apk info linux-$KERNEL_PACKAGE | head -n 1 | sed -e 's/^linux-$KERNEL_PACKAGE-//' -e 's/-r/-/' -e 's/ .*//' -Ee 's/^(.*)\$/\\1-$KERNEL_PACKAGE/'
}

write_debug_log() {
EOF

if [ "$DEBUG" = "true" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"
  current_time=\$(printf "[%s]" "\$(date -u "+%Y-%m-%d %H:%M:%S")")
  echo "\$current_time chroot: \$1" >> /chroot.log
EOF
else
  cat <<'EOF' >> "$RUN_SCRIPT"
  # Debug not enabled so do nothing
  true
EOF
fi

cat <<'EOF' >> "$RUN_SCRIPT"
}

write_log() {
  current_time=\$(printf "[%s]" "\$(date -u "+%Y-%m-%d %H:%M:%S")")
  echo "\$current_time chroot: \$1" >> /chroot.log
  echo "chroot: \$1"
}

############################################################################
##		Chroot Main Section
############################################################################

EOF

configure_fstab

add_additional_repos

update_upgrade_packages

basic_os_configuration

setup_etc_modules

if [ -n "${DELETE_UNNECESSARY_USERS_GROUPS+x}" ]; then
  delete_users_groups
fi

disable_extra_getty

add_base_init_d

install_additional_packages

additional_os_configuration

configure_cloud_init

if [ "$CONSOLE_TYPE" = "serial" ] || \
   [ "$CONSOLE_TYPE" = "both" ]; then
  enable_serial_console
fi

add_additional_init_d

if [ "$IMAGE_HARDEN" = "true" ]; then
  create_module_blocking_initd
fi
if [ "$DISABLE_UNNECESSARY_MODULES" = "true" ]; then
  disable_kernel_modules
fi

configure_mkinitfs

if [ "$IMAGE_ENCRYPTED" = "true" ] && \
   [ -n "${SSH_PUBLIC_KEY+x}" ]; then
  setup_dropbear_authorized_keys
fi

if [ -n "${IMAGE_LVM_ROOTFS+x}" ] && \
   [ "$IMAGE_BOOTLOADER" = "grub" ]; then

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
	cp /usr/sbin/grub-mkconfig /usr/sbin/grub-mkconfig-orig
}
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
write_log "  Tweaking grub-mkconfig to prevent LVM-related warning"
sed -i \
  -Ee 's|^(GRUB_DEVICE="\`)(.*)|\1export LVM_SUPPRESS_FD_WARNINGS=1; \2|' \
  -Ee 's|^(GRUB_DEVICE_UUID="\`)(.*)|\1export LVM_SUPPRESS_FD_WARNINGS=1; \2|' \
  -Ee 's|^(GRUB_DEVICE_PARTUUID="\`)(.*)|\1 export LVM_SUPPRESS_FD_WARNINGS=1; \2|' \
  -Ee 's|^(GRUB_DEVICE_BOOT="\`)(.*)|\1export LVM_SUPPRESS_FD_WARNINGS=1; \2|' \
  -Ee 's|^(GRUB_DEVICE_BOOT_UUID="\`)(.*)|\1export LVM_SUPPRESS_FD_WARNINGS=1; \2|' \
  -Ee 's|^(GRUB_FS="\`)(.*)|\1export LVM_SUPPRESS_FD_WARNINGS=1; \2|' \
  /usr/sbin/grub-mkconfig
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
	diff /usr/sbin/grub-mkconfig-orig /usr/sbin/grub-mkconfig \
    >> /chroot.log \
    || true
}
EOF
  fi
fi

install_kernel

if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
  configure_bootloader_grub
elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
  configure_bootloader_syslinux
elif [ "$IMAGE_CLASS" = "physical" ] && \
     [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
  configure_bootloader_rpi
fi

if [ "$IMAGE_ENCRYPTED" = "true" ] && \
   [ "$IMAGE_BOOTLOADER" = "grub" ] && \
   [ "$REMOTE_UNLOCK" != "true" ] && \
   [ "$NO_GRUB_ENCRYPTION" != "true" ]; then
  # When using GRUB encryption along with a keyfile (to avoid 2nd prompt),
  # ensure that initramfs is only readable by root as it contains the
  # keyfile to decrypt the root partition.
  case $IMAGE_CLASS in
    cloud | virtual )
      if [ "$IMAGE_KERNEL_TYPE" = "edge" ]; then
        INITRAMFS_FILENAME="initramfs-edge-virt"
      else
        INITRAMFS_FILENAME="initramfs-virt"
      fi
      ;;
    physical )
      if [ "$(expr "$PHYSICAL_TYPE" : '.*rpi.*')" -gt 0 ]; then
        INITRAMFS_FILENAME="initramfs-rpi"
      else
        if [ "$IMAGE_KERNEL_TYPE" = "edge" ]; then
          INITRAMFS_FILENAME="initramfs-edge"
        else
          INITRAMFS_FILENAME="initramfs-lts"
        fi
      fi
      ;;
  esac
  cat <<EOF >> "$RUN_SCRIPT"

chmod 600 /boot/$INITRAMFS_FILENAME
EOF
fi

if [ "$DEBUG" = "true" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  write_debug_log "mkinitfs contents:"
  mkinitfs -l "\$KERNEL_VERSION" >> /chroot.log
}
EOF
fi

if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
  install_grub
elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
  install_syslinux
fi

if [ "$DEBUG" = "true" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  df -k >> /chroot.log
  write_debug_log "/boot size:"
	du -k /boot/ |sort -n >> /chroot.log
  write_debug_log "/boot contents:"
  ls -laR /boot/ >> /chroot.log
EOF

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    # UEFI
    cat <<'EOF' >> "$RUN_SCRIPT"

  write_debug_log "/efi size:"
	du -k /efi/ |sort -n >> /chroot.log
  write_debug_log "Contents of /efi directory:"
  ls -lR /efi >> /chroot.log
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

  apk info | sort > /final-packages.list
}
EOF
fi

cat <<'EOF' >> "$RUN_SCRIPT"

EOT

#############################################################################
##		End of Chroot section
#############################################################################

cat "$CHROOT_DIRECTORY"/chroot.log >> "$LOGFILE"
rm "$CHROOT_DIRECTORY"/chroot.log

write_log "Finished chroot section"

write_log "Removing temporary /etc/resolv.conf from chroot filesystem"
rm "$CHROOT_DIRECTORY"/etc/resolv.conf
EOF

if [ "$DEBUG" = "true" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
mv "$CHROOT_DIRECTORY"/base-packages.list .
mv "$CHROOT_DIRECTORY"/final-packages.list .
EOF
fi

cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Cleaning up"
normal_cleanup
EOF

if [ "$USE_RAMDISK" = "true" ]; then
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Copying image from ramdisk to final location"
cp "\$IMAGE_FULL_FILENAME" "\$IMAGES_DIRECTORY/"

if mount | grep -q "\$RAMDISK_DIRECTORY" ; then
  write_log "Unmounting ramdisk"
  umount \$RAMDISK_DIRECTORY >> \$LOGFILE
  # A small delay before rmdir as sometimes the umount is not immediate
  sleep 10
  rmdir \$RAMDISK_DIRECTORY
fi
EOF
fi

cat <<'EOF' >> "$RUN_SCRIPT"

# Clear exit trap function
trap EXIT

exit

EOF

if [ "$DEBUG" = "true" ]; then
  shellcheck -s ash -e SC1117 "$RUN_SCRIPT"
  # shellcheck disable=SC2034
  RET_CODE=$?
  #if [ $RET_CODE != 0 ]; then
  #  exit 2
  #fi
fi

chmod +x "$RUN_SCRIPT"

echo
echo "Created tailored script '$RUN_SCRIPT'."
echo "This script must be run as user 'root'."
echo

exit
