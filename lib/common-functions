#!/bin/sh
# shellcheck disable=SC1117,SC2039

#############################################################################
##
##  common-functions
##
##  Copyright 2021-2023 Dermot Bradley <dermot_bradley@yahoo.com>
##
##  Licensed via GPL version 2.0
##
#############################################################################


#
# Add more Alpine repos to the repositories file.
#
add_additional_repos() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Adding additional repos"
	{
	EOF

  if [ "$image_alpine_release" = "edge-special" ]; then
    add_alpine_repo "$alpine_mirror_site" "edge" "community"
    add_alpine_repo "$alpine_mirror_site" "edge" "testing"
    if [ -n "$local_alpine_repository" ]; then
      add_alpine_repo "$local_alpine_repository" "edge"
    fi
  else
    add_alpine_repo "$alpine_mirror_site" "$image_alpine_release" "community"

    case $image_alpine_release in
      edge )
        add_alpine_repo "$alpine_mirror_site" "$image_alpine_release" "testing" ;;
    esac

    if [ -n "$local_alpine_repository" ]; then
      add_alpine_repo "$local_alpine_repository" "$image_alpine_release"
    fi
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Enable base Alpine init.d services.
#
add_base_init_d() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Enable init.d scripts"
	{
	EOF

  add_init_d_service "devfs" "sysinit" 2
  add_init_d_service "dmesg" "sysinit" 2

  cat <<-'EOF' >> "$run_script"
	
	EOF

  add_init_d_service "bootmisc" "boot" 2
  add_init_d_service "hostname" "boot" 2
  add_init_d_service "modules" "boot" 2
  add_init_d_service "swap" "boot" 2
  case $image_alpine_release in
    v3.13 | v3.14 | v3.15 | v3.16 )
      add_init_d_service "urandom" "boot" 2 ;;
    * )
      add_init_d_service "seedrng" "boot" 2 ;;
  esac

  case $image_class in
    cloud | virtual )
      add_init_d_service "osclock" "boot" 2 ;;
    physical )
      case $image_physical_type in
        rpi* )
          if [ -n "$rpi_use_rtc" ]; then
            # With hardware RTC
            add_init_d_service "osclock" "boot" 2
          else
            # Without hardware RTC
            add_init_d_service "swclock" "boot" 2
          fi
          ;;
        * )
          add_init_d_service "osclock" "boot" 2 ;;
      esac
      ;;
  esac

  cat <<-'EOF' >> "$run_script"
	
	EOF

  add_init_d_service "networking" "default" 2

  cat <<-'EOF' >> "$run_script"
	
	EOF

  add_init_d_service "killprocs" "shutdown" 2
  add_init_d_service "mount-ro" "shutdown" 2
  add_init_d_service "savecache" "shutdown" 2

  cat <<-'EOF' >> "$run_script"
	} >> /chroot.log 2>&1
	EOF
}


#
# Add an entry to /etc/apk/repositories file.
#
add_alpine_repo() {
  local _alpine_mirror=$1
  local _alpine_release=$2
  local _alpine_repo=${3:-local}

  cat <<EOF >> "$run_script"
  write_log "Adding ${_alpine_repo} repo to /etc/apk/repositories" 2
  cat <<-_SCRIPT_ >> /etc/apk/repositories
EOF

  if [ "$_alpine_repo" = "local" ]; then
    cat <<EOF >> "$run_script"
	${_alpine_mirror}/${_alpine_release}
EOF
  else
    cat <<EOF >> "$run_script"
	${_alpine_mirror}/${_alpine_release}/${_alpine_repo}
EOF
  fi

  cat <<'EOF' >> "$run_script"
	_SCRIPT_
EOF
}


#
# Enable the specified service on the specified runlevel.
#
add_init_d_service() {
  local _service_name=$1
  local _run_level=$2
  local _indent=${3:-0}

  cat <<-EOF >> "$run_script"
	$(printf "%${_indent}s")rc-update add ${_service_name} ${_run_level}
	EOF
}


#
# Returns all entries from a comma-separated string
# except the specified entry.
#
all_entries_in_comma_list_except() {
  local _comma_list="$1"
  local _cl_except="$2"

  all_entries_in_list_except "$_comma_list" "$_cl_except" ","
}


#
# Returns all entries from a string (which uses the specified
# separator) except the specified entry.
#
all_entries_in_list_except() {
  local _list="$1"
  local _keep_item="$2"
  local _separator="$3"

  local _check _check_item _resulting_list=""

  _check="$_list"
  while true; do
    _check_item="$(first_entry_in_list "$_check" "$_separator")"
    case $_check_item in
      generic )
        : ;;
      * )
        if [ "$_check_item" != "$_keep_item" ]; then
          if [ -n "$_resulting_list" ]; then
            _resulting_list="${_resulting_list}${_separator}${_check_item}"
          else
            _resulting_list="${_check_item}"
          fi
        fi
        ;;
    esac
    if [ "${_check%$_separator*}" = "$_check" ]; then
      # No more entries
      break
    else
      _check="${_check#$_check_item$_separator}"
    fi
  done

  echo "$_resulting_list"
}


#
# Returns all entries from a space-separated string
# except the specified entry.
#
all_entries_in_space_list_except() {
  local _space_list="$1"
  local _sl_except="$2"

  all_entries_in_list_except "$_space_list" "$_sl_except" " "
}


#
# Change the extension of a filename.
#
change_filename_extension() {
  local _original_full_filepath="$1"
  local _new_ext="$2"

  local _filename_portion _new_full_filepath _old_ext _path_portion

  _path_portion="$(dirname "$_original_full_filepath")"
  if [ "$_path_portion" != "." ]; then
    _filename_portion="${_original_full_filepath#$_path_portion}"
  else
    _filename_portion="${_original_full_filepath}"
    _path_portion=""
  fi

  if [ "${_filename_portion%.*}" != "$_filename_portion" ]; then
    # Replace existing extension
    _old_ext="${_filename_portion##*.}"
    _new_full_filepath="${_path_portion}${_filename_portion%.$_old_ext}.${_new_ext}"
  else
    # No existing extension so add one
    _new_full_filepath="${_path_portion}${_filename_portion}.${_new_ext}"
  fi

  echo "$_new_full_filepath"
}


#
# Display error as command option is not supported, and exit.
#
cli_option_not_handled() {
  error_message "This option does not apply in this situation."
}


#
# Display error as command option value is not valid, and exit.
#
cli_option_unknown_value() {
  error_message "Unknown $1!"
}


#
# Copy /etc/resolv.conf from host system to chroot.
#
copy_host_resolv_conf_to_chroot() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Copying system's /etc/resolv.conf into chroot filesystem"
	mkdir -p "$chroot_dir"/etc
	cp /etc/resolv.conf "$chroot_dir"/etc/
	EOF
}

#
# Copy local repository signing key to chroot.
#
copy_local_repo_key_to_chroot() {
  cat <<-EOF >> "$run_script"
	
	write_log "Copy local repo key to /etc/apk/keys/ directory inside chroot"
	cp "${local_repo_signature_file}" "\$chroot_dir"/etc/apk/keys/
	EOF
}


#
# Create MBR or GPT disk label.
#
create_disk_label() {
  local _label_type="$1"

  cat <<-EOF >> "$run_script"
	  write_debug_log "Creating ${_label_type} disk label" 2
	  parted --machine --script --align=optimal \$image_full_filename \\
	    mklabel ${_label_type} >> "\$logfile" 2>&1
	EOF
}


#
# Create a disk partition.
#
create_disk_partition() {
  local _part_number=$1
  local _part_start=$2
  local _part_end=$3
  local _size=$4
  local _part_desc=$5
  local _flags="${6:-}"
  local _fs_type=${7:-}

  local _flag

  cat <<-EOF >> "$run_script"
	  write_debug_log "Creating ${_size}MiB ${_part_desc} partition" 2
	  parted --machine --script --align=optimal \$image_full_filename \\
	    unit MiB mkpart primary ${_fs_type} ${_part_start} ${_part_end} >> "\$logfile" 2>&1
	EOF

  for _flag in $_flags; do
    cat <<-EOF >> "$run_script"
	  write_debug_log "Setting partition ${_flag} flag on" 2
	  parted --machine --script --align=optimal \$image_full_filename \\
	    set ${_part_number} ${_flag} on >> "\$logfile" 2>&1
	EOF
  done
}


#
# Create basic /etc/apk/repositories file inside chroot.
#
create_repositories_file_inside_chroot() {
  cat <<-EOF >> "$run_script"
	
	write_log "Creating /etc/apk/repositories file inside chroot"
	mkdir -p "\$chroot_dir"/etc/apk/keys
	{
	EOF

  if [ "$image_alpine_release" = "edge-special" ]; then
    cat <<-EOF >> "$run_script"
	  printf '%s/edge/main\n' "$alpine_mirror_site"
	  printf '%s/edge/community\n' "$alpine_mirror_site"
	  printf '%s/edge/testing\n' "$alpine_mirror_site"
	EOF

    if [ -n "$local_alpine_repository" ]; then
      cat <<-EOF >> "$run_script"
	  printf '%s/edge\n' "$local_alpine_repository"
	EOF
    fi
  else
    cat <<-EOF >> "$run_script"
	  printf '%s/%s/main\n' "$alpine_mirror_site" "$image_alpine_release"
	  printf '%s/%s/community\n' "$alpine_mirror_site" "$image_alpine_release"
	EOF

    case $image_alpine_release in
      edge )
        cat <<-EOF >> "$run_script"
	  printf '%s/%s/testing\n' "$alpine_mirror_site" "$image_alpine_release"
	EOF
        ;;
    esac

    if [ -n "$local_alpine_repository" ]; then
      cat <<-EOF >> "$run_script"
	  printf '%s/%s\n' "$local_alpine_repository" "$image_alpine_release"
	EOF
    fi
  fi

  cat <<-EOF >> "$run_script"
	} > "\$chroot_dir"/etc/apk/repositories
	EOF
}


#
# Determine the Linux distro that this script is being run on.
#
detect_host_os() {
  grep "^ID=" /etc/os-release | sed -e 's/^ID=//'
}


#
# Output one line per entry in list using specified line formatting.
#
echo_lines_from_comma_list() {
  local _output_formatting="$1"
  local _input_cl_list="$2"

  local _cl_list _cl_list_item

  _cl_list="$_input_cl_list"
  while true; do
    _cl_list_item="$(first_entry_in_comma_list "$_cl_list")"
    printf "$_output_formatting\n" "$_cl_list_item"
    if [ "${_cl_list%,*}" = "$_cl_list" ]; then
      # No more entries
      break
    else
      _cl_list="${_cl_list#$_cl_list_item,}"
    fi
  done
}


#
# Name a GPT disk partition.
#
label_gpt_disk_partition() {
  local _part_number=$1
  local _part_name="${2:-}"

  cat <<-EOF >> "$run_script"
	  write_debug_log "Labelling GPT partition ${_part_number} as '${_part_name}'" 2
	  parted --machine --script \$image_full_filename \\
	    name ${_part_number} "${_part_name}" >> "\$logfile" 2>&1
	EOF
}


#
# Output list of options, one per line.
#
options_wrap() {
  local _options_list="$1"

  local _current_option _option_name _option_value

  while [ ${#_options_list} -gt 0 ] && \
        [ "${_options_list#*--}" != "$_options_list" ]; do
    _options_list="${_options_list#*--}"
    _current_option="${_options_list%% --*}"

    # Extract the name of the option
    _option_name="${_current_option%% *}"
    if [ "$_option_name" != "$_current_option" ]; then
      # There is an option value also, extract it
      _option_value="${_current_option##$_option_name }"
      if [ "${_option_value%% *}" != "$_option_value" ]; then
        # option value contains multiple items so place quotes around it
        _option_value="\"$_option_value\""
      fi
    fi

    if [ -n "$_option_value" ]; then
      cat <<-EOF >> "$run_script"
	#   --${_option_name} ${_option_value}
	EOF
    else
      cat <<-EOF >> "$run_script"
	#   --${_option_name}
	EOF
    fi
    unset _option_value
  done
}


#
# Create the comment block at the start of the runscript.
#
create_runscript_header() {
  cat <<-EOF > "$run_script"
	#!/bin/sh -eu
	# shellcheck disable=SC2039
	
	#############################################################################
	# Generated on $(date +%c) by ${script_name}
	# version ${script_version} using the following options:
	#
	EOF

  options_wrap "$full_command_options"

  cat <<-'EOF' >> "$run_script"
	#
	#############################################################################
	
	if [ "$(id -u)" -ne 0 ]; then
	  printf '\nThis script must be run as the root user!\n\n'
	  exit 1
	fi
	
	EOF
}


#
# Download tarball of statically compiled apk tool.
#
download_static_apk() {
  if [ "$image_script_host_arch" = "all" ] || \
     [ "$image_script_host_arch" != "$image_arch" ]; then
    cat <<-'EOF' >> "$run_script"
	
	_host_arch="$(detect_host_arch)"
	EOF
  else
    cat <<-EOF >> "$run_script"
	
	_host_arch="${image_arch}"
	EOF
  fi

  cat <<-EOF >> "$run_script"
	write_log "Downloading statically built APK tool for \${_host_arch} arch"
	{
	  wget -q -O ${TMPDIR}/apk.static \\
	    ${apk_static_url}/"\${_host_arch}"/apk.static \\
	    2>> "\$logfile"
	  _rc=\$?
	  case \$_rc in
	    5 )
	      error_message "Error with wget HTTPS certificate validation!" ;;
	    1 | 3 | 4 | 7 | 8 )
	      error_message "A wget error (\$_rc) occurred during download!" ;;
	  esac
	  chmod +x ${TMPDIR}/apk.static
	
	  if ! echo "$apk_static_checksum ${TMPDIR}/apk.static" | sha256sum -c >/dev/null; then
	    error_message "The checksum of the downloaded APK tool does not match the expected checksum!"
	  fi
	}
	EOF
}


#
# Display an error message and exit the script.
#
error_message() {
  printf '\n%s\n\n' "$1"
  exit 2
}


#
# Returns first entry from a comma-separated string.
#
first_entry_in_comma_list() {
  local _comma_list="$1"

  first_entry_in_list "$_comma_list" ","
}


#
# Returns first entry from a string which uses the specified separator.
#
first_entry_in_list() {
  local _list="$1"
  local _separator="$2"

  echo "${_list%%$_separator*}"
}


#
# Returns first entry from a space-separated string.
#
first_entry_in_space_list() {
  local _space_list="$1"

  first_entry_in_list "$_space_list" " "
}


#
# Create an ESP FAT filesystem.
#
format_esp_fs() {
  local _uefi_info_type _uefi_mkfs_options

  case $image_esp_type in
    fat12 )
      _uefi_info_type="FAT12"
      _uefi_mkfs_options="-F12 -s 1 -S $image_os_device_sector_size"
      ;;
    fat16 )
      _uefi_info_type="FAT16"
      _uefi_mkfs_options="-F16 -s 1 -S $image_os_device_sector_size"
      ;;
    fat32 )
      _uefi_info_type="FAT32"
      _uefi_mkfs_options="-F32 -S $image_os_device_sector_size"
      ;;
  esac
  if [ -n "$debug_enabled" ]; then
    _uefi_mkfs_options="$_uefi_mkfs_options -v"
  fi

  cat <<-EOF >> "$run_script"
	  write_log \\
	    "Formatting ${_uefi_info_type} filesystem with ${image_os_device_sector_size}-byte sectors on ESP partition" 2
	  mkfs.fat ${_uefi_mkfs_options} -n "${CADI_ESP_FS_LABEL}" "\$uefi_part_device" \\
	    >> "\$logfile" 2>&1
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-EOF >> "$run_script"
	
	  # Debug
	  write_debug_log "FAT filesystem info:" 2
	  file -s "\$uefi_part_device" >> "\$logfile" 2>&1
	EOF
  fi
}


#
# Create an EXT4 filesystem.
#
format_ext4_fs() {
  local _ext4_device=$1
  local _ext4_fs_use="$2"
  local _ext4_label=$3
  local _formatting_where="$4"

  local _ext4_fs_options

  _ext4_fs_options="-L ${_ext4_label}"
  # Ensure EXT4 inode size is 256 bytes rather than 128
  # in order to avoid Year 2038 problems/warning.
  _ext4_fs_options="$_ext4_fs_options -I 256"

  case $image_bootloader in
    syslinux )
      # Syslinux requires Ext4 64bit flag be disabled
      # for whichever filesystem it boots from.
      case $_ext4_fs_use in
        boot )
          _ext4_fs_options="$_ext4_fs_options -O ^64bit" ;;
        root )
          if [ "$image_create_boot_partition" != "true" ] && \
             [ -z "$image_lvm_rootfs" ]; then
          _ext4_fs_options="$_ext4_fs_options -O ^64bit"
          fi
          ;;
      esac
      ;;
  esac

  case $image_encryption_type in
    both | fscrypt )
      _ext4_fs_options="$_ext4_fs_options -O encrypt"
      ;;
  esac

  if [ -z "$debug_enabled" ]; then
    _ext4_fs_options="$_ext4_fs_options -q"
  fi

  cat <<-EOF >> "$run_script"
	
	  write_log "Formatting Ext4 ${_ext4_fs_use} filesystem on ${_formatting_where}" 2
	  mkfs.ext4 ${_ext4_fs_options} "${_ext4_device}" >> "\$logfile" 2>&1
	
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-EOF >> "$run_script"
	  # Debug
	  write_debug_log "EXT4 filesystem info:" 2
	  tune2fs -l "$_ext4_device" >> "\$logfile" 2>&1
	
	EOF
  fi
}


#
# Indicate which kernel package to use based on cloud/physical/vm type,
# whether Edge kernel is specified, and the Alpine release.
#
get_kernel_type() {
  local _kernel_pkg_type

  if [ -n "$CADI_KERNEL_PACKAGE" ]; then
    # If config file defines kernel package then use that
    _kernel_pkg_type="$(echo "$CADI_KERNEL_PACKAGE" | sed -e 's/^linux\-//')"
  else
    case $image_class in
      cloud | virtual )
        case $image_alpine_release in
          v3.13 | v3.14 )
            _kernel_pkg_type="virt" ;;
          v3.15 )
            # This Alpine release has linux-virt
            # and linux-edge4virt packages.
            case $image_kernel_type in
              edge | edge-special )
                _kernel_pkg_type="edge4virt" ;;
              * )
                _kernel_pkg_type="virt" ;;
            esac
            ;;
          * )
            # These Alpine releases no longer have linux-edge4virt
            # package so use either linux-virt or linux-edge
            # (rather than linux-edge4virt).
            case $image_kernel_type in
              edge | edge-special )
                _kernel_pkg_type="edge" ;;
              * )
                _kernel_pkg_type="virt" ;;
            esac
            ;;
        esac
        ;;

      physical )
        case $image_physical_type in
          rpi2 | rpi3 )
            case $image_arch in
              aarch64 )
                _kernel_pkg_type="rpi" ;;
              armv7 )
                _kernel_pkg_type="rpi2" ;;
            esac
            ;;

          rpi4 )
            _kernel_pkg_type="rpi4" ;;

          * )
            case $image_kernel_type in
              edge | edge-special )
                _kernel_pkg_type="edge" ;;
              * )
                _kernel_pkg_type="lts" ;;
            esac
            ;;
        esac
        ;;
    esac
  fi

  echo "$_kernel_pkg_type"
}


#
# Returns the device name for specified storage.
#
get_storage_device_name() {
  local _device_type=$1

  local _device_name

  case $_device_type in
    nvme )
      _device_name="/dev/nvme0n1" ;;
    sd )
      _device_name="/dev/mmcblk0" ;;
    virtio_blk )
      _device_name="/dev/vda" ;;
    * )
      _device_name="/dev/sda" ;;
  esac

  echo "$_device_name"
}


#
# Returns the device name for specified storage partition.
#
get_storage_partition_name() {
  local _device_type=$1
  local _partition_number=$2

  local _partition_name

  _partition_name=$(get_storage_device_name "$_device_type")

  case $_device_type in
    nvme | sd )
      _partition_name="${_partition_name}p" ;;
  esac

  _partition_name="${_partition_name}${_partition_number}"

  echo "$_partition_name"
}


#
# Insert function add_fstab_entry into created script.
#
insert_chroot_function_add_fstab_entry() {
  cat <<-'EOF' >> "$run_script"
	
	add_fstab_entry() {
	  local _entry_type="\$1"
	  local _entry_value="\$2"
	  local _mount_point="\$3"
	  local _fs_type="\$4"
	  local _fs_options="\${5:-}"
	  local _entry_log="\${6:-}"
	
	  local _fstab_entry
	
	  if [ "\$_entry_type" = "BIND" ]; then
	    _fs_options="bind,\${_fs_options}"
	    local _fs_passno="0"
	  elif [ "\$_fs_type" = "swap" ]; then
	    _mount_point="none"
	    _fs_options="sw"
	    local _fs_passno="0"
	    _entry_log="Swap partition"
	  elif [ "\$_fs_type" = "tmpfs" ]; then
	    local _fs_passno="0"
	  elif [ "\$_mount_point" = "/" ]; then
	    local _fs_passno="1"
	  else
	    local _fs_passno="2"
	  fi
	
	  if [ "\$_entry_type" = "BIND" ] || [ "\$_entry_type" = "DEVICE" ]; then
	    _fstab_entry="\${_entry_value}"
	  else
	    _fstab_entry="\${_entry_type}=\${_entry_value}"
	  fi
	  _fstab_entry="\${_fstab_entry}\t\${_mount_point}\t\${_fs_type}\t\${_fs_options} 0 \${_fs_passno}"
	
	  write_log "Add \${_entry_log} entry" 2
	  # shellcheck disable=SC2059
	  printf "\${_fstab_entry}\n" >> /etc/fstab
	}
	EOF
}


#
# Insert function get_kernel_version into created script.
#
insert_chroot_function_get_kernel_version() {
  local _kernel_type

  _kernel_type="$(get_kernel_type)"

  cat <<-EOF >> "$run_script"
	
	get_kernel_version() {
	  apk info linux-${_kernel_type} | head -n 1 | sed -e "s/^linux-${_kernel_type}-//" \\
	    -e 's/-r/-/' -e 's/ .*//' -Ee "s/^(.*)\$/\\1-${_kernel_type}/"
	}
	EOF
}


#
# Insert function write_debug_log into created script.
#
insert_chroot_function_write_debug_log() {
  cat <<-'EOF' >> "$run_script"
	
	write_debug_log() {
	  local _log_entry="\$1"
	  local _indent=\${2:-0}
	
	  local _current_time
	
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	  _current_time=\$(printf "[%s]" "\$(date -u "+%Y-%m-%d %H:%M:%S")")
	  # shellcheck disable=SC1117
	  printf "\$_current_time chroot: %\${_indent}s\${_log_entry}\n" >> /chroot.log
	EOF
  else
    cat <<-'EOF' >> "$run_script"
	  # Debug not enabled so do nothing
	  true
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Insert function write_log into created script.
#
insert_chroot_function_write_log() {
cat <<-'EOF' >> "$run_script"
	
	write_log() {
	  local _log_entry="\$1"
	  local _indent=\${2:-0}
	
	  local _current_time
	
	  _current_time=\$(printf "[%s]" "\$(date -u "+%Y-%m-%d %H:%M:%S")")
	  # shellcheck disable=SC1117
	  printf "\$_current_time chroot: %\${_indent}s\${_log_entry}\n" >> /chroot.log
	  # shellcheck disable=SC1117
	  printf "chroot: %\${_indent}s\${_log_entry}\n"
	}
	EOF
}


#
# Insert function check_binfmt_packages into the run script.
#
insert_runscript_function_check_binfmt_packages() {
  local _alpine_arch_package _binfmt_file

  case $image_arch in
    aarch64 )
      _alpine_arch_package="qemu-aarch64"
      _binfmt_file="/proc/sys/fs/binfmt_misc/qemu-aarch64"
      ;;
    armv7 )
      _alpine_arch_package="qemu-arm"
      _binfmt_file="/proc/sys/fs/binfmt_misc/qemu-arm"
      ;;
    x86 )
      _alpine_arch_package="qemu-i386"
      _binfmt_file="/proc/sys/fs/binfmt_misc/qemu-i386"
      ;;
    x86_64 )
      _alpine_arch_package="qemu-x86_64"
      _binfmt_file="/proc/sys/fs/binfmt_misc/qemu-x86_64"
      ;;
  esac

  cat <<-EOF >> "$run_script"
	
	#
	# Check that the host OS has necessary packages installed for
	# running user-mode QEMU via binfmt and that it is configured.
	#
	check_binfmt_packages() {
	EOF

  case $image_script_host_os in
    alpine | all )
      cat <<-EOF >> "$run_script"
	  local _alpine_arch_package="$_alpine_arch_package"
	EOF
      ;;
  esac

  cat <<-EOF >> "$run_script"
	  local _arch="$image_arch"
	  local _binfmt_file="$_binfmt_file"
	
	  local _binfmt_arch_enabled _host_arch _host_os _required_packages
	
	  _host_arch=\$(detect_host_arch)
	
	  if [ "\$_host_arch" != "\$_arch" ]; then
	    _host_os=\$(detect_host_os)
	    case \$_host_os in
	EOF

  case $image_script_host_os in
    alpine | all )
      cat <<-'EOF' >> "$run_script"
	      alpine )
	EOF

      cat <<-'EOF' >> "$run_script"
	        _required_packages="qemu-openrc $_alpine_arch_package"
	        # shellcheck disable=SC2086
	        if ! apk info -e -q $_required_packages; then
	          printf '\nThe following Alpine packages need to be installed:\n\n'
	          printf '  %s\n\n' "$_required_packages"
	          exit 1
	        fi
	        ;;
	EOF
      ;;
  esac

  case $image_script_host_os in
    debian | ubuntu | all )
      case $image_script_host_os in
        debian )
          cat <<-'EOF' >> "$run_script"
	      debian )
	EOF
          ;;
        ubuntu )
          cat <<-'EOF' >> "$run_script"
	      ubuntu )
	EOF
          ;;
        all )
          cat <<-'EOF' >> "$run_script"
	
	      debian | ubuntu )
	EOF
          ;;
      esac

      cat <<-'EOF' >> "$run_script"
	        _required_packages="binfmt-support qemu-user-static"
	        # shellcheck disable=SC2086
	        if ! dpkg-query -W -f='${Status}\n' $_required_packages 1>/dev/null 2>&1; then
	          printf '\nThe following packages need to be installed:\n\n'
	          printf '  %s\n\n' "$_required_packages"
	          exit 1
	        fi
	        ;;
	EOF
      ;;
  esac

  if [ "$image_script_host_os" = "all" ]; then
    cat <<-'EOF' >> "$run_script"
	
	      * )
	        printf '\nUnsupported host OS!\n\n'
	        exit 1
	        ;;
	    esac
	EOF
  else
    cat <<-EOF >> "$run_script"
	
	      * )
	        case \$_host_os in
	          alpine | debian | ubuntu )
	            printf \\
	              '\nRe-run create-alpine-disk-image specifying '\''--script-host-os %s'\''!\n\n' \\
	              "\$_host_os"
	            ;;
	          * )
	            printf '\nUnsupported host OS!\n\n' ;;
	        esac
	        exit 1
	        ;;
	    esac
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	
	    # Is binfmt configured for this QEMU arch?
	    if [ -e "$_binfmt_file" ]; then
	      _binfmt_arch_enabled=$(head -1 ${_binfmt_file})
	      if [ "$_binfmt_arch_enabled" = "enabled" ]; then
	        return
	      else
	        printf '\nBinfmt is not enabled for %s\n\n' "$_arch"
	        exit 1
	      fi
	EOF

  if [ "$image_arch" = "x86" ]; then
    case $image_script_host_os in
      all )
        cat <<-'EOF' >> "$run_script"
	    elif [ "$_host_os" = "debian" ] || [ "$_host_os" = "ubuntu" ]; then
	EOF
        ;;
      debian | ubuntu )
        cat <<-'EOF' >> "$run_script"
	    else
	EOF
        ;;
    esac

    cat <<-'EOF' >> "$run_script"
	      # The Debian & Ubuntu binfmt-support package does not set up binfmt for x86
	      echo ':qemu-i386:M::\x7fELF\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03\x00:\xff\xff\xff\xff\xff\xfe\xfe\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-i386-static:' \
	        | tee /proc/sys/fs/binfmt_misc/register > /dev/null
	    fi
	EOF
  else
    cat <<-'EOF' >> "$run_script"
	    else
	      printf '\nBinfmt and QEMU are not configured for %s\n\n' "$_arch"
	      exit 1
	    fi
	EOF
  fi

    cat <<-'EOF' >> "$run_script"
	  fi
	}
	EOF
}


#
# Insert function check_for_required_packages into the run script.
#
insert_runscript_function_check_for_required_packages() {
  local _alpine_package_list _debian_package_list

  # Select:
  #    coreutils for: truncate
  _alpine_package_list="blkid busybox coreutils jq lsblk qemu-img tar wget"
  _debian_package_list="coreutils jq mount qemu-utils util-linux wget"

  if { [ "$image_class" = "physical" ] && \
       [ "$image_cloud_software" = "cloud-init" ]; } || \
     { [ "$image_boot_type" = "secure-uefi" ] || \
       [ "$image_boot_type" = "uefi" ]; }; then
    # FAT/VFAT filesystem is used for both cloud-init CIDATA filesystem
    # on physical machines and for UEFI ESP partition filesystem.
    _alpine_package_list="${_alpine_package_list} dosfstools"
  fi

  case $image_os_partitioning_type in
    unpartitioned )
      : ;;
    * )
      _alpine_package_list="${_alpine_package_list} parted"
      _debian_package_list="${_debian_package_list} parted"
      ;;
  esac

  case $image_fs_type in
    btrfs )
      _alpine_package_list="$_alpine_package_list btrfs-progs btrfs-progs-extra"
      _debian_package_list="$_debian_package_list btrfs-progs"
      ;;
    ext4 )
      # e2fsprogs for: mkfs.ext4
      _alpine_package_list="$_alpine_package_list e2fsprogs"
      _debian_package_list="$_debian_package_list e2fsprogs"
      ;;
    f2fs )
      _alpine_package_list="$_alpine_package_list f2fs-tools"
      _debian_package_list="$_debian_package_list f2fs-tools"
      ;;
    xfs )
      _alpine_package_list="$_alpine_package_list xfsprogs xfsprogs-extra"
      _debian_package_list="$_debian_package_list xfsprogs"
      ;;
  esac
  if [ -n "$image_encryption_type" ]; then
    case $image_encryption_type in
      both )
        _alpine_package_list="$_alpine_package_list cryptsetup fscrypt"
        _debian_package_list="$_debian_package_list cryptsetup-bin fscrypt"
        ;;
      fscrypt )
        _alpine_package_list="$_alpine_package_list fscrypt"
        _debian_package_list="$_debian_package_list fscrypt"
        ;;
      luks )
        _alpine_package_list="$_alpine_package_list cryptsetup"
        _debian_package_list="$_debian_package_list cryptsetup-bin"
        ;;
    esac
  fi
  if [ -n "$image_lvm_rootfs" ]; then
    _alpine_package_list="$_alpine_package_list lvm2"
    _debian_package_list="$_debian_package_list lvm2"
  fi
  if [ -n "$debug_enabled" ]; then
    _alpine_package_list="$_alpine_package_list shellcheck"
    _debian_package_list="$_debian_package_list shellcheck"
  fi

  cat <<-'EOF' >> "$run_script"
	
	#
	# Checks that the host OS has all necessary packages installed.
	#
	check_for_required_packages() {
	  local _required_packages
	EOF

  case $image_script_host_os in
    alpine | all )
      cat <<-'EOF' >> "$run_script"
	  local _host_os_major_version
	EOF
      ;;
  esac

  cat <<-'EOF' >> "$run_script"
	  local _host_os
	
	  _host_os=$(detect_host_os)
	  case $_host_os in
	EOF

  case $image_script_host_os in
    alpine | all )
      cat <<-EOF >> "$run_script"
	    alpine )
	      _host_os_major_version="\$(grep VERSION_ID /etc/os-release | sed -E -e 's/^VERSION_ID=([0-9]+\.[0-9]+).*/\1/g')"
	      _required_packages="${_alpine_package_list}"
	
	      case \$_host_os_major_version in
	        3.13 | 3.14 )
	          # Select:
	          #    util-linux for: losetup, mount, umount
	          #    (Busybox versions are not suitable)
	          _required_packages="\$_required_packages util-linux"
	          ;;
	        3.15 )
	          # Select:
	          #    util-linux-misc for: losetup, mount, umount
	          #    (Busybox versions are not suitable)
	          _required_packages="\$_required_packages util-linux-misc"
	          ;;
	        3.16 )
	          # Select:
	          #    losetup & util-linux-misc for: losetup, mount, umount
	          #    (Busybox versions are not suitable)
	          _required_packages="\$_required_packages losetup util-linux-misc"
	          ;;
	        * )
	          # Select:
	          #    losetup, mount, & umount for: losetup, mount, umount
	          #    (Busybox versions are not suitable)
	          _required_packages="\$_required_packages losetup mount umount"
	          ;;
	      esac
	      # shellcheck disable=SC2086
	      if ! apk info -e -q \$_required_packages; then
	        printf '\nThe following Alpine packages need to be installed:\n\n'
	        printf '  %s\n\n' "\$_required_packages"
	        exit 1
	      fi
	      ;;
	EOF
      ;;
  esac

  case $image_script_host_os in
    debian )
      cat <<-'EOF' >> "$run_script"
	    debian )
	EOF
      ;;
    ubuntu )
      cat <<-'EOF' >> "$run_script"
	    ubuntu )
	EOF
      ;;
    all )
      cat <<-'EOF' >> "$run_script"
	
	    debian | ubuntu )
	EOF
      ;;
  esac

  case $image_script_host_os in
    debian | ubuntu | all )
      cat <<-EOF >> "$run_script"
	      _required_packages="${_debian_package_list}"
	
	      # shellcheck disable=SC2086
	      if ! dpkg-query -W -f='\${Status}\n' \$_required_packages 1>/dev/null 2>&1; then
	        printf '\nThe following packages need to be installed:\n\n'
	        printf '  %s\n\n' "\$_required_packages"
	        exit 1
	      fi
	      # The apk.static package requires a CAs file to use for trusting HTTPS
	      # connections but it is hardcoded to look for /etc/apk/ca.pem, which is
	      # Alpine-specific. Create this directory on the host machine and copy
	      # the host's usual CA file there. This directory will be deleted when
	      # this script finishes.
	      if [ ! -d /etc/apk ]; then
	        mkdir -p /etc/apk
	        temp_ca_dir_created=true
	      else
	        temp_ca_dir_created=false
	      fi
	      if [ ! -f /etc/apk/ca.pem ]; then
	        cp /etc/ssl/certs/ca-certificates.crt /etc/apk/ca.pem
	        temp_ca_file_created=true
	      else
	        temp_ca_file_created=false
	      fi
	      ;;
	EOF
      ;;
  esac

  if [ "$image_script_host_os" = "all" ]; then
    cat <<-EOF >> "$run_script"
	
	    * )
	      printf '\nUnsupported host OS!\n\n'
	      exit 1
	      ;;
	  esac
	EOF
  else
    cat <<-EOF >> "$run_script"
	
	    * )
	      case \$_host_os in
	        alpine | debian | ubuntu )
	          printf \\
	            '\nRe-run create-alpine-disk-image specifying '\''--script-host-os %s'\''!\n\n' \\
	            "\$_host_os"
	          ;;
	        * )
	          printf '\nUnsupported host OS!\n\n' ;;
	      esac
	      exit 1
	      ;;
	  esac
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Insert function detect_host_arch into the run script.
#

insert_runscript_function_detect_host_arch() {
  cat <<-'EOF' >> "$run_script"
	
	#
	# Determine the host architecture that script is being run on.
	#
	detect_host_arch() {
	  uname -m
	}
	EOF
}


#
# Insert function detect_host_os into the run script.
#
insert_runscript_function_detect_host_os() {
  cat <<-'EOF' >> "$run_script"
	
	#
	# Determine the Linux distro that script is being run on.
	#
	detect_host_os() {
	  grep "^ID=" /etc/os-release | sed -e 's/^ID=//'
	}
	EOF
}


#
# Insert function error_cleanup into the run script.
#
insert_runscript_function_error_cleanup() {
  cat <<-'EOF' >> "$run_script"
	
	#
	# Unmount filesystems whenever an error occurs in the script.
	#
	# shellcheck disable=SC2317
	error_cleanup() {
	  write_log
	  write_log
	  write_log "AN ERROR OCCURRED, cleaning up before aborting!"
	  write_log
	  write_log
	
	  if [ -f "$chroot_dir"/chroot.log ]; then
	    cat "$chroot_dir"/chroot.log >> "$logfile"
	  fi
	
	  normal_cleanup "error"
	EOF

  case $image_bootloader in
    grub )
      case $image_encryption_type in
        both | luks )
          if { [ -z "$image_experimental" ] || \
               [ -z "$luks_remote_unlock_enabled" ]; } && \
             [ -z "$image_no_grub_luks_fde_encryption" ] && \
             [ "$image_create_boot_partition" = "false" ]; then
            cat <<-'EOF' >> "$run_script"
	
	  rm -f crypto_keyfile.bin
	EOF
          fi
          ;;
      esac
      ;;
  esac

  if [ -n "$use_ramdisk" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  rm "$image_full_filename"
	  sync -f "$ramdisk_dir"
	  unmount_ramdisk
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Insert function get_uuid_from_device into the run script.
#
insert_runscript_function_get_uuid_from_device() {
  cat <<-'EOF' >> "$run_script"
	
	#
	# Get the UUID of the filesystem in the specified device.
	#
	get_uuid_from_device() {
	  blkid -s UUID -o value "$1"
	}
	EOF
}


#
# Insert function normal_cleanup into the run script.
#
insert_runscript_function_normal_cleanup() {
  cat <<-'EOF' >> "$run_script"
	
	#
	# Unmount filesystems mounted inside chroot directory.
	#
	normal_cleanup() {
	  local _param="${1:-}"
	
	  # Clear exit trap function
	  trap EXIT
	
	  if [ -z "$_param" ]; then
	    write_log "Normal cleanup"
	  fi
	
	  unmount_chroot_fs "/tmp"
	  if [ -n "$working_dir" ]; then
	    rmdir "$working_dir"
	  fi
	  unmount_chroot_fs "/dev"
	  unmount_chroot_fs "/sys"
	  unmount_chroot_fs "/proc"
	EOF

  case $image_boot_type in
    secure-uefi | uefi )
      cat <<-'EOF' >> "$run_script"
	  unmount_chroot_fs "/boot/efi"
	EOF
      ;;
  esac

  if [ "$image_create_boot_partition" = "true" ] || \
     [ -n "$image_lvm_rootfs" ]; then
    cat <<-'EOF' >> "$run_script"
	  unmount_chroot_fs "/boot"
	EOF
  fi

  if [ "$image_class" = "physical" ] && \
     [ "$image_cloud_software" = "cloud-init" ]; then
    cat <<-'EOF' >> "$run_script"
	  unmount_chroot_fs "/cidata"
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	  unmount_chroot_fs "/"
	EOF

  if [ -n "$image_lvm_rootfs" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  vgchange -an >> "$logfile"
	EOF
  fi

  if [ -n "$image_encryption_type" ] && \
     { [ "$image_encryption_type" = "both" ] || \
       [ "$image_encryption_type" = "luks" ]; }; then
    cat <<-EOF >> "$run_script"
	
	  cryptsetup close ${CADI_LUKS_DEVICE_NAME} >> "\$logfile"
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	
	  if [ -n "$loop_device" ]; then
	    write_log "Freeing up loop device '$loop_device'" 2
	    losetup -d "$loop_device" >> "$logfile"
	    _rc=$?
	    if [ $_rc -ne 0 ]; then
	      printf '\nThere was a problem freeing the loop device '\''%s'\''!\n\n' \
	        "$loop_device"
	      exit 1
	    fi
	  fi
	}
	EOF
}


#
# Insert function unmount_chroot_fs into the run script.
#
insert_runscript_function_unmount_chroot_fs() {
  cat <<-'EOF' >> "$run_script"
	
	#
	# Unmount a filesystem inside chroot.
	#
	unmount_chroot_fs() {
	  local _mountpoint="$1"
	  local _where_from="${2:-inside chroot}"
	
	  local _full_path _pseudo_path
	
	  if [ "$_mountpoint" = "/" ]; then
	    _full_path="$chroot_dir"
	    _pseudo_path="root filesystem"
	  else
	    _full_path="${chroot_dir}${_mountpoint}"
	    _pseudo_path="$_mountpoint"
	  fi
	
	  if mount | grep -q "$_full_path" ; then
	    write_log "Unmounting ${_pseudo_path} ${_where_from}" 2
	    umount -l -f "$_full_path" >> "$logfile"
	  fi
	}
	EOF
}


#
# Insert function unmount_ramdisk into the run script.
#
insert_runscript_function_unmount_ramdisk() {
  cat <<-'EOF' >> "$run_script"
	
	#
	# Unmount ramdisk.
	#
	unmount_ramdisk() {
	  local _rc
	
	  # Give any previous operations using the ramdisk time to complete
	  sleep 10
	
	  if mount | grep -q "$ramdisk_dir" ; then
	    _rc=1
	    while [ $_rc -ne 0 ]; do
	      write_log "Unmounting ramdisk"
	      umount "$ramdisk_dir" >> "$logfile"
	      _rc=$?
	      sleep 5
	    done
	    sleep 5
	
	    write_log "Deleting ramdisk directory"
	    rmdir "$ramdisk_dir" >> "$logfile"
	  fi
	}
	EOF
}


#
# Insert function write_debug_log into the run script.
#
insert_runscript_function_write_debug_log() {
  cat <<-'EOF' >> "$run_script"
	
	#
	# Write debug messages only to the log file.
	#
	write_debug_log() {
	  local _log_entry="$1"
	  local _indent="${2:-0}"
	
	  local _current_time
	
	EOF

  if [ -n "$debug_enabled" ]; then
	  cat <<-'EOF' >> "$run_script"
	  _current_time=$(printf "[%s]" "$(date -u "+%Y-%m-%d %H:%M:%S")")
	  # shellcheck disable=SC1117
	  printf "${_current_time} %${_indent}s${_log_entry}\n" >> "$logfile"
	EOF
  else
    cat <<-'EOF' >> "$run_script"
	  # Debug not enabled so do nothing
	  true
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Insert function write_log into the run script.
#
insert_runscript_function_write_log() {
  cat <<-'EOF' >> "$run_script"
	
	#
	# Write log messages to both logfile (with timestamp) and stdout.
	#
	write_log() {
	  local _log_entry="${1:-}"
	  local _indent="${2:-0}"
	
	  local _current_time
	
	  _current_time=$(printf "[%s]" "$(date -u "+%Y-%m-%d %H:%M:%S")")
	  # shellcheck disable=SC1117
	  printf "${_current_time} %${_indent}s${_log_entry}\n" >> "$logfile"
	  # shellcheck disable=SC1117
	  printf "%${_indent}s$_log_entry\n"
	}
	EOF
}


#
# Insert required functions into the run script.
#
insert_runscript_functions() {
  cat <<-'EOF' >> "$run_script"
	
	#############################################################################
	##   Functions
	#############################################################################
	EOF

  insert_runscript_function_check_for_required_packages

  if [ "$image_script_host_arch" = "all" ] || \
     [ "$image_script_host_arch" != "$image_arch" ]; then
    insert_runscript_function_check_binfmt_packages
  fi
  insert_runscript_function_detect_host_arch
  insert_runscript_function_detect_host_os
  insert_runscript_function_error_cleanup
  insert_runscript_function_get_uuid_from_device
  insert_runscript_function_normal_cleanup
  insert_runscript_function_unmount_chroot_fs
  if [ -n "$use_ramdisk" ]; then
    insert_runscript_function_unmount_ramdisk
  fi
  insert_runscript_function_write_debug_log
  insert_runscript_function_write_log
}


#
# Adds an entry to the specified /etc/mkinitfs/features.d/*.modules file.
#
initramfs_entry_add() {
  local _modules_entry="$1"

  cat <<EOF >> "$run_script"
	$_modules_entry
EOF
}


#
# Complete adding entries to the specified
# /etc/mkinitfs/features.d/*.modules file.
#
initramfs_entry_finish() {
  cat <<EOF >> "$run_script"
	_SCRIPT_
EOF
}


#
# Prep adding entries to the specified
# /etc/mkinitfs/features.d/*.modules file.
#
initramfs_entry_initialise() {
  local _modules_file=$1
  local _append=${2:-no}

  local _output='>'

  if [ "$_append" != "no" ]; then
    _output='>>'
  fi

  cat <<EOF >> "$run_script"
    cat <<-_SCRIPT_ $_output /etc/mkinitfs/features.d/${_modules_file}.modules
EOF
}


#
# Install additional packages.
#
install_additional_packages() {
  local _machine_class_software_pkgs

  cat <<-EOF >> "$run_script"
	
	add_packages="$(define_additional_packages)"
	EOF

  cat <<-'EOF' >> "$run_script"
	write_log "Install additional packages: \$add_packages"
	{
	  # shellcheck disable=SC2086
	  apk add \$add_packages >> /chroot.log 2>&1
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  write_debug_log "Disk space usage after additional packages added:"
	  busybox df -k >> /chroot.log
	  write_debug_log "Additional installed packages list:"
	  apk info -v | sort >> /chroot.log
	EOF
  fi

  cat <<-EOF >> "$run_script"
	}
	
	add_os_config_software_packages="$(define_os_config_software_packages)"
	EOF

  cat <<-'EOF' >> "$run_script"
	write_log \
	  "Install OS configuration software packages: \$add_os_config_software_packages"
	{
	  # shellcheck disable=SC2086
	  apk add \$add_os_config_software_packages >> /chroot.log 2>&1
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  write_debug_log \
	    "Disk space usage after OS configuration software packages added:"
	  busybox df -k >> /chroot.log
	  write_debug_log \
	    "Packages list after OS configuration software packages installed:"
	  apk info -v | sort >> /chroot.log
	EOF
  fi

  cat <<-EOF >> "$run_script"
	}
	EOF

  _machine_class_software_pkgs="$(define_machine_specific_packages)"

  if [ -n "$packages_additional" ]; then
    # Machine-related packages, taking into account whether cloud-init or
    # tiny-cloud is in use, and also taking into account Cloud/Physical/Virtual.
    _machine_class_software_pkgs="$_machine_class_software_pkgs $packages_additional"
  fi

  if [ -z "$image_barebones" ]; then
    if [ -n "$packages_optional" ]; then
      # ????????
      _machine_class_software_pkgs="$_machine_class_software_pkgs $packages_optional"
    fi
    if [ -n "$packages_extra" ]; then
      # ????????
      _machine_class_software_pkgs="$_machine_class_software_pkgs $packages_extra"
    fi
  fi

  if [ -n "$_machine_class_software_pkgs" ]; then
    cat <<-EOF >> "$run_script"
	
	machine_specific_packages="$_machine_class_software_pkgs"
	EOF

    cat <<-'EOF' >> "$run_script"
	write_log \
	  "Install additional machine specific packages: \$machine_specific_packages"
	{
	  # shellcheck disable=SC2086
	  apk add \$machine_specific_packages >> /chroot.log 2>&1
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  write_debug_log "Disk space usage after machine-specific packages added:"
	  busybox df -k >> /chroot.log
	  write_debug_log "Packages list after machine-specific packages installed:"
	  apk info -v | sort >> /chroot.log
	EOF
    fi

    cat <<-'EOF' >> "$run_script"
	}
	EOF
  fi
}


#
# Install the contents of a user-specified directory into image.
#
install_extra_files() {
  cat <<-EOF >> "$run_script"
	
	extra_contents="${extra_files_directory}"
	EOF

  cat <<-'EOF' >> "$run_script"
	write_log "Installing contents of specified directory '$extra_contents' into image"
	{
	  if [ -d "$extra_contents" ]; then
	    cp -vpr "$extra_contents"/* $chroot_dir/ >> $logfile 2>&1
	  else
	    write_log "NOTE: directory $extra_contents is missing, unable to copy files from there!"
	  fi
	}
	EOF
}


#
# Install extra, user specified, packages.
#
install_extra_packages() {
  cat <<-EOF >> "$run_script"
	
	extra_packages="${extra_packages_list}"
	EOF

  cat <<-'EOF' >> "$run_script"
	write_log "Installing extra packages: \$extra_packages"
	{
	  apk add \$extra_packages >> /chroot.log 2>&1
	}
	EOF
}


#
# Indicate if a string is present in a comma-separated string.
#
is_in_comma_list() {
  local _comma_list="$1"
  local _cl_check_string="$2"

  if is_in_list "$_comma_list" "$_cl_check_string" ","; then
    return 0
  else
    return 1
  fi
}


#
# Indicate if a string is present in a string with the specified separator.
#
is_in_list() {
  local _list="$1"
  local _check_string="$2"
  local _list_separator="$3"

  if [ "$_list" = "$_check_string" ]; then
    # Present as list only has that single entry
    return 0
  elif [ "${_list#*"$_list_separator""$_check_string"}" != "$_list" ] || \
     [ "${_list#*"$_check_string""$_list_separator"}" != "$_list" ]; then
    # Present
    return 0
  else
    # Not present
    return 1
  fi
}


#
# Indicate if a string is present in a space-separated string.
#
is_in_space_list() {
  local _space_list="$1"
  local _sl_check_string="$2"

  if is_in_list "$_space_list" "$_sl_check_string" " "; then
    return 0
  else
    return 1
  fi
}


#
# Indicate if there is only a single entry present in a comma-separated string.
#
is_single_entry_in_comma_list() {
  local _comma_list="$1"

  if [ "${_comma_list%%,*}" = "$_comma_list" ]; then
    return 0
  else
    return 1
  fi
}


#
# Mount the ramdisk.
#
mount_ramdisk() {
  cat <<-EOF >> "$run_script"
	
	write_log "Setting up ramdisk"
	mkdir -p \$ramdisk_dir
	mount -t tmpfs -o size=${CADI_RAMDISK_SIZE} tmpfs \$ramdisk_dir >> \$logfile
	EOF
}


#
# Mount special filesystems from host inside chroot.
#
mount_host_special_fs_in_chroot() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Mounting tmp, /proc, /sys, and /dev special filesystems in chroot"
	{
	  working_dir=$(mktemp -d -p /tmp create-alpine.XXXXXX)
	  _rc=$?
	  if [ $_rc -ne 0 ]; then
	    printf '\nThere was a problem creating a temporary working directory!\n\n'
	    exit 1
	  fi
	  mount -v -t none -o rbind "$working_dir" $chroot_dir/tmp
	  mount -v --make-rprivate $chroot_dir/tmp
	  mount -v -t proc none $chroot_dir/proc
	  mount -v -t none -o rbind /sys $chroot_dir/sys
	  mount -v --make-rprivate $chroot_dir/sys
	  mount -v -t none -o rbind /dev $chroot_dir/dev
	  mount -v --make-rprivate $chroot_dir/dev
	} >> $logfile 2>&1
	EOF
}


#
# Display the help for an individual option, wrapped to 70 chars width.
#
option_help() {
  local _option_format="$1"
  local _option_description="$2"

  local _remaining_desc _temp_chunk _this_line
  local _desc_len=76

  echo "  $_option_format"
  echo
  if [ "${#_option_description}" -le 70 ]; then
    echo "    $_option_description"
  else
    # Chop the description into appropriate line portions based on spaces
    _remaining_desc="$_option_description"
    while [ ${#_remaining_desc} -gt 0 ]; do
      if [ ${#_remaining_desc} -le $_desc_len ]; then
        _this_line=$_remaining_desc
        _remaining_desc=''
      else
        _temp_chunk="$(printf '%s' "$_remaining_desc" | cut -c -$_desc_len)"
        _this_line=${_temp_chunk% *}
        _remaining_desc=${_remaining_desc##$_this_line}
        # Remove any leading space
        _remaining_desc=${_remaining_desc# }
      fi
      echo "    $_this_line"
    done
  fi
  echo
}


#
# Outputs a blank line.
#
output_eof_block_blank_line() {
  output_eof_block_text ""
}


#
# Outputs a tab-indented blank line.
#
output_eof_block_tab_blank_line() {
  output_eof_block_text "\t"
}


#
# Outputs text.
#
output_eof_block_text(){
  local _eof_block_line="$1"

  cat <<EOF >> "$run_script"
$(printf "$_eof_block_line\n")
EOF
}


#
# Outputs tab-indented empty line.
#
output_script_block_blank_line() {
  output_script_block_text ""
}


#
# Outputs tab-indented end of script block marker.
#
output_script_block_end_marker() {
  output_script_block_text "_SCRIPT_"
}


#
# Outputs tab-indented text.
#
output_script_block_text(){
  local _script_block_line="$1"

  cat <<-EOF >> "$run_script"
$(printf '\t%s\n' "$_script_block_line")
EOF
}


#
# Populate the chroot directory with a basic Alpine system.
#
setup_alpine_base() {
  if [ "$image_script_host_os" != "alpine" ]; then
    download_static_apk
  fi
  copy_host_resolv_conf_to_chroot
  create_repositories_file_inside_chroot
  if [ -n "$local_repo_signature_file" ]; then
    copy_local_repo_key_to_chroot
  fi
  install_alpine_base
}


#
# In the script, setup the loop device for the disk image.
#
setup_loop_device() {
  cat <<-EOF >> "$run_script"
	
	write_log "Setting up loop device for disk image"
	{
	  write_log "Ensuring that loop driver is loaded (if necessary)" 2
	  if [ ! -c /dev/loop-control ]; then
	    loop_module_filename=\$(modinfo -F filename loop 2>/dev/null)
	    if [ "\$loop_module_filename" != "" ] && \\
	       [ "\$loop_module_filename" != "(builtin)" ]; then
	      modprobe loop 2>> \$logfile
	    else
	      printf '\nThere is a problem with loop devices!\n\n'
	      exit 1
	    fi
	  fi
	  
	  write_log "Setting up loop device with ${image_os_device_sector_size}-byte sector size for disk image" 2
	  loop_device=\$(losetup -P --show -b $image_os_device_sector_size -f \$image_full_filename 2>> \$logfile)
	  _rc=\$?
	  if [ \$_rc -ne 0 ]; then
	    if [ -n "\$loop_device" ]; then
	      unset loop_device
	      printf '\nThere was a problem creating the loop device!\n\n'
	    else
	      printf \\
	        '\nThere was a problem creating the loop device '\''%s'\''!\n\n' \\
	        "\$loop_device"
	    fi
	    exit 1
	  fi
	  if [ -z "\$loop_device" ]; then
	    printf '\nThere was a problem creating the loop device. Aborting!\n\n'
	    exit 1
	  fi
	}
	EOF
}


#
# Upgrade Alpine packages.
#
update_upgrade_packages() {
  cat <<-'EOF' >> "$run_script"
	
	write_log "Updating packages info"
	{
	  write_log "Updating packages list" 2
	  apk update >> /chroot.log
	
	  write_log "Upgrading base packages if necessary" 2
	  apk -a upgrade >> /chroot.log
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  write_debug_log "Base packages list:" 2
	  apk info -v | sort | tee /base-packages.list >> /chroot.log
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}
