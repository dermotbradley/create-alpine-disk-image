#!/bin/sh
# shellcheck disable=SC2039

#############################################################################
##
##  mkinitfs-functions
##
##  Copyright 2021-2023 Dermot Bradley <dermot_bradley@yahoo.com>
##
##  Licensed via GPL version 2.0
##
#############################################################################


#
# Configure mkinitfs so that only the modules necessary for the relevant
# image type are placed in the initramfs file.
#
configure_mkinitfs() {
  local _optimise

  cat <<-'EOF' >> "$run_script"
	
	write_log "Configuring mkinitfs"
	{
	EOF

  if [ -z "$image_disable_optimisation" ]; then
    configure_mkinitfs_conf "optimise-"
  else
    configure_mkinitfs_conf
  fi

  configure_mkinitfs_feature_base
  if [ -n "$image_bootchart" ]; then
    configure_mkinitfs_feature_bootchart
  fi
  configure_mkinitfs_feature_keymap
  if [ "$image_os_device_type" = "usb" ] || \
     { [ -n "$image_disable_optimisation" ] && \
       { [ "$image_keyboard_type" = "usb" ] || \
         [ "$image_keyboard_type" = "generic" ]; }; }; then
    # Either using USB for boot or else USB keyboard support with
    # non-optimised initramfs USB keyboard support (where this is
    # defined in usb.modules).
    configure_mkinitfs_feature_usb
  fi

  case $image_fs_type in
    btrfs )
      configure_mkinitfs_feature_btrfs ;;
    ext4 )
      configure_mkinitfs_feature_ext4 ;;
    f2fs )
      configure_mkinitfs_feature_f2fs ;;
    xfs )
      configure_mkinitfs_feature_xfs ;;
  esac

  if [ -n "$image_lvm_rootfs" ]; then
    configure_mkinitfs_feature_lvm
  fi

  case $image_encryption_type in
    both | luks )
      configure_mkinitfs_feature_cryptsetup ;;
  esac

  configure_mkinitfs_image_type_feature

  cat <<-'EOF' >> "$run_script"
	
	  write_log "Regenerating initramfs" 2
	  mkinitfs "\$_kernel_version" >> /chroot.log 2>&1
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-EOF >> "$run_script"
	
	  # Debug
	  write_debug_log "Disk space usage after initramfs regenerated:" 2
	  df -k >> /chroot.log
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	}
	EOF
}


#
# Configure /etc/mkinitfs/mkinitfs.conf
#
configure_mkinitfs_conf() {
  local _optimise=${1:-}

  local _features_list _cloud_features_list _virt_features_list

  cat <<-'EOF' >> "$run_script"
	  write_log "Setting up mkinitfs.conf" 2
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  cp /etc/mkinitfs/mkinitfs.conf /etc/mkinitfs/mkinitfs.conf-orig
	EOF
  fi

  _features_list="${_optimise:-}base keymap"

  if [ "$image_os_device_type" = "usb" ] || \
     { [ -n "$image_disable_optimisation" ] && \
       { [ "$image_keyboard_type" = "usb" ] || \
         [ "$image_keyboard_type" = "generic" ]; }; }; then
    # Either using USB for boot or else USB keyboard support with
    # non-optimised initramfs USB keyboard support (where this is
    # defined in usb.modules).
    _features_list="$_features_list ${_optimise:-}usb"
  fi

  # Add feature for relevant filesystem type
  case $image_fs_type in
    btrfs | ext4 | f2fs | xfs )
      _features_list="$_features_list ${_optimise:-}${image_fs_type}" ;;
    * )
      _features_list="$_features_list ${image_fs_type}" ;;
  esac

  if [ -n "$image_bootchart" ]; then
    _features_list="$_features_list ${_optimise:-}bootchart"
  fi

  if [ -n "$image_lvm_rootfs" ]; then
    _features_list="$_features_list ${_optimise:-}lvm"
  fi

  case $image_encryption_type in
    both | luks )
      case $image_bootloader in 
        grub )
          if { [ -z "$image_experimental" ] || \
               [ -z "$luks_remote_unlock_enabled" ]; } && \
             [ -z "$image_no_grub_luks_fde_encryption" ] && \
             [ "$image_create_boot_partition" != "true" ]; then
            # Cryptkey is used for unlock LUKS rootfs without 2nd
            # password prompt. It applies only when:
            #  - disk image is LUKS encrypted, AND
            #  - bootloader is Grub, AND
            #  - remote unlock is not enabled (as otherwise /boot
            #    is not encrypted), AND
            #  - Grub LUKS encryption support is not disabled AND
            #  - /boot is not a separate partition.
            _features_list="$_features_list cryptkey"
          fi
          ;;
      esac

      # cryptsetup is required in all rootfs encryption situations
      _features_list="$_features_list ${_optimise:-}cryptsetup"
      if [ -n "$image_experimental" ] && \
         [ -n "$luks_remote_unlock_enabled" ]; then
        # enable SSH remote unlock functionality and also dhcp which it uses
        _features_list="$_features_list ${_optimise:-}dhcp ${_optimise:-}luks_remote_unlock"
      fi
      ;;
  esac

  case $image_class in
    cloud )
      _subclass_type="$image_cloud_type"
      ;;
    physical )
      _subclass_type="$image_physical_type"
      ;;
    virtual )
      _subclass_type="$image_vm_type"
      ;;
  esac
  _features_list="$_features_list $image_class-$_subclass_type"

  if [ -n "$debug_enabled" ]; then
    cat <<-EOF >> "$run_script"
	  write_debug_log \\
	    "mkinitfs features list is: ${_features_list}" 2
	EOF
  fi

  cat <<-EOF >> "$run_script"
	
	  sed -i -e \\
	    "s|^features=\".*\"|features=\"${_features_list}\"|" \\
	    /etc/mkinitfs/mkinitfs.conf
	EOF

  if [ -n "$image_initramfs_compress" ]; then
    cat <<-EOF >> "$run_script"
	
	  write_log "Setting initramfs file compression to ${image_initramfs_compress}" 2
	  echo "initfscomp=${image_initramfs_compress}" >> /etc/mkinitfs/mkinitfs.conf
	EOF
  fi

  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Debug
	  diff /etc/mkinitfs/mkinitfs.conf-orig /etc/mkinitfs/mkinitfs.conf \
	    >> /chroot.log || true
	  rm /etc/mkinitfs/mkinitfs.conf-orig
	EOF
  fi
}


#
# Create/modify base mkinitfs feature files.
#
configure_mkinitfs_feature_base() {
  cat <<-'EOF' >> "$run_script"
	
	  # Base
	  {
	EOF

  if [ -z "$image_disable_optimisation" ]; then
    # optimise-base.files

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-base.files" 2
	    {
	      echo "/bin/busybox"
	      echo "/bin/sh"
	      echo "/etc/mdev.conf"
	      echo "/etc/modprobe.d/aliases.conf"
	      echo "/etc/modprobe.d/i386.conf"
	      echo "/etc/modprobe.d/kms.conf"
	      echo "/lib/mdev"
	EOF

    case $image_alpine_release in
      v3.13 | v3.14 | v3.15 | v3.16 )
        # Use kmod/modprobe from kmod package
        cat <<-'EOF' >> "$run_script"
	      echo "/sbin/modprobe"
	EOF
        ;;
      * )
        # Rely on Busybox's modprobe
        : ;;
    esac

    cat <<-'EOF' >> "$run_script"
	      echo "/sbin/nlplug-findfs"
	    } > /etc/mkinitfs/features.d/optimise-base.files
	
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	    # Debug
	    write_debug_log "optimise-base.files contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-base.files >> /chroot.log
	
	EOF
    fi

    # optimise-base.modules

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-base.modules" 2
	EOF

    initramfs_entry_initialise "optimise-base"
    if [ -n "$image_hwrng" ] && [ "$image_class" = "physical" ]; then
      initramfs_entry_add "kernel/drivers/char/hw_random/rng-core.ko*"
    fi

    case $image_console_device_type in
      normal | normal_and_serial | generic )
        case $image_keyboard_type in
          usb | generic )
            if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_KEYBOARD_TYPES" \
                                "usb"; then
              # Need to add USB HID-related drivers to mkinitfs so that USB
              # keyboard can work in initramfs (i.e. for typing in Rescue
              # Mode or entering decryption passphrase for LUKS encryption)
              initramfs_entry_add "# USB keyboard-related modules"
              initramfs_entry_add "kernel/drivers/hid/hid-generic.ko*"
              initramfs_entry_add "kernel/drivers/hid/usbhid/usbhid.ko*"
              initramfs_entry_add "kernel/drivers/usb/host/ehci-pci.ko*"
              case $image_class in
                physical )
                  # Extra vendor keyboards
                  initramfs_entry_add "kernel/drivers/hid/hid-cherry.ko*"
                  initramfs_entry_add "kernel/drivers/hid/hid-apple.ko*"
                  initramfs_entry_add "kernel/drivers/hid/hid-kensington.ko*"
                  initramfs_entry_add "kernel/drivers/hid/hid-lenovo.ko*"
                  initramfs_entry_add "kernel/drivers/hid/hid-logitech.ko*"
                  initramfs_entry_add "kernel/drivers/hid/hid-microsoft.ko*"
                  ;;
              esac
              case $image_arch in
                aarch64 | armv7 )
                  # Include OHCI module for Arm
                  initramfs_entry_add "kernel/drivers/usb/host/ohci-pci.ko*" ;;
                x86 | x86_64 )
                  # Include OHCI module by default, or where CPU vendor is
                  # specified and is not Intel
                  if [ -z "$image_cpu_vendor" ] || \
                     [ "$image_cpu_vendor" != "intel" ]; then
                    initramfs_entry_add "kernel/drivers/usb/host/ohci-pci.ko*"
                  fi
                  ;;
              esac
              case $image_arch in
                x86 | x86_64 )
                  # Include UHCI module by default, or where CPU vendor is
                  # specified and is Intel
                  if [ -z "$image_cpu_vendor" ] || \
                     [ "$image_cpu_vendor" = "intel" ]; then
                    initramfs_entry_add "kernel/drivers/usb/host/uhci-hcd.ko*"
                  fi
                  ;;
              esac
              initramfs_entry_add "kernel/drivers/usb/host/xhci-pci.ko*"
            fi
            ;;
        esac

        case $image_keyboard_type in
          hyperv | generic )
            if [ "$image_class_subtype" = "azure" ] || \
               [ "$image_class_subtype" = "hyperv" ]; then
              # Need to add Hyper-V keyboard driver to mkinitfs so that
              # keyboard can work in initramfs (i.e. for typing in Rescue
              # Mode or entering decryption passphrase for LUKS encryption)
              initramfs_entry_add "# Hyper-V keyboard-related module"
              initramfs_entry_add \
                "kernel/drivers/input/serio/hyperv-keyboard.ko*"
            fi
            ;;
        esac
        ;;
    esac

    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "optimise-base.modules contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-base.modules >> /chroot.log
	EOF
    fi

  else
    # base.files

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	    # Debug
	    write_debug_log "base.files contents:" 2
	    cat /etc/mkinitfs/features.d/base.files
	
	EOF
    fi

    # base.modules

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/base.modules" 2
	EOF

    initramfs_entry_initialise "base" "append"
    if [ -n "$image_hwrng" ] && [ "$image_class" = "physical" ]; then
      initramfs_entry_add "kernel/drivers/char/hw_random/*.ko*"
    fi
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "base.modules contents:" 2
	    cat /etc/mkinitfs/features.d/base.modules >> /chroot.log
	EOF
    fi

  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify bootchart mkinitfs feature files.
#
configure_mkinitfs_feature_bootchart() {
  cat <<-'EOF' >> "$run_script"
	
	  # Bootchart
	  {
	EOF

  if [ -z "$image_disable_optimisation" ]; then
    # optimise-bootchart.files

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-bootchart.files" 2
	    {
	      echo "/sbin/bootchartd"
	      echo "/usr/sbin/accton"
	    } > /etc/mkinitfs/features.d/optimise-bootchart.files
	
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	    # Debug
	    write_debug_log "optimise-bootchart.files contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-bootchart.files >> /chroot.log
	
	EOF
    fi
  else
    # bootchart.files

    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "bootchart.files contents:" 2
	    cat /etc/mkinitfs/features.d/bootchart.files >> /chroot.log
	EOF
    fi
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify btrfs mkinitfs feature files.
#
configure_mkinitfs_feature_btrfs() {
  cat <<-'EOF' >> "$run_script"
	
	  # Btrfs
	  {
	EOF

  if [ -z "$image_disable_optimisation" ]; then
    # optimise-btrfs.files

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-btrfs.files" 2
	    {
	      echo "/sbin/btrfs"
	    } > /etc/mkinitfs/features.d/optimise-btrfs.files
	
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	    # Debug
	    write_debug_log "optimise-btrfs.files contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-btrfs.files >> /chroot.log
	
	EOF
    fi

    # optimise-btrfs.modules

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-btrfs.modules" 2
	EOF

    initramfs_entry_initialise "optimise-btrfs"
    case $image_arch in
      x86 | x86_64 )
        if [ -z "$image_cpu_vendor" ] || \
           [ "$image_cpu_vendor" = "intel" ]; then
          initramfs_entry_add "kernel/arch/*/crypto/crc32c-intel.ko*"
        fi
        ;;
    esac
    initramfs_entry_add "kernel/crypto/xxhash_generic.ko*"
    initramfs_entry_add "kernel/fs/btrfs"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "optimise-btrfs.modules contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-btrfs.modules >> /chroot.log
	EOF
    fi

  else
    # btrfs.modules

    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "btrfs.modules contents:" 2
	    cat /etc/mkinitfs/features.d/btrfs.modules >> /chroot.log
	EOF

    fi

  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify cryptsetup mkinitfs feature files.
#
configure_mkinitfs_feature_cryptsetup() {
  cat <<-'EOF' >> "$run_script"
	
	  # Cryptsetup
	  {
	EOF

  if [ -z "$image_disable_optimisation" ]; then
    # optimise-cryptsetup.files

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-cryptsetup.files" 2
	    {
	      echo "/sbin/cryptsetup"
	    } >> /etc/mkinitfs/features.d/optimise-cryptsetup.files
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "optimise-cryptsetup.files contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-cryptsetup.files >> /chroot.log
	EOF
    fi

    # optimise-cryptsetup.modules

    cat <<-'EOF' >> "$run_script"
	
	    write_log "Setting up features.d/optimise-cryptsetup.modules" 2
	EOF

    initramfs_entry_initialise "optimise-cryptsetup"
    case $image_arch in
      aarch64 )
        case $image_luks_cipher in
          adiantum )
            initramfs_entry_add "kernel/arch/arm64/crypto/chacha-neon.ko*"
            initramfs_entry_add "kernel/arch/arm64/crypto/nhpoly1305-neon.ko*"
            initramfs_entry_add "kernel/arch/arm64/crypto/poly1305-neon.ko*"
            ;;
          * )
            initramfs_entry_add "kernel/arch/arm64/crypto/aes-arm64.ko*"
            initramfs_entry_add "kernel/arch/arm64/crypto/aes-neon-blk.ko*"
            initramfs_entry_add "kernel/arch/arm64/crypto/aes-neon-bs.ko*"
            ;;
        esac
        case $image_class in
          cloud | virtual )
            # Add Arm Crypto Extension modules for ARM64 virtual servers
            initramfs_entry_add "kernel/arch/arm64/crypto/*-ce*.ko*" ;;
          physical )
            case $image_physical_type in
              rpi* )
                # Raspberry Pis don't have crypto instructions
                : ;;
              * )
                # Add Arm Crypto Extension modules for ARM64 physical servers
                initramfs_entry_add "kernel/arch/arm64/crypto/*-ce*.ko*" ;;
            esac
            ;;
        esac
        ;;
      armv7 )
        case $image_luks_cipher in
          adiantum )
            initramfs_entry_add "kernel/arch/arm/crypto/chacha-neon.ko*"
            initramfs_entry_add "kernel/arch/arm/crypto/poly1305-arm.ko*"
            ;;
          * )
            initramfs_entry_add "kernel/arch/arm/crypto/aes-arm.ko*"
            initramfs_entry_add "kernel/arch/arm/crypto/aes-arm-bs.ko*"
            ;;
        esac
        ;;
      x86 | x86_64 )
        case $image_luks_cipher in
          adiantum )
            initramfs_entry_add "kernel/crypto/chacha_generic.ko*"
            initramfs_entry_add "kernel/crypto/chacha_x86_64.ko*"
            initramfs_entry_add "kernel/crypto/nhpoly1305.ko*"
            ;;
          * )
            if [ -z "$image_cpu_vendor" ] || \
               [ "$image_cpu_vendor" = "intel" ]; then
              initramfs_entry_add "kernel/arch/x86/crypto/aesni-intel.ko*"
            fi
            ;;
        esac
        ;;
    esac
    case $image_luks_cipher in
      adiantum )
        initramfs_entry_add "kernel/crypto/adiantum.ko*" ;;
    esac
    initramfs_entry_add "kernel/crypto/algif_skcipher.ko*"
    initramfs_entry_add "kernel/drivers/md/dm-crypt.ko*"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "optimise-cryptsetup.modules contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-cryptsetup.modules >> /chroot.log
	EOF
    fi
  else
    cat <<-'EOF' >> "$run_script"
	    :
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify ext4 mkinitfs feature files.
#
configure_mkinitfs_feature_ext4() {
  cat <<-'EOF' >> "$run_script"
	
	  # Ext4
	  {
	EOF

  if [ -z "$image_disable_optimisation" ]; then
    # optimise-ext4.modules

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-ext4.modules" 2
	EOF

    initramfs_entry_initialise "optimise-ext4"
    case $image_arch in
      x86 | x86_64 )
        if [ -z "$image_cpu_vendor" ] || \
           [ "$image_cpu_vendor" = "intel" ]; then
          initramfs_entry_add "kernel/arch/*/crypto/crc32c-intel.ko*"
        fi
        ;;
    esac
    initramfs_entry_add "kernel/crypto/crc32c*.ko*"
    initramfs_entry_add "kernel/fs/ext4"
    initramfs_entry_add "kernel/fs/jbd2"
    initramfs_entry_add "kernel/fs/mbcache"
    initramfs_entry_add "kernel/lib/crc16.ko*"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "optimise-ext4.modules contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-ext4.modules >> /chroot.log
	EOF
    fi
  else
    # ext4.modules

    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "ext4.modules contents:" 2
	    cat /etc/mkinitfs/features.d/ext4.modules >> /chroot.log
	EOF
    fi
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify f2fs mkinitfs feature files.
#
configure_mkinitfs_feature_f2fs() {
  cat <<-'EOF' >> "$run_script"
	
	  # F2FS
	  {
	EOF

  if [ -z "$image_disable_optimisation" ]; then
    # optimise-f2fs.modules

    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-f2fs.modules" 2
	EOF

    initramfs_entry_initialise "optimise-f2fs"
    case $image_arch in
      x86 | x86_64 )
        if [ -z "$image_cpu_vendor" ] || \
           [ "$image_cpu_vendor" = "intel" ]; then
          initramfs_entry_add "kernel/arch/*/crypto/crc32-pcmul*"
        fi
        ;;
    esac
    initramfs_entry_add "kernel/crypto/crc32_generic*"
    initramfs_entry_add "kernel/fs/f2fs"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "optimise-f2fs.modules contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-f2fs.modules >> /chroot.log
	EOF
    fi
  else
    # f2fs.modules

    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "f2fs.modules contents:" 2
	    cat /etc/mkinitfs/features.d/f2fs.modules >> /chroot.log
	EOF
    fi
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify keymap mkinitfs feature files.
#
configure_mkinitfs_feature_keymap() {
  if [ -n "$debug_enabled" ]; then
    cat <<-'EOF' >> "$run_script"
	
	  # Keymap
	  {
	    # Debug
	    write_debug_log "keymap.files contents:" 2
	    cat /etc/mkinitfs/features.d/keymap.files >> /chroot.log
	  }
	EOF
  fi
}


#
# Create/modify lvm mkinitfs feature files.
#
configure_mkinitfs_feature_lvm() {
  cat <<-'EOF' >> "$run_script"
	
	  # LVM
	  {
	EOF

  if [ -z "$image_disable_optimisation" ]; then
    # optimise-lvm.files
    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-lvm.files" 2
	    {
	      echo "/sbin/lvm"
	    } >> /etc/mkinitfs/features.d/optimise-lvm.files
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "optimise-lvm.files contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-lvm.files >> /chroot.log
	EOF
    fi

    # optimise-lvm.modules
    cat <<-'EOF' >> "$run_script"
	
	    write_log "Setting up features.d/optimise-lvm.modules" 2
	EOF

    initramfs_entry_initialise "optimise-lvm"
    initramfs_entry_add "kernel/drivers/md/dm-mod.ko*"
    initramfs_entry_add "kernel/drivers/md/dm-snapshot.ko*"
    initramfs_entry_add "kernel/drivers/md/dm-thin-pool.ko*"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "optimise-lvm.modules contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-lvm.modules >> /chroot.log
	EOF
    fi

  else
    # lvm.files & lvm.modules
    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "lvm.files contents:" 2
	    cat /etc/mkinitfs/features.d/lvm.files >> /chroot.log
	    write_debug_log "lvm.modules contents:" 2
	    cat /etc/mkinitfs/features.d/lvm.modules >> /chroot.log
	EOF
    fi
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify usb mkinitfs feature files.
#
configure_mkinitfs_feature_usb() {
  cat <<-'EOF' >> "$run_script"
	
	  # USB
	  {
	EOF

  if [ -z "$image_disable_optimisation" ]; then
    # optimise-usb.modules
    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-usb.modules" 2
	EOF

    initramfs_entry_initialise "optimise-usb"
    case $image_class in
      physical )
        # Boot/root filesystem stored on USB device
        case $image_os_device_type in
          usb | generic )
            if is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" "usb"; then
              initramfs_entry_add "kernel/drivers/usb/storage/uas.ko*"
              initramfs_entry_add "kernel/drivers/usb/storage/usb-storage.ko*"
            fi
            ;;
        esac
        case $image_physical_type in
          rpi* )
            initramfs_entry_add "kernel/fs/fat"
            initramfs_entry_add "kernel/fs/nls"
            ;;
        esac
        ;;
    esac
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "optimise-usb.modules contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-usb.modules >> /chroot.log
	EOF
    fi
  else
    # usb.modules
    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "usb.modules contents:" 2
	    cat /etc/mkinitfs/features.d/usb.modules >> /chroot.log
	EOF
    fi

  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create/modify xfs mkinitfs feature files.
#
configure_mkinitfs_feature_xfs() {
  cat <<-'EOF' >> "$run_script"
	
	  # XFS
	  {
	EOF

  if [ -z "$image_disable_optimisation" ]; then
    # optimise-xfs.files
    cat <<-'EOF' >> "$run_script"
	    write_log "Setting up features.d/optimise-xfs.files" 2
	    {
	      echo "/sbin/xfs_repair"
	    } > /etc/mkinitfs/features.d/optimise-xfs.files
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "optimise-xfs.files contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-xfs.files >> /chroot.log
	EOF
    fi

    # optimise-xfs.modules
    cat <<-'EOF' >> "$run_script"
	
	    write_log "Setting up features.d/optimise-xfs.modules" 2
	EOF

    initramfs_entry_initialise "optimise-xfs"
    case $image_arch in
      x86 | x86_64 )
        if [ -z "$image_cpu_vendor" ] || \
           [ "$image_cpu_vendor" = "intel" ]; then
          initramfs_entry_add "kernel/arch/*/crypto/crc32c-intel.ko*"
        fi
        ;;
    esac
    initramfs_entry_add "kernel/crypto/crc32c*.ko*"
    initramfs_entry_add "kernel/fs/xfs/xfs.ko*"
    initramfs_entry_add "kernel/lib/libcrc32c.ko*"
    initramfs_entry_finish

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "optimise-xfs.modules contents:" 2
	    cat /etc/mkinitfs/features.d/optimise-xfs.modules >> /chroot.log
	EOF
    fi
  else
    # xfs.files and xfs.modules
    cat <<-'EOF' >> "$run_script"
	    :
	EOF

    if [ -n "$debug_enabled" ]; then
      cat <<-'EOF' >> "$run_script"
	
	    # Debug
	    write_debug_log "xfs.files contents:" 2
	    cat /etc/mkinitfs/features.d/xfs.files >> /chroot.log
	    write_debug_log "xfs.modules contents:" 2
	    cat /etc/mkinitfs/features.d/xfs.modules >> /chroot.log
	EOF
    fi

  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# Create mkinitfs feature file for cloud/physical/virtual.
#
configure_mkinitfs_image_type_feature() {
  cat <<-EOF >> "$run_script"
	
	  # ${image_class}-${image_class_subtype}
	  {
	    write_log "Setting up features.d/${image_class}-${image_class_subtype}.modules" 2
	EOF

  initramfs_entry_initialise "${image_class}-${image_class_subtype}"

  # ACPI Button
  convert_power_button_methods_to_initramfs_entries

  # Crypto devices
  convert_crypto_devices_to_initramfs_entries

  # RNGs
  convert_rng_devices_to_initramfs_entries

  # Console / Display / KMS
  convert_display_devices_to_initramfs_entries

  # Network - only used for remote encryption unlock
  if [ -n "$luks_remote_unlock_enabled" ]; then
    convert_network_boot_devices_to_initramfs_entries
  fi

  # Storage
  convert_storage_devices_to_initramfs_entries

  # Add additional required modules to initramfs
  convert_addn_modules_to_initramfs_entries

  initramfs_entry_finish

  cat <<-EOF >> "$run_script"
	
	    # Sort and remove duplicate entries
	    sort -u -o \\
	      /etc/mkinitfs/features.d/${image_class}-${image_class_subtype}.modules \\
	      /etc/mkinitfs/features.d/${image_class}-${image_class_subtype}.modules
	EOF

  if [ -n "$debug_enabled" ]; then
    cat <<-EOF >> "$run_script"
	
	    # Debug
	    write_debug_log "${image_class}-${image_class_subtype}.modules contents:" 2
	    cat /etc/mkinitfs/features.d/${image_class}-${image_class_subtype}.modules >> /chroot.log
	EOF
  fi

  cat <<-'EOF' >> "$run_script"
	  }
	EOF
}


#
# For the defined additional modules determine the module(s) paths
# and add them to mkinitfs feature file.
#
convert_addn_modules_to_initramfs_entries() {
  local _addn_module_list _addn_module_list_item

  if [ -n "$CADI_ADDITIONAL_INITRAMFS_MODULES" ]; then
    _addn_module_list="$CADI_ADDITIONAL_INITRAMFS_MODULES"
    while true; do
      _addn_module_list_item="$(first_entry_in_comma_list "$_addn_module_list")"
      initramfs_entry_add "\\\$(find_module_full_path \"$_addn_module_list_item\")"
      if [ "${_addn_module_list%,*}" = "$_addn_module_list" ]; then
        # No more entries
        break
      else
        _addn_module_list="${_addn_module_list#$_addn_module_list_item,}"
      fi
    done
  fi
}


#
# For the defined crypto device(s) determine the module(s) paths
# and add them to mkinitfs feature file.
#
convert_crypto_devices_to_initramfs_entries() {
  local _cryptodev_list _cryptodev_list_item

  if [ -n "$CADI_SUPPORTED_CRYPTO_DEVICES" ]; then
    if [ -n "$CADI_DEFAULT_CRYPTO_DEVICE" ]; then
      # Check default driver
      if is_in_comma_list "$CADI_SUPPORTED_CRYPTO_DEVICES" \
                          "$CADI_DEFAULT_CRYPTO_DEVICE"; then
        if [ "$CADI_DEFAULT_CRYPTO_DEVICE" = "generic" ]; then
          _cryptodev_list="$(all_entries_in_comma_list_except "$CADI_SUPPORTED_CRYPTO_DEVICES" "generic")"
        else
          _cryptodev_list="$CADI_DEFAULT_CRYPTO_DEVICE"
        fi

        if [ "$_cryptodev_list" != "none" ]; then
          # Remove "none" from the list if it is present
          _cryptodev_list="$(all_entries_in_comma_list_except "$_cryptodev_list" "none")"

          while true; do
            _cryptodev_list_item="$(first_entry_in_comma_list "$_cryptodev_list")"
            initramfs_entry_add "$(convert_cryptodev_name_to_module_path "$_cryptodev_list_item")"

            if [ "${_cryptodev_list%,*}" = "$_cryptodev_list" ]; then
              # No more entries
              break
            else
              _cryptodev_list="${_cryptdev_list#$_cryptodev_list_item,}"
            fi
          done
        fi
      else
        error_message \
          "'$CADI_DEFAULT_CRYPTO_DEVICE' is not defined in CADI_SUPPORTED_CRYPTO_DEVICES for '$image_class $image_class_subtype'!"
      fi
    else
      # No default specified
      if is_single_entry_in_comma_list "$CADI_SUPPORTED_CRYPTO_DEVICES"; then
        if [ "$CADI_SUPPORTED_CRYPTO_DEVICES" != "none" ]; then
          initramfs_entry_add "$(convert_cryptodev_name_to_module_path "$CADI_SUPPORTED_CRYPTO_DEVICES")"
        fi
      else
        error_message \
          "CADI_DEFAULT_CRYPTO_DEVICE is not defined and $CADI_SUPPORTED_CRYPTO_DEVICES contains more than a single entry for '$image_class $image_class_subtype'!"
      fi
    fi
  else
    error_message \
      "CADI_SUPPORTED_CRYPTO_DEVICES is not defined for '$image_class $image_class_subtype'!"
  fi
}


#
# Given a crypto device driver name will return the required path to it.
#
convert_cryptodev_name_to_module_path() {
  local _cryptodev_module_path

  case $1 in
    ccp )
      _cryptodev_module_path="kernel/drivers/crypto/ccp" ;;
    virtio )
      _cryptodev_module_path="kernel/drivers/crypto/virtio" ;;
  esac

  echo "$_cryptodev_module_path"
}


#
# For console-related drivers determine the module(s) paths
# and add them to mkinitfs feature file.
#
convert_display_devices_to_initramfs_entries() {
  case $image_console_device_type in
    hypervisor )
      convert_text_consoles_to_initramfs_entries ;;

    none | serial )
      : ;;

    * )
      # normal, normal_and_serial, or generic

      if [ -n "$image_enable_graphics" ] && \
         [ "$image_enable_graphics" = "true" ]; then
        # Graphic driver(s) is/are required
        case $image_console_output_type in
          graphics | generic )
            convert_graphics_names_to_initramfs_entries ;;
        esac
      fi

      case $image_console_output_type in
        # Text driver(s) is/are required
        text | generic )
          convert_text_consoles_to_initramfs_entries ;;
      esac
      ;;
  esac
}


#
# Given a graphics driver name will return the required path to it.
#
convert_graphics_name_to_module_path() {
  local _gfx_driver="$1"

  local _gfx_module_path

  case $_gfx_driver in
    amd )
      case $image_alpine_release in
        v3.13 | v3.14 )
          _gfx_module_path="kernel/drivers/video/fbdev/aty" ;;
        * )
          _gfx_module_path="kernel/drivers/gpu/drm/amd" ;;
      esac
      ;;

    bochs )
      case $image_alpine_release in
        v3.13 | v3.14 )
          _gfx_module_path="kernel/drivers/gpu/drm/bochs/bochs-drm.ko*" ;;
        * )
          _gfx_module_path="kernel/drivers/gpu/drm/tiny/bochs.ko*" ;;
      esac
      ;;

    hyperv )
      case $image_alpine_release in
        v3.13 | v3.14 )
          _gfx_module_path="kernel/drivers/video/fbdev/hyperv_fb.ko*" ;;
        * )
          _gfx_module_path="kernel/drivers/gpu/drm/hyperv/hyperv_drm.ko*" ;;
      esac
      ;;

    i915 )
      case $image_alpine_release in
        v3.13 | v3.14 )
          _gfx_module_path="kernel/drivers/video/fbdev/intelfb*" ;;
        * )
          _gfx_module_path="kernel/drivers/gpu/drm/i915" ;;
      esac
      ;;

    nouveau )
      case $image_alpine_release in
        v3.13 | v3.14 )
          _gfx_module_path="kernel/drivers/video/fbdev/nvidia" ;;
        * )
          _gfx_module_path="kernel/drivers/gpu/drm/nouveau" ;;
      esac
      ;;

    qxl )
      _path="kernel/drivers/gpu/drm/qxl/qxl.ko*" ;;

    radeon )
      case $image_alpine_release in
        v3.13 | v3.14 )
          _gfx_module_path="kernel/drivers/video/fbdev/aty/radeonfb.ko*" ;;
        * )
          _gfx_module_path="kernel/drivers/gpu/drm/radeon" ;;
      esac
      ;;

    simpledrm )
      _gfx_module_path="kernel/drivers/gpu/drm/tiny/simpledrm.ko*" ;;

    virtio-gpu )
      _gfx_module_path="kernel/drivers/gpu/drm/virtio" ;;

    vmwgfx )
      _gfx_module_path="kernel/drivers/gpu/drm/vmwgfx" ;;
  esac

  echo "$_gfx_module_path"
}


#
# For graphics drivers determine the module(s) paths
# and add them to mkinitfs feature file.
#
convert_graphics_names_to_initramfs_entries() {
  local _graphics_list _graphics_list_item

  if [ -n "$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS" ]; then
    if [ -n "$image_graphics_driver" ]; then
      # Override default graphics driver
      if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS" \
                          "$image_graphics_driver"; then
        if [ "$image_graphics_driver" = "generic" ]; then
          _graphics_list="$(all_entries_in_comma_list_except "$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS" "generic")"
        else
          _graphics_list="$image_graphics_driver"
        fi
      else
        error_message \
          "Specified graphic driver '$image_graphics_driver' is not defined in CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS for '$class_type_description'!"
      fi
    elif [ -n "$CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER" ]; then
      # Use the default graphics driver
      if is_in_comma_list "$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS" \
                          "$CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER"; then
        if [ "$CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER" = "generic" ]; then
          _graphics_list="$(all_entries_in_comma_list_except "$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS" "generic")"
        else
          _graphics_list="$CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER"
        fi
      else
        error_message \
          "Wanted to add default graphic driver '$CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER' to initramfs but it is not defined in CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS!"
      fi
    elif is_single_entry_in_comma_list \
             "$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS" && \
         [ "$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS" != "generic" ] && \
         [ "$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS" != "none" ]; then
      # Use the single value in supported drivers list
      _graphics_list="$CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS"
    else
      error_message \
        "Wanted to add default graphic driver to initramfs but CADI_DEFAULT_CONSOLE_GRAPHICS_DRIVER is not defined for '$image_class $image_class_subtype'!"
    fi

    if [ "$_graphics_list" != "none" ]; then
      # Remove "none" from the list if it is present
      _graphics_list="$(all_entries_in_comma_list_except "$_graphics_list" "none")"

      while true; do
        _graphics_list_item="$(first_entry_in_comma_list "$_graphics_list")"
        if [ -n "$_graphics_list_item" ]; then
          initramfs_entry_add "$(convert_graphics_name_to_module_path "$_graphics_list_item")"
        else
          error_message \
            "Unknown graphics driver: '$_graphics_list_item' for '$image_class $image_class_subtype'!"
        fi

        if [ "${_graphics_list%,*}" = "$_graphics_list" ]; then
          # No more entries
          break
        else
          _graphics_list="${_graphics_list#$_graphics_list_item,}"
        fi
      done
    fi
  else
    #  No list of supported graphics drivers is defined
    error_message \
      "Wanted to add graphic driver(s) to initramfs but CADI_SUPPORTED_CONSOLE_GRAPHICS_DRIVERS is not defined for '$image_class $image_class_subtype'!"
  fi
}


#
# Given a network driver name will return the required path to it.
#
convert_network_name_to_module_path() {
  local _network_name="$1"

  local _network_module_path

  case $_network_name in
    alx )
      _network_module_path="kernel/drivers/net/ethernet/atheros/alx" ;;
    e1000 | e1000e | i40e | ice | igb | igbvf | igc | ixgb | ixgbe | ixgbevf )
      _network_module_path="kernel/drivers/net/ethernet/intel/${_network_name}" ;;
    ena )
      _network_module_path="kernel/drivers/net/ethernet/amazon/ena" ;;
    gve )
      _network_module_path="kernel/drivers/net/ethernet/google/gve" ;;
    hyperv )
      _network_module_path="kernel/drivers/net/hyperv/hv_netvsc.ko*" ;;
    intel )
      _network_module_path="kernel/drivers/net/ethernet/intel" ;;
    mana )
      _network_module_path="kernel/drivers/net/ethernet/microsoft/mana" ;;
    mellanox )
      _network_module_path="kernel/drivers/net/ethernet/mellanox" ;;
    mii )
      _network_module_path="kernel/drivers/net/mii.ko*" ;;
    mlx4 )
      _network_module_path="kernel/drivers/net/ethernet/mellanox/mlx4" ;;
    mlx5 )
      _network_module_path="kernel/drivers/net/ethernet/mellanox/mlx5" ;;
    nvidia )
      _network_module_path="kernel/drivers/net/ethernet/nvidia" ;;
    r8169 )
      _network_module_path="kernel/drivers/net/ethernet/realtek/r8169.ko*" ;;
    realtek )
      _network_module_path="kernel/drivers/net/ethernet/realtek" ;;
    tg3 )
      _network_module_path="kernel/drivers/net/ethernet/broadcom/tg3.ko*" ;;
    virtio-net )
      _network_module_path="kernel/drivers/net/virtio_net.ko*" ;;
    vmxnet3 )
      _network_module_path="kernel/drivers/net/vmxnet3" ;;
  esac

  echo "$_network_module_path"
}


#
# For the specified network boot drivers determine the module paths
# and add them to mkinitfs feature file.
#
convert_network_boot_devices_to_initramfs_entries() {
  local _netdev_list _netdev_list_item _netdev_module_path

  if [ -n "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" ]; then
    if [ -n "$image_ethernet_module" ]; then
      # Network module specified via option
      if is_in_comma_list "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" \
                          "$image_ethernet_module"; then
        if [ "$image_graphics_driver" = "generic" ]; then
          _netdev_list="$(all_entries_in_comma_list_except "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" "generic")"
        else
          _netdev_list="$image_ethernet_module"
        fi
      else
        error_message \
          "Ethernet driver '$image_ethernet_module' is not defined in CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS for '$image_class_description'!"
      fi
    elif [ -n "$CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER" ]; then
      # Use the default network driver
      if is_in_comma_list "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" \
                          "$CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER"; then
        if [ "$CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER" = "generic" ]; then
          _netdev_list="$(all_entries_in_comma_list_except "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" "generic")"
        else
          _netdev_list="$CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER"
        fi
      else
        error_message \
          "'$CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER' is not defined in CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS for '$image_class_description'!"
      fi
    elif is_single_entry_in_comma_list \
             "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" && \
         [ "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" != "generic" ] && \
         [ "$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS" != "none" ]; then
      # Use the single value in supported drivers list
      _netdev_list="$CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS"
    else
      error_message \
        "Wanted to add default network boot driver to initramfs but CADI_DEFAULT_OS_BOOT_NETWORK_DRIVER is not defined and CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS either is not defined or does not contain a single value for '$image_class_description'!"
    fi

    if [ "$_netdev_list" != "none" ]; then
      # Remove "none" from the list if it is present
      _netdev_list="$(all_entries_in_comma_list_except "$_netdev_list" "none")"

      while true; do
        _netdev_list_item="$(first_entry_in_comma_list "$_netdev_list")"

        if [ -n "$_netdev_list_item" ]; then
          _netdev_module_path="$(convert_network_name_to_module_path "$_netdev_list_item")"
          if [ -n "$_netdev_module_path" ]; then
            initramfs_entry_add "$_netdev_module_path"
            case $_netdev_list_item in
              r8169 | realtek )
                initramfs_entry_add "kernel/drivers/net/phy/realtek.ko*" ;;
            esac
          fi
        else
          error_message \
            "Unknown network driver: '$_netdev_list_item' for '$image_class_description'!"
        fi

        if [ "${_netdev_list%,*}" = "$_netdev_list" ]; then
          # No more entries
          break
        else
          _netdev_list="${_netdev_list#$_netdev_list_item,}"
        fi
      done

      case $image_class in
        physical )
          initramfs_entry_add "$(convert_network_name_to_module_path "mii")" ;;
      esac
    fi
  else
    error_message \
      "CADI_SUPPORTED_OS_BOOT_NETWORK_DRIVERS is not defined for '$image_class_description'!"
  fi
}


#
# Given a power button driver name will return the required path to it.
#
convert_power_button_name_to_module_path() {
  local _power_button_name="$1"

  local _power_button_module_path

  case $_power_button_name in
    button )
      _power_button_module_path="kernel/drivers/acpi/button.ko*" ;;
    gpio )
      _power_button_module_path="kernel/drivers/gpio/gpio-pl061.ko*" ;;
    tiny-power-button )
      _power_button_module_path="kernel/drivers/acpi/tiny-power-button.ko*" ;;
  esac

  echo "$_power_button_module_path"
}


#
# For the power button method determine the module(s) paths
# and add them to mkinitfs feature file.
#
convert_power_button_methods_to_initramfs_entries() {
  local _button_list _button_list_item

  if [ "$image_acpi_power_method" = "generic" ]; then
    _button_list="$(all_entries_in_comma_list_except "$CADI_SUPPORTED_ACPI_BUTTONS" "generic")"
  else
    _button_list="$image_acpi_power_method"
  fi

  while true; do
    _button_list_item="$(first_entry_in_comma_list "$_button_list")"
    if is_in_comma_list "$CADI_SUPPORTED_ACPI_BUTTONS" \
       "$_button_list_item"; then
      initramfs_entry_add "$(convert_power_button_name_to_module_path "${_button_list_item}")"
    fi

    if [ "${_button_list%,*}" = "$_button_list" ]; then
      # No more entries
      break
    else
      _button_list="${_button_list#$_button_list_item,}"
    fi
  done
}


#
# For the defined RNG device(s) determine the module(s) paths
# and add them to mkinitfs feature file.
#
convert_rng_devices_to_initramfs_entries() {
  local _rngdev_list _rngdev_list_item _rng_module_path

  if [ -n "$CADI_SUPPORTED_RNGS" ]; then
    if [ -n "$CADI_DEFAULT_RNG" ]; then
      # Check default driver
      if is_in_comma_list "$CADI_SUPPORTED_RNGS" \
                          "$CADI_DEFAULT_RNG"; then
        if [ "$CADI_DEFAULT_RNG" = "generic" ]; then
          _rngdev_list="$(all_entries_in_comma_list_except "$CADI_SUPPORTED_RNGS" "generic")"
        else
          _rngdev_list="$CADI_DEFAULT_RNG"
        fi

        if [ "$_rngdev_list" != "none" ]; then
          # Remove "none" from the list if it is present
          _rngdev_list="$(all_entries_in_comma_list_except "$_rngdev_list" "none")"

          while true; do
            _rngdev_list_item="$(first_entry_in_comma_list "$_rngdev_list")"

            _rng_module_path="$(convert_rngdev_name_to_module_path "$_rngdev_list_item")"
            if [ -n "$_rng_module_path" ]; then
              initramfs_entry_add "$_rng_module_path"
            fi

            if [ "${_rngdev_list%,*}" = "$_rngdev_list" ]; then
              # No more entries
              break
            else
              _rngdev_list="${_rngdev_list#$_rngdev_list_item,}"
            fi
          done
        fi
      else
        error_message \
          "'$CADI_DEFAULT_RNG' is not defined in CADI_SUPPORTED_RNGS for '$image_class $image_class_subtype'!"
      fi
    else
      # No default specified
      if is_single_entry_in_comma_list "$CADI_SUPPORTED_RNGS"; then
        if [ "$CADI_SUPPORTED_RNGS" != "none" ]; then
          _rng_module_path="$(convert_rngdev_name_to_module_path "$CADI_SUPPORTED_RNGS")"
          if [ -n "$_rng_module_path" ]; then
            initramfs_entry_add "$_rng_module_path"
          fi
        fi
      else
        error_message \
          "CADI_DEFAULT_RNG is not defined and CADI_SUPPORTED_RNGS contains more than a single entry for '$image_class $image_class_subtype'!"
      fi
    fi
  else
    error_message \
      "CADI_SUPPORTED_RNGS is not defined for '$image_class $image_class_subtype'!"
  fi
}


#
# Given a RNG device driver name will return the required path to it.
#
convert_rngdev_name_to_module_path() {
  local _rngdev_module_path

  case $1 in
    amd )
      if [ -z "$image_cpu_vendor" ] || [ "$image_cpu_vendor" = "amd" ]; then
        _rngdev_module_path="kernel/drivers/char/hw_random/amd-rng.ko*"
      fi
      ;;
    intel )
      if [ -z "$image_cpu_vendor" ] || [ "$image_cpu_vendor" = "intel" ]; then
        _rngdev_module_path="kernel/drivers/char/hw_random/intel-rng.ko*"
      fi
      ;;
    virtio )
      _rngdev_module_path="kernel/drivers/char/hw_random/virtio-rng.ko*" ;;
  esac

  echo "$_rngdev_module_path"
}


#
# For the defined storage driver(s) determine the module(s) paths
# and add them to mkinitfs feature file.
#
convert_storage_devices_to_initramfs_entries() {
  local _storage_list _storage_list_item
  local _storage_module_list _storage_module_list_item _storage_module_path

  if [ -n "$CADI_SUPPORTED_OS_DEVICE_TYPES" ]; then
    if [ -n "$image_os_device_type" ]; then
      # Use the specified storage driver
      if is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" \
                          "$image_os_device_type"; then
        if [ "$CADI_DEFAULT_OS_DEVICE_TYPE" = "generic" ]; then
          _storage_list="$(all_entries_in_comma_list_except "$CADI_SUPPORTED_OS_DEVICE_TYPES" "generic")"
        else
          _storage_list="$image_os_device_type"
        fi
      else
        error_message \
          "'$image_os_device_type' is not defined in CADI_SUPPORTED_OS_DEVICE_TYPES for '$image_class_description'!"
      fi
    elif [ -n "$CADI_DEFAULT_OS_DEVICE_TYPE" ]; then
      # Use the default storage driver
      if is_in_comma_list "$CADI_SUPPORTED_OS_DEVICE_TYPES" \
                          "$CADI_DEFAULT_OS_DEVICE_TYPE"; then
        if [ "$CADI_DEFAULT_OS_DEVICE_TYPE" = "generic" ]; then
          _storage_list="$(all_entries_in_comma_list_except "$CADI_SUPPORTED_OS_DEVICE_TYPES" "generic")"
        else
          _storage_list="$CADI_DEFAULT_OS_DEVICE_TYPE"
        fi
      else
        error_message \
          "'$CADI_DEFAULT_OS_DEVICE_TYPE' is not defined in CADI_SUPPORTED_OS_DEVICE_TYPES for '$image_class_description'!"
      fi
    elif is_single_entry_in_comma_list \
             "$CADI_SUPPORTED_OS_DEVICE_TYPES" && \
         [ "$CADI_SUPPORTED_OS_DEVICE_TYPES" != "generic" ] && \
         [ "$CADI_SUPPORTED_OS_DEVICE_TYPES" != "none" ]; then
      # Use the single value in supported storage drivers list
      _netdev_list="$CADI_SUPPORTED_OS_DEVICE_TYPES"
    else
      error_message \
        "Wanted to add default storage driver to initramfs but CADI_DEFAULT_OS_DEVICE_TYPE is not defined and CADI_SUPPORTED_OS_DEVICE_TYPES either is not defined or does not contain a single value for '$image_class_description'!"
    fi

    if [ "$_storage_list" != "none" ]; then
      # Remove "none" from the list if it is present
      _storage_list="$(all_entries_in_comma_list_except "$_storage_list" "none")"

      while true; do
        _storage_list_item="$(first_entry_in_comma_list "$_storage_list")"

        if [ -n "$_storage_list_item" ]; then
          _storage_module_path="$(convert_storage_name_to_module_path "$_storage_list_item")"
          if [ -n "$_storage_module_path" ]; then
            if is_single_entry_in_comma_list "$_storage_module_path"; then
              initramfs_entry_add "$_storage_module_path"
            else
              _storage_module_list="$_storage_module_path"
              while true; do
                _storage_module_list_item="$(first_entry_in_comma_list "$_storage_module_list")"
                initramfs_entry_add "$_storage_module_list_item"

                if [ "${_storage_module_list%,*}" = "$_storage_module_list" ]; then
                  # No more entries
                  break
                else
                  _storage_module_list="${_storage_module_list#$_storage_module_list_item,}"
                fi
              done
            fi
          fi
        fi

        if [ "${_storage_list%,*}" = "$_storage_list" ]; then
          # No more entries
          break
        else
          _storage_list="${_storage_list#$_storage_list_item,}"
        fi
      done
    fi
  else
    error_message \
      "CADI_SUPPORTED_OS_DEVICE_TYPES is not defined for '$image_class_description'!"
  fi
}


#
# Given a storage driver name will return the required path to it.
#
convert_storage_name_to_module_path() {
  local _storage_module_path

  case $1 in
    hyperv )
      _storage_module_path="kernel/drivers/scsi/hv_storvsc.ko*" ;;
    nvme )
      _storage_module_path="kernel/drivers/nvme/host/nvme.ko*"
      case $image_class in
        physical )
          case $image_class_subtype in
            pc )
              _storage_module_path="$_storage_module_path,kernel/drivers/pci/controller/vmd.ko*"
          esac
          ;;
      esac
      ;;
    pvscsi )
      _storage_module_path="kernel/drivers/scsi/sd_mod.ko*" ;;
    sata )
      _storage_module_path="kernel/drivers/ata/ahci.ko*"
      _storage_module_path="$_storage_module_path,kernel/drivers/ata/ahci_platform.ko*"
      _storage_module_path="$_storage_module_path,kernel/drivers/ata/libahci.ko*"
      _storage_module_path="$_storage_module_path,kernel/drivers/ata/libahci_platform.ko*"
      _storage_module_path="$_storage_module_path,kernel/drivers/scsi/sd_mod.ko*"
      ;;
    scsi )
      _storage_module_path="kernel/drivers/scsi/sd_mod.ko*" ;;
    sd )
      case $image_class in
        physical )
          case $image_class_subtype in
            rpi4 )
              _storage_module_path="kernel/drivers/mmc/host/sdhci-iproc.ko*" ;;
            rpi* )
              _storage_module_path="kernel/drivers/mmc/host/mmc_spi.ko*" ;;
            * )
              _storage_module_path="kernel/drivers/mmc/host/sdhci.ko*" ;;
          esac
          ;;
      esac
      ;;
    usb )
      _storage_module_path="kernel/drivers/scsi/ses.ko*"
      _storage_module_path="$_storage_module_path,kernel/drivers/usb/storage/uas.ko*"
      _storage_module_path="$_storage_module_path,kernel/drivers/usb/storage/usb-storage.ko*"
      _storage_module_path="$_storage_module_path,kernel/drivers/scsi/sd_mod.ko*"
      ;;
    virtio-blk )
      _storage_module_path="kernel/drivers/block/virtio_blk.ko*" ;;
    virtio-scsi )
      _storage_module_path="kernel/drivers/scsi/virtio_scsi.ko*"
      _storage_module_path="$_storage_module_path,kernel/drivers/scsi/sd_mod.ko*"
      ;;
  esac

  echo "$_storage_module_path"
}


#
# Given a text console driver name will return the required path to it.
#
convert_text_console_name_to_module_path() {
  local _text_console_path

  case $1 in
    hypervisor )
      _text_console_path="kernel/drivers/char/virtio_console.ko*" ;;
  esac

  echo $_text_console_path
}


#
# For the defined text console device(s) determine the module(s) paths
# and add them to mkinitfs feature file.
#
convert_text_consoles_to_initramfs_entries() {
  local _text_console_path

  case $image_console_device_type in
    hypervisor | generic )
      if [ -n "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES" ] && \
         is_in_comma_list "$CADI_SUPPORTED_CONSOLE_DEVICE_TYPES" \
                          "hypervisor"; then
        _text_console_path="$(convert_text_console_name_to_module_path "hypervisor")"
        if [ -n "$_text_console_path" ]; then
          initramfs_entry_add "$_text_console_path"
        fi
      else
        error_message \
          "Virtio console is not supported by $class_type_description!"
      fi
      ;;
  esac
}
