#!/bin/sh -u
# shellcheck disable=SC1117
#
#############################################################################
##
##  create-alpine-disk-image
##
##  Copyright 2021 Dermot Bradley <dermot_bradley@yahoo.com>
##
##  Licensed via GPL version 2.0
##
#############################################################################
##
##  This script must be run as root user.
##
#############################################################################

SCRIPT_VERSION="0.2-DEV"


TMPDIR="/var/tmp"

DEFAULT_ALPINE_RELEASE="edge"
DEFAULT_APK_STATIC_VERSION="2.10.4"
DEFAULT_APK_STATIC_URL="https://github.com/alpinelinux/apk-tools/releases/download/v${DEFAULT_APK_STATIC_VERSION}"
DEFAULT_ARCH="x86_64"
DEFAULT_BOOT_REFERENCE="uuid"
DEFAULT_BOOTFS_LABEL="boot"
DEFAULT_CONSOLE_NAME="tty1"
DEFAULT_KEYMAP="us us"
DEFAULT_LOCALE="en_US"
DEFAULT_LUKS_PASSPHRASE="InsecureDefault"
DEFAULT_MIRROR_SITE="https://alpine.global.ssl.fastly.net/alpine/"
DEFAULT_USER_PASSWORD="ChangeMe"
DEFAULT_ROOTFS_LABEL="alpine-rootfs"
DEFAULT_SERIAL_PORT_NUMBER="0"
DEFAULT_SERIAL_PORT_NAME="ttyS${DEFAULT_SERIAL_PORT_NUMBER}"
DEFAULT_SERIAL_PORT_SPEED="115200"
DEFAULT_USERNAME="alpine"

DEFAULT_CHROOT_DIRECTORY="./chroot"
DEFAULT_IMAGES_DIRECTORY="./alpine-images"
DEFAULT_RAMDISK_DIRECTORY="./ramdisk"
RAMDISK_SIZE=3G

# Size in MiB
CIDATA_PART_SIZE=8
UEFI_PART_SIZE=128

# Takes into account size of kernel & initramfs
CLOUD_BOOT_PART_SIZE=32
CLOUD_ROOT_PART_SIZE=270
#
# Takes into account size of firmware, kernel and initramfs
PHYSICAL_BOOT_PART_SIZE=64
PHYSICAL_ROOT_PART_SIZE=450
#
###RPI_BOOT_PART_SIZE=128
RPI_BOOT_PART_SIZE=64
RPI_ROOT_PART_SIZE=220
#
# Takes into account size of kernel & initramfs
VIRTUAL_BOOT_PART_SIZE=32
VIRTUAL_ROOT_PART_SIZE=270

#############################################################################
##		Functions
#############################################################################

#
# Enable some additional server-related init.d services
#
add_additional_init_d() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Adding additional init.d scripts"
{
  rc-update add rngd boot
  rc-update add rsyslog boot

  rc-update add chronyd default
  rc-update add sshd default
EOF

  if [ "$IMAGE_CLASS" = "vm" ]; then
    case $VM_TYPE in
      libvirtd | qemu )
        cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add qemu-guest-agent default
EOF
        ;;
      virtualbox )
        cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add virtualbox-guest-additions default
EOF
        ;;
      vmware )
        cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add open-vm-tools default
EOF
        ;;
      *)
        cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add acpid default
EOF
        ;;
    esac
  elif [ "$IMAGE_CLASS" != "physical" ] || \
       [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -eq 0 ]; then
    # acpid is not run on Raspberry PIs
    cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add acpid default
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
} >> /chroot.log 2>&1
EOF
}


#
# Add more Alpine repos to the repositories file
#
add_additional_repos() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Adding additional repos"

write_log "  Adding Community repo to /etc/apk/repositories"
cat <<-_SCRIPT_ >> /etc/apk/repositories
	$ALPINE_MIRROR_SITE/$IMAGE_ALPINE_RELEASE/community
	_SCRIPT_
EOF

  if [ "$IMAGE_ALPINE_RELEASE" = "edge" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Adding Testing repo to /etc/apk/repositories"
cat <<-_SCRIPT_ >> /etc/apk/repositories
	$ALPINE_MIRROR_SITE/$IMAGE_ALPINE_RELEASE/testing
	_SCRIPT_
EOF
  fi

  if [ -n "${LOCAL_ALPINE_REPOSITORY+x}" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Adding local repo to /etc/apk/repositories"
cat <<-_SCRIPT_ >> /etc/apk/repositories
	$LOCAL_ALPINE_REPOSITORY/$IMAGE_ALPINE_RELEASE
	_SCRIPT_
EOF
  fi
}


#
# Enable base Alpine init.d services
#
add_base_init_d() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Enable init.d scripts"
{
  rc-update add devfs sysinit
  rc-update add dmesg sysinit

  rc-update add bootmisc boot
  rc-update add hostname boot
EOF

  if [ "$IMAGE_CLASS" = "physical" ] && \
     [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add hwclock boot
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add modules boot
EOF

  if [ "$IMAGE_CLASS" != "physical" ] || \
     [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -eq 0 ]; then

    cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add osclock boot
EOF

  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add sysctl boot
  rc-update add swap boot
EOF

  if [ "$IMAGE_CLASS" = "physical" ] && \
     [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add swclock boot
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
  rc-update add urandom boot

  rc-update add crond default
  rc-update add networking default

  rc-update add killprocs shutdown
  rc-update add mount-ro shutdown
  rc-update add savecache shutdown
} >> /chroot.log 2>&1
EOF
}


#
# Adds an entry to the specified /etc/mkinitfs/features.d/*.modules file
#
add_initramfs_entry() {
  local modules_file=$1
  local modules_entry="$2"

  cat <<EOF >> "$RUN_SCRIPT"
	$modules_entry
EOF
}


#
# Insert required functions into the run script
#
add_runscript_functions() {
  cat <<EOF >> "$RUN_SCRIPT"

#############################################################################
##   Functions
#############################################################################

#
# Checks that the host OS has all necessary packages installed
#
check_for_required_packages() {
  local host_os

  host_os=\$(detect_host_os)
  case \$host_os in
    alpine )
EOF

  # Busybox losetup not suitable
  REQUIRED_LIST="blkid busybox e2fsprogs parted util-linux"
  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    REQUIRED_LIST="$REQUIRED_LIST cryptsetup"
  fi
  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    REQUIRED_LIST="$REQUIRED_LIST lvm2"
  fi

  cat <<EOF >> "$RUN_SCRIPT"
      REQUIRED_PACKAGES="$REQUIRED_LIST"
      if [ -n "\$(apk info -q "\$REQUIRED_PACKAGES" 1>/dev/null)" ]; then
        echo
        echo "The following Alpine packages need to be installed:"
        echo "  \$REQUIRED_PACKAGES"
        echo
        exit 1
      fi
      ;;
    debian | ubuntu )
EOF

  REQUIRED_LIST="coreutils e2fsprogs mount parted wget"
  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    REQUIRED_LIST="$REQUIRED_LIST cryptsetup-bin"
  fi
  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    REQUIRED_LIST="$REQUIRED_LIST lvm2"
  fi

  cat <<EOF >> "$RUN_SCRIPT"
      REQUIRED_PACKAGES="$REQUIRED_LIST"
      if [ "\$(dpkg-query -W -f='\${Status}\n' "\$REQUIRED_PACKAGES")" -ne 0 ]; then
        echo
        echo "The following packages need to be installed:"
        echo "  \$REQUIRED_PACKAGES"
        echo
        exit 1
      fi
      ;;
    *)
      echo
      echo "Unsupported host OS!"
      echo
      exit 1
      ;;
  esac
}


#
# Check that the host OS has necessary packages installed for
# running user-mode QEMU via binfmt and that it is configured.
#
check_binfmt_packages() {
  local arch=\$1
  local host_arch host_os

  host_arch=\$(uname -m)

  if [ "\$host_arch" != "\$arch" ]; then
    host_os=\$(detect_host_os)
    case \$host_os in
      alpine )
        REQUIRED_PACKAGES="qemu-openrc"
        case \$arch in
          aarch64 )
            REQUIRED_PACKAGES="\$REQUIRED_PACKAGES qemu-aarch64" ;;
          armv7 )
            REQUIRED_PACKAGES="\$REQUIRED_PACKAGES qemu-arm" ;;
          x86 )
            REQUIRED_PACKAGES="\$REQUIRED_PACKAGES qemu-i386" ;;
          x86_64 )
            REQUIRED_PACKAGES="\$REQUIRED_PACKAGES qemu-x86_64" ;;
          * )
            echo "Unsupported archicture: \$arch!"
            exit 1
            ;;
        esac
        if [ -n "\$(apk info -q "\$REQUIRED_PACKAGES" 1>/dev/null)" ]; then
          echo
          echo "The following Alpine packages need to be installed:"
          echo "  \$REQUIRED_PACKAGES"
          echo
          exit 1
        fi
        ;;
      debian | ubuntu )
        REQUIRED_PACKAGES="binfmt-support qemu-user-static"
        if [ "\$(dpkg-query -W -f='\${Status}\n' "\$REQUIRED_PACKAGES")" -ne 0 ]; then
          echo
          echo "The following packages need to be installed:"
          echo "  \$REQUIRED_PACKAGES"
          echo
          exit 1
        fi
        ;;
      * )
        echo
        echo "Unsupported host OS!"
        echo
        exit 1
        ;;
    esac

    # Is binfmt configured for this QEMU arch?
    case \$arch in
      aarch64 )
        BINFMT_FILE="/proc/sys/fs/binfmt_misc/qemu-aarch64" ;;
      armv7 )
        BINFMT_FILE="/proc/sys/fs/binfmt_misc/qemu-arm" ;;
      x86 )
        BINFMT_FILE="/proc/sys/fs/binfmt_misc/qemu-i386" ;;
      x86_64 )
        BINFMT_FILE="/proc/sys/fs/binfmt_misc/qemu-x86_64" ;;
    esac
    if [ -e "\$BINFMT_FILE" ]; then
      BINFMT_ARCH_ENABLED=\$(head -1 \${BINFMT_FILE})
      if [ "\$BINFMT_ARCH_ENABLED" = "enabled" ]; then
        return
      else
        echo
        echo "Binfmt is not enabled for \$arch"
        echo
        exit 1
      fi
    else
      echo
      echo "Binfmt and QEMU are not configured for \$arch"
      echo
      exit 1
    fi
  fi
}


#
# Determine the Linux distro that this script is being run on
#
detect_host_os() {
  local os

  os=\$(grep "^ID" /etc/os-release | sed -e 's/^ID=//')
  echo "\$os"
}


#
# Unmount filesystems whenever an error occurs in the script
#
error_cleanup() {
  write_log "An error occurred, cleaning up before aborting!"

  normal_cleanup
EOF

  if [ -n "${RAMDISK_DIRECTORY+x}" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

  if [ "$(mount | grep "$RAMDISK_DIRECTORY")" != "" ]; then
    write_log "Unmounting ramdisk"
    umount "$RAMDISK_DIRECTORY" >> "$LOGFILE"
    rmdir "$RAMDISK_DIRECTORY"
  fi
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
}


#
# Get the UUID of the filesystem in the specified device
#
get_uuid_from_device() {
  local DEVICE=$1

  # shellcheck disable=SC2005
  echo "$(blkid -s UUID "$DEVICE" | sed -E -e 's|^.*UUID="(.*)"|\1|')"
}


#
# Unmount filesystems mounted inside chroot directory
#
normal_cleanup() {
  write_log "Normal cleanup"

  # Unmount special filesystems
  if [ "$(mount | grep "$CHROOT_DIRECTORY"/dev)" != "" ]; then
    write_log "  Unmounting /dev inside chroot"
    umount -l -f "$CHROOT_DIRECTORY"/dev >> "$LOGFILE"
  fi
  if [ "$(mount | grep "$CHROOT_DIRECTORY"/sys)" != "" ]; then
    write_log "  Unmounting /sys inside chroot"
    umount -l -f "$CHROOT_DIRECTORY"/sys >> "$LOGFILE"
  fi
  if [ "$(mount | grep "$CHROOT_DIRECTORY"/proc)" != "" ]; then
    write_log "  Unmounting /proc inside chroot"
    umount -l -f "$CHROOT_DIRECTORY"/proc >> "$LOGFILE"
  fi
EOF

  if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

  write_log "  Unmounting /boot filesystem"
  umount -l -f "$CHROOT_DIRECTORY"/boot >> "$LOGFILE"
EOF
  elif [ "$IMAGE_BOOT_TYPE" = "uefi" ] && \
       [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

  write_log "  Unmounting /boot bind-mounted from ESP filesystem"
  umount -l -f "$CHROOT_DIRECTORY"/boot >> "$LOGFILE"
EOF
  fi

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

  write_log "  Unmounting ESP filesystem"
  umount -l -f "$CHROOT_DIRECTORY"/efi >> "$LOGFILE"
EOF
  fi

  if [ "$IMAGE_CLASS" = "physical" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

  if mount | grep -q "$CHROOT_DIRECTORY/cidata" ; then
    write_log "  Unmounting cidata filesystem"
    umount -l -f "$CHROOT_DIRECTORY"/cidata >> "$LOGFILE"
  fi
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

  if [ "$(mount | grep "$CHROOT_DIRECTORY")" != "" ]; then
    write_log "  Unmounting root filesystem"
    umount -l -f "$CHROOT_DIRECTORY" >> "$LOGFILE"
  fi
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

  cryptsetup close cryptroot
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

  write_log "  Freeing up loop device"
  losetup -d "$LOOP_DEVICE" >> "$LOGFILE"
}

#
# Write debug messages only to the log file
#
write_debug_log() {
EOF

  if [ "$DEBUG" = "true" ]; then
	  cat <<'EOF' >> "$RUN_SCRIPT"
  current_time=$(printf "[%s]" "$(date -u "+%Y-%m-%d %H:%M:%S")")
  echo "$current_time $1" >> "$LOGFILE"
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"
  # Debug not enabled so do nothing
  true
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
}


#
# Write log messages to both the logfile (with timestamp) and stdout
#
write_log() {
  current_time=$(printf "[%s]" "$(date -u "+%Y-%m-%d %H:%M:%S")")
  echo "$current_time $1" >> "$LOGFILE"
  echo "$1"
}

#############################################################################
##   Main Section
#############################################################################

# Ensure if any errors occur that various cleanup operations happen
trap error_cleanup EXIT
EOF

  cat <<EOF >> "$RUN_SCRIPT"

CHROOT_DIRECTORY="$CHROOT_DIRECTORY"
IMAGES_DIRECTORY="$IMAGES_DIRECTORY"
TMPDIR="/var/tmp"

IMAGE_FILENAME="$IMAGE_FILENAME"
LOGFILE="$LOGFILE"

EOF

  if [ "$DEBUG" != "true" ]; then
    cat <<EOF >> "$RUN_SCRIPT"
DEFAULT_USER_PASSWORD="$IMAGE_DEFAULT_USER_PASSWORD"

EOF
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<EOF >> "$RUN_SCRIPT"
ENCRYPTION_PASSPHRASE="$IMAGE_ENCRYPTION_PASSPHRASE"

EOF
  fi

  cat <<EOF >> "$RUN_SCRIPT"
# Create empty logfile
:> \$LOGFILE

EOF

if [ "$USE_RAMDISK" = "true" ]; then
  cat <<EOF >> "$RUN_SCRIPT"
RAMDISK_DIRECTORY="$RAMDISK_DIRECTORY"
IMAGE_FULL_FILENAME="\$RAMDISK_DIRECTORY/\$IMAGE_FILENAME"
EOF
else
  cat <<EOF >> "$RUN_SCRIPT"
IMAGE_FULL_FILENAME="\$IMAGES_DIRECTORY/\$IMAGE_FILENAME"
EOF
fi

}


#
# Additional OS configuration
#
additional_os_configuration() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Doing additional OS configuration"

# FIXUP: stop update-ca-certificates displaying a warning
sed -i \
  -e 's|/etc/ssl/certs|/etc/ssl/certs 2>/dev/null|' \
  /etc/ca-certificates/update.d/certhash
EOF

  tighten_sshd_configuration

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    setup_crypttab
  fi
}


#
# Basic OS configuration
#
basic_os_configuration() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Doing basic OS configuration"

write_log "  Setting the login message to be 'vague'"
echo -e "\nWelcome\n\n" > /etc/issue
EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    LOGIN_BANNER="Alpine $IMAGE_ARCH $CLOUD_TYPE Cloud server"
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual machine
    LOGIN_BANNER="Alpine $IMAGE_ARCH $VM_TYPE VM server"
  else
    # Physical machine
    case $PHYSICAL_TYPE in
      pc )
        LOGIN_BANNER="Alpine $IMAGE_ARCH PC server"
        ;;
      rpi2 | rpi3 | rpi4 )
        LOGIN_BANNER="Alpine $IMAGE_ARCH Raspberry Pi server"
        ;;
      * )
        LOGIN_BANNER=""
        ;;
    esac
  fi

  cat <<EOF >> "$RUN_SCRIPT"
echo -e "\n\n$LOGIN_BANNER\n\n" > /etc/motd
EOF

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting the keymap to '\$KEYMAP'"
setup-keymap \$KEYMAP >> "/chroot.log" 2>&1
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/profile.d/locale.sh /etc/profile.d/locale.sh-orig
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting locale to \$LOCALE.UTF-8"
sed -i -E \
  -e 's/^(export LANG=)C.UTF-8/\1\$LOCALE.UTF-8/' \
  /etc/profile.d/locale.sh
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/profile.d/locale.sh-orig /etc/profile.d/locale.sh \
    >> /chroot.log \
    || true
  rm /etc/profile.d/locale.sh-orig

  cp /etc/rc.conf /etc/rc.conf-orig
}
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Fixup rc.conf so that keyboards and screens use Unicode"
sed -i -e 's/^#unicode="NO"/unicode="YES"/' /etc/rc.conf
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/rc.conf-orig /etc/rc.conf \
    >> /chroot.log \
    || true
  rm /etc/rc.conf-orig
}
EOF
  fi

  if [ "$IMAGE_ALPINE_RELEASE" = "v3.13" ]; then
    COLOR_PROMPT_FILE="color_prompt"
  else
    COLOR_PROMPT_FILE="color_prompt.sh.disabled"
  fi

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Enable colour shell prompt"
cp \
  /etc/profile.d/${COLOR_PROMPT_FILE} \
  /etc/profile.d/color_prompt.sh

rmdir /media/floppy
EOF
}


#
# Calculate size of the resultant disk image taking into account
# whether bootloader, boot and cloud-init partitions are needed.
#
calculate_image_size() {
  local SIZE

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    SIZE=$ROOT_PART_SIZE
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      # shellcheck disable=SC2003
      SIZE="$((SIZE + UEFI_PART_SIZE))"
    fi
    if [ "$IMAGE_BOOT_TYPE" != "uefi" ] || \
       [ "$IMAGE_BOOTLOADER" != "syslinux" ]; then
      # Exclude UEFI with Syslinux as then EFI partition is also /boot.
      SIZE="$((SIZE + BOOT_PART_SIZE))"
    fi
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical machine
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      # x86/x86_64 PC
      SIZE="$((ROOT_PART_SIZE + CIDATA_PART_SIZE))"
      if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
        # shellcheck disable=SC2003
        SIZE="$((SIZE + UEFI_PART_SIZE))"
      fi
      if [ "$IMAGE_BOOT_TYPE" != "uefi" ] || \
         [ "$IMAGE_BOOTLOADER" != "syslinux" ]; then
        # Exclude UEFI with Syslinux as then EFI partition is also /boot.
        SIZE="$((SIZE + BOOT_PART_SIZE))"
      fi
    else
      # Raspberry Pi
      # shellcheck disable=SC2003
      SIZE="$((BOOT_PART_SIZE + CIDATA_PART_SIZE + ROOT_PART_SIZE))"
    fi
  else
    # Virtual machine
    SIZE=$ROOT_PART_SIZE
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      # shellcheck disable=SC2003
      SIZE="$((SIZE + UEFI_PART_SIZE))"
    fi
    if [ "$IMAGE_BOOT_TYPE" != "uefi" ] || \
       [ "$IMAGE_BOOTLOADER" != "syslinux" ]; then
      # Exclude UEFI with Syslinux as then EFI partition is also /boot.
      SIZE="$((SIZE + BOOT_PART_SIZE))"
    fi
  fi

  echo "$SIZE"
}



#
# Configure Grub
#
configure_bootloader_grub() {
  local MODULES

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Configuring Grub"
mkdir -p /boot/grub
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
write_debug_log "  Root fs partition device is $ROOT_PART_DEVICE"
write_debug_log "  Loopback device is $LOOP_DEVICE"
EOF
  fi

  # Busybox's losetup is not suitable when installing Grub on a loopback
  # device as it may truncate the name of the underlying filename.
  cat <<'EOF' >> "$RUN_SCRIPT"
write_log "  Installing util-linux package for losetup"
apk add --quiet util-linux
EOF

  if [ "$IMAGE_BOOT_REFERENCE" = "label" ]; then

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
  cp /etc/grub.d/10_linux /etc/grub.d/10_linux-orig
	cp /usr/share/grub/grub-mkconfig_lib /usr/share/grub/grub-mkconfig_lib-orig
	cp /usr/sbin/grub-mkconfig /usr/sbin/grub-mkconfig-orig
}
EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Temporarily installing patch program"
apk add --quiet patch >> $LOGFILE
write_log "  Patching /etc/grub.d/10_linux"
cat <<-'_SCRIPT_' | patch /etc/grub.d/10_linux >> $LOGFILE
	--- /etc/grub.d/10_linux
	+++ /etc/grub.d/10_linux-label
	@@ -44,7 +44,8 @@
	 # the initrds that Linux uses don't like that.
	 case ${GRUB_DEVICE} in
	   /dev/loop/*|/dev/loop[0-9])
	-    GRUB_DEVICE=`losetup ${GRUB_DEVICE} | sed -e "s/^[^(]*(\([^)]\+\)).*/\1/"`
	+    # Work with both Busybox and util-linux versions of losetup
	+    GRUB_DEVICE=`losetup ${GRUB_DEVICE} | sed -e "s/^[^:]*: []0-9[\:]* [\(]*\([^)]\+\)[\)]*$/\1/"`
	   ;;
	 esac
	
	@@ -64,6 +65,10 @@
	   LINUX_ROOT_DEVICE=PARTUUID=${GRUB_DEVICE_PARTUUID}
	 else
	   LINUX_ROOT_DEVICE=UUID=${GRUB_DEVICE_UUID}
	+  GRUB_DEVICE_LABEL="$(blkid | grep "UUID=\"${GRUB_DEVICE_UUID}\"" | sed -e 's|^.* LABEL="||g' -e 's|".*||g' | head -1)"
	+  if [ "x${GRUB_ENABLE_LINUX_LABEL}" = "xtrue" ] ; then
	+    LINUX_ROOT_DEVICE=LABEL=${GRUB_DEVICE_LABEL}
	+  fi
	 fi
	
	 case x"$GRUB_FS" in
	_SCRIPT_

write_log "  Patching /usr/share/grub/grub-mkconfig_lib"
cat <<-'_SCRIPT_' | patch /usr/share/grub/grub-mkconfig_lib >> $LOGFILE
	--- grub-mkconfig_lib-stock
	+++ grub-mkconfig_lib-custom
	@@ -156,7 +156,9 @@
	   if [ "x$fs_hint" != x ]; then
	     echo "set root='$fs_hint'"
	   fi
	-  if fs_uuid="`"${grub_probe}" --device $@ --target=fs_uuid 2> /dev/null`" ; then
	+  if label="`${grub_probe} --device $@ --target=fs_label 2> /dev/null`" ; then
	+    echo "search --no-floppy --label --set=root ${label}"
	+  elif fs_uuid="`"${grub_probe}" --device $@ --target=fs_uuid 2> /dev/null`" ; then
	     hints="`"${grub_probe}" --device $@ --target=hints_string 2> /dev/null`" || hints=
	     echo "if [ x\$feature_platform_search_hint = xy ]; then"
	     echo "  search --no-floppy --fs-uuid --set=root ${hints} ${fs_uuid}"
	_SCRIPT_

write_log "  Patching /usr/sbin/grub-mkconfig"
cat <<-'_SCRIPT_' | patch /usr/sbin/grub-mkconfig >> $LOGFILE
	--- grub-mkconfig-stock
	+++ grub-mkconfig-custom
	@@ -135,10 +135,12 @@
	 GRUB_DEVICE="`${grub_probe} --target=device /`"
	 GRUB_DEVICE_UUID="`${grub_probe} --device ${GRUB_DEVICE} --target=fs_uuid 2> /dev/null`" || true
	 GRUB_DEVICE_PARTUUID="`${grub_probe} --device ${GRUB_DEVICE} --target=partuuid 2> /dev/null`" || true
	+GRUB_DEVICE_LABEL="`${grub_probe} --device ${GRUB_DEVICE} --target=fs_label 2> /dev/null`" || true
	 
	 # Device containing our /boot partition.  Usually the same as GRUB_DEVICE.
	 GRUB_DEVICE_BOOT="`${grub_probe} --target=device /boot`"
	 GRUB_DEVICE_BOOT_UUID="`${grub_probe} --device ${GRUB_DEVICE_BOOT} --target=fs_uuid 2> /dev/null`" || true
	+GRUB_DEVICE_BOOT_LABEL="`${grub_probe} --device ${GRUB_DEVICE_BOOT} --target=fs_label 2> /dev/null`" || true
	 
	 # Filesystem for the device containing our userland.  Used for stuff like
	 # choosing Hurd filesystem module.
	@@ -190,8 +192,10 @@
	 export GRUB_DEVICE \
	   GRUB_DEVICE_UUID \
	   GRUB_DEVICE_PARTUUID \
	+  GRUB_DEVICE_LABEL \
	   GRUB_DEVICE_BOOT \
	   GRUB_DEVICE_BOOT_UUID \
	+  GRUB_DEVICE_BOOT_LABEL \
	   GRUB_FS \
	   GRUB_FONT \
	   GRUB_PRELOAD_MODULES \
	@@ -226,6 +230,7 @@
	   GRUB_SERIAL_COMMAND \
	   GRUB_DISABLE_LINUX_UUID \
	   GRUB_DISABLE_LINUX_PARTUUID \
	+  GRUB_ENABLE_LINUX_LABEL \
	   GRUB_DISABLE_RECOVERY \
	   GRUB_VIDEO_BACKEND \
	   GRUB_GFXMODE \
	_SCRIPT_

write_log "  Uninstalling patch program"
apk del --quiet patch >> $LOGFILE
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
	write_debug_log "  Diff 10_linux:"
  diff -aur /etc/grub.d/10_linux-orig /etc/grub.d/10_linux \
    >> $LOGFILE \
    || true
  rm /etc/grub.d/10_linux-orig

  write_debug_log "  Diff grub-mkconfig_lib:"
  diff -aur \
    /usr/share/grub/grub-mkconfig_lib-orig /usr/share/grub/grub-mkconfig_lib \
    >> $LOGFILE \
  	|| true
  rm /usr/share/grub/grub-mkconfig_lib-orig

  write_debug_log "  Diff grub-mkconfig:"
 diff -aur \
    /usr/sbin/grub-mkconfig-orig /usr/sbin/grub-mkconfig \
    >> $LOGFILE \
  	|| true
  rm /usr/sbin/grub-mkconfig-orig

}
EOF
    fi

  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
write_debug_log "  Contents of /etc/grub.d/10_linux:"
cat /etc/grub.d/10_linux >> /chroot.log
cp /etc/default/grub /etc/default/grub-orig
EOF
  fi

  KERNEL_OPTS_LIST="rootfstype=ext4"

  # Add modules list
  MODULES=$(define_cmdline_for_modules)
  if [ -n "${MODULES+x}" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST modules=$MODULES"
  fi

  if [ "$CONSOLE_TYPE" = "serial" ] || \
     [ "$CONSOLE_TYPE" = "both" ]; then
    # Serial console
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST console=${SERIAL_PORT_NAME},${SERIAL_PORT_SPEED}"
  fi

  if [ "$CONSOLE_TYPE" = "normal" ] || \
     [ "$CONSOLE_TYPE" = "both" ]; then
    # Normal console
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST console=$CONSOLE_NAME"
  fi

  if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    # With BIOS can disable graphics as "standard" VGA provides text output
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST nomodeset"
  fi

  if [ "$IMAGE_DISABLE_IPV6" = "true" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST ipv6.disable=1"
  fi

  if [ -n "${IMAGE_BOOTCHART+x}" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST chart"
  fi

  KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST quiet"

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Update /etc/default/grub"
sed -i \
  -e 's|^GRUB_DISABLE_RECOVERY=.*$|GRUB_DISABLE_RECOVERY=false|g' \
  -e 's|^GRUB_TIMEOUT=.*$|GRUB_TIMEOUT=5|g' \
  /etc/default/grub
EOF

  cat <<EOF >> "$RUN_SCRIPT"
KERNEL_OPTS="$KERNEL_OPTS_LIST"
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # Add other LUKS-related cmdline entries
    cat <<'EOF' >> "$RUN_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS root=/dev/mapper/cryptroot"
KERNEL_OPTS="\$KERNEL_OPTS \$(define_cmdline_for_encryption)"
EOF

    if [ "$REMOTE_UNLOCK" != "true" ]; then
      # Cryptkey is used for unlock rootfs without 2nd password prompt.
      # It doesn't apply when remote unlock is enabled as then /boot is
      # not encrypted for Grub to manage.
      cat <<'EOF' >> "$RUN_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS cryptkey"
EOF
    fi
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
{
  echo "GRUB_CMDLINE_LINUX_DEFAULT=\"\$KERNEL_OPTS\""
EOF

  if [ "$IMAGE_BOOT_REFERENCE" = "label" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
	echo 'GRUB_ENABLE_LINUX_LABEL=true'
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"
  echo 'GRUB_ENABLE_LINUX_LABEL=false'
EOF
  fi

  if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
  echo 'GRUB_GFXPAYLOAD_LINUX=text'
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
  echo 'GRUB_DISABLE_OS_PROBER=true'
  echo 'GRUB_RECORDFAIL_TIMEOUT=20'
} >> /etc/default/grub
EOF

  if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
if ! grep -q "^GRUB_TERMINAL=" /etc/default/grub; then
  echo 'GRUB_TERMINAL=console' >> /etc/default/grub
fi
EOF
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ] && \
     [ "$REMOTE_UNLOCK" != "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
echo 'GRUB_ENABLE_CRYPTODISK=y' >> /etc/default/grub
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
  diff /etc/default/grub-orig /etc/default/grub \
    >> /chroot.log \
    || true
  rm /etc/default/grub-orig

  # Fudge
  sed -i -e 's|^set -e$|set -ex|' /usr/sbin/grub-mkconfig
}
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

####chmod g=,o= /etc/default/grub

write_log "  Generating GRUB config"
grub-mkconfig -o /boot/grub/grub.cfg >> /chroot.log 2>&1
EOF

  cat <<'EOF' >> "$RUN_SCRIPT"
write_log "  Checking GRUB config"
grub-script-check /boot/grub/grub.cfg >> /chroot.log

chmod g=,o= /boot/grub/grub.cfg
EOF
}


#
# Setup the config files used by Raspberry Pi bootloader
#
configure_bootloader_rpi() {
  local CMDLINE EXTRA_MODULES MODULES

  MODULES="sd-mod,usb-storage"
  EXTRA_MODULES="$(define_cmdline_for_modules)"
  if [ -n "${EXTRA_MODULES+x}" ]; then
    MODULES="$MODULES,$EXTRA_MODULES"
  fi
  CMDLINE="rootfstype=ext4 modules=$MODULES"

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    CMDLINE="$CMDLINE root=/dev/mapper/cryptroot \$(define_cmdline_for_encryption)"
  else
    CMDLINE="$CMDLINE root=/dev/mmcblk0p${ROOT_PART_NUM}"
  fi

  if [ "$IMAGE_DISABLE_IPV6" = "true" ]; then
	  CMDLINE="$CMDLINE ipv6.disable=1"
	fi

  if [ -n "${IMAGE_BOOTCHART+x}" ]; then
    CMDLINE="$CMDLINE chart"
  fi

  CMDLINE="$CMDLINE console=${CONSOLE_NAME} quiet"

  cat <<EOF >> "$RUN_SCRIPT"

write_log "Create RPI bootloader configuration"

write_log "  Creating /boot/cmdline.txt"
cat <<-_SCRIPT_ > /boot/cmdline.txt
	$CMDLINE
	_SCRIPT_

write_log "  Creating /boot/config.txt"
cat <<-_SCRIPT_ > /boot/config.txt
EOF

  if [ "$PHYSICAL_TYPE" != "rpi4" ]; then
	  # RPI 2 or RPI 3
	  cat <<'EOF' >> "$RUN_SCRIPT"
	[pi2]
	kernel=vmlinuz-rpi
	initramfs initramfs-rpi
	[pi3]
	kernel=vmlinuz-rpi
	initramfs initramfs-rpi
	[pi3+]
	kernel=vmlinuz-rpi
	initramfs initramfs-rpi
EOF
  else
	  # RPI 4
	  cat <<'EOF' >> "$RUN_SCRIPT"
	[pi4]
	enable_gic=1
	kernel=vmlinuz-rpi4
	initramfs initramfs-rpi4
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	[all]
EOF

  if [ "$IMAGE_ARCH" = "aarch64" ]; then
	  cat <<'EOF' >> "$RUN_SCRIPT"
	arm_64bit=1
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	# Set GPU memory to 16MB when using cutdown bootloader
	gpu_mem=16
	include usercfg.txt
	_SCRIPT_
EOF

  if [ "$PHYSICAL_TYPE" != "rpi4" ]; then
	  # RPI 2 or RPI 3
    FIXUP_FILE="fixup_cd.dat"
    START_FILE="start_cd.elf"
  else
	  # RPI 4
    FIXUP_FILE="fixup4cd.dat"
    START_FILE="start4cd.elf"
	fi
  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Creating /boot/usercfg.txt"
cat <<-_SCRIPT_ > /boot/usercfg.txt
	fixup_file=$FIXUP_FILE
	start_file=$START_FILE
	_SCRIPT_
EOF
}


#
# Configure Syslinux
#
configure_bootloader_syslinux() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Configuring Syslinux"
mkdir -p /boot
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
# Debug
cp /etc/update-extlinux.conf /etc/update-extlinux.conf-orig

EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
write_log "  Updating update-extlinux.conf"
EOF

  KERNEL_OPTS_LIST="rootfstype=ext4"
  if [ "$CONSOLE_TYPE" = "serial" ] || \
     [ "$CONSOLE_TYPE" = "both" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST console=${SERIAL_PORT_NAME},${SERIAL_PORT_SPEED}"
  fi
  if [ "$CONSOLE_TYPE" = "normal" ] || \
     [ "$CONSOLE_TYPE" = "both" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST console=${CONSOLE_NAME}"
  fi
  if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST nomodeset"
  fi
  if [ "$IMAGE_DISABLE_IPV6" = "true" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST ipv6.disable=1"
  fi
  if [ -n "${IMAGE_BOOTCHART+x}" ]; then
    KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST chart"
  fi
  KERNEL_OPTS_LIST="$KERNEL_OPTS_LIST quiet"

  cat <<EOF >> "$RUN_SCRIPT"
KERNEL_OPTS="$KERNEL_OPTS_LIST"
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
KERNEL_OPTS="\$KERNEL_OPTS \$(define_cmdline_for_encryption)"
EOF
  fi

  MODULES_LIST="ext4"
  EXTRA_MODULES="$(define_cmdline_for_modules)"
  if [ -n "${EXTRA_MODULES+x}" ]; then
    MODULES_LIST="$MODULES_LIST,$EXTRA_MODULES"
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
FS_REFERENCE="/dev/mapper/cryptroot"
EOF
  elif [ "$IMAGE_BOOT_REFERENCE" = "label" ]; then
    # Use LABELs to refer to filesystems
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      cat <<EOF >> "$RUN_SCRIPT"
###FS_REFERENCE="LABEL=SYSTEM_EFI"
FS_REFERENCE="LABEL=$DEFAULT_ROOTFS_LABEL"
EOF
    else
      cat <<EOF >> "$RUN_SCRIPT"
FS_REFERENCE="LABEL=$DEFAULT_ROOTFS_LABEL"
EOF
    fi
  else
    # Use UUIDs to refer to filesystems
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
###FS_REFERENCE="UUID=$ESP_FS_UUID"
FS_REFERENCE="UUID=$ROOT_FS_UUID"
EOF
    else
      cat <<'EOF' >> "$RUN_SCRIPT"
FS_REFERENCE="UUID=$ROOT_FS_UUID"
EOF
    fi
  fi

  cat <<EOF >> "$RUN_SCRIPT"
MODULES="$MODULES_LIST"
EOF

  cat <<'EOF' >> "$RUN_SCRIPT"
sed -i \
  -e 's|^overwrite=(.*)\$|overwrite=1|g' \
  -e "s|^modules=.*\$|modules=\$MODULES|g" \
  -e 's|^hidden=.*\$|hidden=0|g' \
  -e 's|^timeout=.*\$|timeout=3|g' \
  -e "s|^default_kernel_opts=.*\$|default_kernel_opts=\"\$KERNEL_OPTS\"|g" \
  -e "s|^root=.*\$|root=\$FS_REFERENCE|g" \
  /etc/update-extlinux.conf
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
  write_debug_log "  diff update-extlinux.conf"
  diff /etc/update-extlinux.conf-orig /etc/update-extlinux.conf \
    >> /chroot.log \
    || true
  rm /etc/update-extlinux.conf-orig
  write_debug_log "  update-extlinux.conf contents:"
  cat /etc/update-extlinux.conf >> /chroot.log
}
EOF
  fi
}


#
# Configure cloud-init
#
configure_cloud_init() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Configuring cloud-init"

write_log "  Running setup-cloud-init"
setup-cloud-init >> /chroot.log 2>&1
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/cloud/cloud.cfg /etc/cloud/cloud.cfg-orig
EOF
  fi

  if [ "$DEBUG" != "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Locking the root account"
cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	
	# Lock root's password
	users:
	  - name: root
	    lock_passwd: true
	_SCRIPT_
EOF
  fi

  if [ "$DEBUG" != "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting the default user's password"
cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	
	# The password for the default user account
	passwd: $DEFAULT_USER_PASSWORD
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"

cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	
	# Delete any pre-existing SSH hosts keys
	ssh_deletekeys: True
	
	# Only create ED25519 and RSA SSH host keys
	ssh_genkeytypes: ["ed25519","rsa"]
	
	# Don't show SSH host key fingerprints on console at boot.
	no_ssh_fingerprints: True
	_SCRIPT_

write_log "  Ensuring SSH password authentication is disabled"
sed -i \
  -Ee 's/^([[:space:]]*)ssh_pwauth:.*$/\1ssh_pwauth: false/' \
  /etc/cloud/cloud.cfg
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Preventing default user account being locked"
sed -i \
  -Ee 's/^([[:space:]]+)lock_passwd: .*$/\1lock_passwd: false/' \
  /etc/cloud/cloud.cfg
EOF
  fi

  if [ "$IMAGE_DEFAULT_USERNAME" != "alpine" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Setting the default username to $IMAGE_DEFAULT_USERNAME"
sed -i \
  -Ee 's/^([[:space:]]+)name: alpine$/\1name: $IMAGE_DEFAULT_USERNAME/' \
  /etc/cloud/cloud.cfg
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

sed -i \
  -Ee 's/^([[:space:]]+)gecos: .*$/\1gecos: Default cloud-init user/' \
  /etc/cloud/cloud.cfg

write_log "  Removing unused cloud-init modules from configuration"
sed -i \
  -e '/^ - chef/d' \
  -e '/^ - mcollective/d' \
  -e '/^ - puppet/d' \
  -e '/^ - rightscale_userdata/d' \
  -e '/^ - salt-minion/d' \
  /etc/cloud/cloud.cfg
EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    define_cloud_settings
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    DATASOURCE_LIST="'NoCloud'"
  else
    # VM
    define_virtual_settings
  fi
  if [ -z "${DATASOURCE_LIST+x}" ]; then
    DATASOURCE_LIST="'None'"
  else
    DATASOURCE_LIST="$DATASOURCE_LIST,'None'"
  fi

  # Need to sort out serial console settings at this stage, after specific
  # clouds/VM types may/may not have overriden the defaults.
  if [ "$CONSOLE_TYPE" = "serial" ] || \
     [ "$CONSOLE_TYPE" = "both" ]; then
    if [ -z "${SERIAL_PORT_NUMBER+x}" ]; then
      SERIAL_PORT_NUMBER=$DEFAULT_SERIAL_PORT_NUMBER
      SERIAL_PORT_NAME=$DEFAULT_SERIAL_PORT_NAME
    fi
    if [ -z "${SERIAL_PORT_SPEED+x}" ]; then
      SERIAL_PORT_SPEED=$DEFAULT_SERIAL_PORT_SPEED
    fi
  fi

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Setting up DataSources list"
cat <<-_SCRIPT_ >> /etc/cloud/cloud.cfg
	
	datasource_list: [$DATASOURCE_LIST]
EOF

  if [ -n "${DATASOURCE_SETTINGS+x}" ]; then
    cat <<EOF >> "$RUN_SCRIPT"
	
	datasource:
	  $DATASOURCE_SETTINGS
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	_SCRIPT_
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/cloud/cloud.cfg-orig \
    /etc/cloud/cloud.cfg \
    >> /chroot.log \
    || true
  rm /etc/cloud/cloud.cfg-orig

  cp /etc/cloud/cloud.cfg.d/05_logging.cfg \
    /etc/cloud/cloud.cfg.d/05_logging.cfg-orig
}
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Enabling cloud-init debugging"
sed -i \
  -E '\$!N; s/(class=.*Handler\n[[:space:]]*)level=INFO/\1level=DEBUG/g ;P;D' \
  /etc/cloud/cloud.cfg.d/05_logging.cfg
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Disabling cloud-init debugging"
sed -i \
  -E '\$!N; s/(class=.*Handler\n[[:space:]]*)level=DEBUG/\1level=INFO/g ;P;D' \
  /etc/cloud/cloud.cfg.d/05_logging.cfg
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/cloud/cloud.cfg.d/05_logging.cfg-orig \
    /etc/cloud/cloud.cfg.d/05_logging.cfg \
    >> /chroot.log \
    || true
  rm /etc/cloud/cloud.cfg.d/05_logging.cfg-orig
}
EOF
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    case $CLOUD_TYPE in
      azure )
        create_etc_filesystems "ISO"
        ;;
    esac
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual machine
    create_etc_filesystems "ISO"
  else
    # Physical
    create_etc_filesystems "VFAT"
  fi

  if [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    create_cloud_init_yaml_files
  fi
}


#
# Place entries in /etc/fstab for various filesystems
#
configure_fstab() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Add /etc/fstab entries"
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
add_fstab_entry DEVICE "/dev/mapper/cryptroot" "/" "ext4" "rw,relatime" "rootfs"
EOF
  else
    case $IMAGE_BOOT_REFERENCE in
      label )
        cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry LABEL "$DEFAULT_ROOTFS_LABEL" "/" "ext4" "rw,relatime" "rootfs"
EOF
        ;;
      * )
        cat <<'EOF' >> "$RUN_SCRIPT"
add_fstab_entry UUID "$ROOT_FS_UUID" "/" "ext4" "rw,relatime" "rootfs"
EOF
        ;;
    esac
  fi

	if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    local MOUNTPOINT="/efi"

    case $IMAGE_BOOT_REFERENCE in
      label )
        cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry LABEL "SYSTEM_EFI" "${MOUNTPOINT}" "vfat" "rw" "ESP filesystem"
EOF
        ;;
		  *)
        cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry UUID "\$ESP_FS_UUID" "${MOUNTPOINT}" "vfat" "rw" "ESP filesystem"
EOF
        ;;
		esac

    if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
add_fstab_entry BIND "/efi/EFI/boot" "/boot" "none" "rw,relatime" "/boot ESP bind-mount"
EOF
    fi
	fi

  if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
    if [ "$IMAGE_CLASS" = "physical" ] && \
       [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
      # RPI 2, 3, or 4
      if [ "$IMAGE_BOOT_REFERENCE" = "label" ]; then
        cat <<'EOF' >> "$RUN_SCRIPT"
add_fstab_entry LABEL "boot" "/media/sdcard" "vfat" "rw,relatime" "/media/sdcard"
EOF
      else
        cat <<'EOF' >> "$RUN_SCRIPT"
add_fstab_entry UUID "$BOOT_FS_UUID" "/media/sdcard" "vfat" "rw,relatime" "/media/sdcard"
EOF
      fi
      cat <<'EOF' >> "$RUN_SCRIPT"
add_fstab_entry BIND "/media/sdcard" "/boot" "none" "rw,relatime" "/boot bind-mount"
EOF
    else
      if [ "$IMAGE_BOOT_REFERENCE" = "label" ]; then
        cat <<EOF >> "$RUN_SCRIPT"
add_fstab_entry LABEL "$DEFAULT_BOOTFS_LABEL" "/boot" "ext4" "rw,relatime" "bootfs"
EOF
      else
        cat <<'EOF' >> "$RUN_SCRIPT"
add_fstab_entry UUID "$BOOT_FS_UUID" "/boot" "ext4" "rw,relatime" "bootfs"
EOF
      fi
    fi
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  write_debug_log "  Resultant /etc/fstab contents:"
  cat /etc/fstab >> "/chroot.log"
}
EOF
  fi
}


#
# Configure mkinitfs so that only the modules necessary for the relevant
# image type are placed in the initramfs file.
#
configure_mkinitfs() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Configuring mkinitfs"

write_log "  Setting up mkinitfs.conf"
EOF

  if [ "$DEBUG" = "true" ]; then

    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/mkinitfs/mkinitfs.conf /etc/mkinitfs/mkinitfs.conf-orig

EOF
  fi

  FEATURES_LIST="base ext4 keymap kms network"

  if [ -n "${IMAGE_BOOTCHART+x}" ]; then
    FEATURES_LIST="$FEATURES_LIST bootchart"
  fi
  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    FEATURES_LIST="$FEATURES_LIST lvm"
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    FEATURES_LIST="$FEATURES_LIST virtio"

    if [ "$IMAGE_ENCRYPTED" = "true" ]; then
      if [ "$IMAGE_BOOTLOADER" = "grub" ] && \
         [ "$REMOTE_UNLOCK" != "true" ]; then
        # cryptkey is only needed when using GRUB encrypted /boot
        # to avoid being prompted both by GRUB and by initramfs for
        # the passphrase twice.
        FEATURES_LIST="$FEATURES_LIST cryptkey"
      fi
      # cryptsetup is required in all rootfs encryption situations
      FEATURES_LIST="$FEATURES_LIST cryptsetup"
      if [ "$REMOTE_UNLOCK" = "true" ]; then
        # enable SSH remote unlock functionality
        FEATURES_LIST="$FEATURES_LIST remote_unlock_luks"
      fi
    fi

    if [ "$CLOUD_TYPE" = "aws" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # AWS
      FEATURES_LIST="$FEATURES_LIST ena nvme"
    fi

  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical machine

    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      FEATURES_LIST="$FEATURES_LIST ata nvme scsi usb"

      if [ "$IMAGE_ENCRYPTED" = "true" ]; then
        if [ "$IMAGE_BOOTLOADER" = "grub" ] && \
           [ "$REMOTE_UNLOCK" != "true" ]; then
          # cryptkey is only needed when using GRUB encrypted /boot
          # to avoid being prompted both by GRUB and by initramfs for
          # the passphrase twice.
          FEATURES_LIST="$FEATURES_LIST cryptkey"
        fi

        # cryptsetup is required in all rootfs encryption situations
        FEATURES_LIST="$FEATURES_LIST cryptsetup"

        if [ "$REMOTE_UNLOCK" = "true" ]; then
          # enable SSH remote unlock functionality
          FEATURES_LIST="$FEATURES_LIST remote_unlock_luks"
        fi
      fi

    elif [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
      FEATURES_LIST="$FEATURES_LIST mmc usb"

      if [ "$IMAGE_ENCRYPTED" = "true" ]; then
        # cryptsetup is required in all rootfs encryption situations
        FEATURES_LIST="$FEATURES_LIST cryptsetup"

        if [ "$REMOTE_UNLOCK" = "true" ]; then
          # enable SSH remote unlock functionality
          FEATURES_LIST="$FEATURES_LIST remote_unlock_luks"
        fi
      fi
    fi

  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual Machine
    FEATURES_LIST="$FEATURES_LIST scsi virtio"

    if [ "$IMAGE_ENCRYPTED" = "true" ]; then
      if [ "$IMAGE_BOOTLOADER" = "grub" ] && \
         [ "$REMOTE_UNLOCK" != "true" ]; then
        # cryptkey is only needed when using GRUB encrypted /boot
        # to avoid being prompted both by GRUB and by initramfs for
        # the passphrase twice.
        FEATURES_LIST="$FEATURES_LIST cryptkey"
      fi

      # cryptsetup is required in all rootfs encryption situations
      FEATURES_LIST="$FEATURES_LIST cryptsetup"

      if [ "$REMOTE_UNLOCK" = "true" ]; then
        # enable SSH remote unlock functionality
        FEATURES_LIST="$FEATURES_LIST remote_unlock_luks"
      fi
    fi
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  mkinitfs features list is: $FEATURES_LIST"
EOF
  fi

  cat <<EOF >> "$RUN_SCRIPT"
sed -i \
  -e "s|^features=\".*\"|features=\"$FEATURES_LIST\"|" \
  /etc/mkinitfs/mkinitfs.conf
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/mkinitfs.conf-orig \
    /etc/mkinitfs/mkinitfs.conf \
    >> /chroot.log \
    || true

  cp /etc/mkinitfs/features.d/ata.modules \
    /etc/mkinitfs/features.d/ata.modules-orig
}
EOF
  fi

  # ata.modules
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/ata.modules"
EOF

  initialise_initramfs_entry "ata"
  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "ata" "# This file is empty for Cloud machines"
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical machine
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      add_initramfs_entry "ata" "kernel/drivers/ata/ahci.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/ahci_platform.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/ata_generic.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/ata_piix.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/libahci.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/libahci_platform.ko"
      add_initramfs_entry "ata" "kernel/drivers/ata/libata.ko"
    elif [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
      add_initramfs_entry "ata" "# This file is empty for Raspberry Pi machines"
    fi
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual Machine
    add_initramfs_entry "ata" "# This file is empty for Virtual machines"
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/ata.modules-orig \
    /etc/mkinitfs/features.d/ata.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/ata.modules-orig

  cp /etc/mkinitfs/features.d/base.modules \
    /etc/mkinitfs/features.d/base.modules-orig
}
EOF
  fi

  # base.modules
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/base.modules"
EOF

  initialise_initramfs_entry "base"
  if [ "$IMAGE_ARCH" != "aarch86" ] || \
     [ "$IMAGE_TYPE" != "vm" ]; then
    # jitterentropy_rng is a module for all machines except for
    # aarch64 VMs where it is compiled into the linux-virt kernel.
    add_initramfs_entry "base" "kernel/crypto/jitterentropy_rng.ko"
  fi

  if [ "$IMAGE_ARCH" = "aarch64" ]; then
    if [ "$IMAGE_CLASS" = "cloud" ] || \
       [ "$IMAGE_CLASS" = "vm" ]; then
      # aarch64 Cloud and Virtual machines
      add_initramfs_entry "base" "kernel/drivers/acpi/button.ko"
    fi
  fi

  if [ "$IMAGE_ARCH" = "x86" ] || \
     [ "$IMAGE_ARCH" = "x86_64" ]; then
    # all x86 and x86_64 machines
    add_initramfs_entry "base" "kernel/drivers/acpi/button.ko"
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/base.modules-orig \
    /etc/mkinitfs/features.d/base.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/base.modules-orig
}
EOF
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ] && \
     [ "$IMAGE_BOOTLOADER" = "grub" ] && \
     [ "$REMOTE_UNLOCK" != "true" ]; then
    # cryptkey.files

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/cryptkey.files \
    /etc/mkinitfs/features.d/cryptkey.files-orig
EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/cryptkey.files"
echo "/etc/crypttab" \
  >> /etc/mkinitfs/features.d/cryptkey.files
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/cryptkey.files-orig \
    /etc/mkinitfs/features.d/cryptkey.files \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/cryptkey.files-orig
}
EOF
    fi

  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # cryptsetup.modules

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/cryptsetup.modules \
    /etc/mkinitfs/features.d/cryptsetup.modules-orig
EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/cryptsetup.modules"
EOF

    initialise_initramfs_entry "cryptsetup"
    case $IMAGE_ARCH in
      aarch64 )
        add_initramfs_entry "cryptsetup" "kernel/arch/arm64/crypto/aes-arm64.ko"
        if [ "$IMAGE_CLASS" = "cloud" ]; then
          # Add Arm Crypto Extension modules for ARM64 servers
          add_initramfs_entry "cryptsetup" "kernel/arch/arm64/crypto/*-ce*.ko"
        fi

        ;;
      x86 | x86_64 )
        if [ -z ${IMAGE_GRAPHICS_VENDOR+X} ] || \
           [ "$IMAGE_GRAPHICS_VENDOR" = "intel" ]; then
          add_initramfs_entry "cryptsetup" "kernel/arch/x86/crypto/aesni-intel.ko"
          ##add_initramfs_entry "cryptsetup" "kernel/arch/x86/crypto/crc32c_intel.ko"
          ##add_initramfs_entry "cryptsetup" "kernel/arch/x86/crypto/ghash-clmulni-intel.ko"
        fi
        #add_initramfs_entry "cryptsetup" "kernel/arch/x86/crypto/*"
        ;;
    esac
    add_initramfs_entry "cryptsetup" "kernel/drivers/md/dm-crypt.ko"
    finish_initramfs_entry

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/cryptsetup.modules-orig \
    /etc/mkinitfs/features.d/cryptsetup.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/cryptsetup.modules-orig
}
EOF
    fi
  fi

  # kms.modules
  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/kms.modules \
  /etc/mkinitfs/features.d/kms.modules-orig
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/kms.modules"
EOF

  initialise_initramfs_entry "kms"
  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "kms" "kernel/drivers/gpu/drm/virtio"

    if [ "$CLOUD_TYPE" = "azure" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # Azure
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/hyperv_fb.ko"
    fi
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical machine
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      add_initramfs_entry "kms" "kernel/drivers/char/agp/agpgart.ko"
      if [ -z ${IMAGE_GRAPHICS_VENDOR+X} ] || \
         [ "$IMAGE_GRAPHICS_VENDOR" = "amd" ]; then
        add_initramfs_entry "kms" "kernel/drivers/char/agp/amd64-agp.ko"
        add_initramfs_entry "kms" "kernel/drivers/gpu/drm/amd"
        add_initramfs_entry "kms" "kernel/drivers/gpu/drm/radeon"
        add_initramfs_entry "kms" "kernel/drivers/video/fbdev/aty/radeonfb.ko"
      fi
      if [ -z ${IMAGE_GRAPHICS_VENDOR+X} ] || \
         [ "$IMAGE_GRAPHICS_VENDOR" = "intel" ]; then
        add_initramfs_entry "kms" "kernel/drivers/char/agp/intel-agp.ko"
        add_initramfs_entry "kms" "kernel/drivers/char/agp/intel-gtt.ko"
        add_initramfs_entry "kms" "kernel/drivers/gpu/drm/gma500"
        add_initramfs_entry "kms" "kernel/drivers/gpu/drm/i915"
        add_initramfs_entry "kms" "kernel/drivers/video/fbdev/intelfb"
      fi
      if [ -z ${IMAGE_GRAPHICS_VENDOR+X} ] || \
         [ "$IMAGE_GRAPHICS_VENDOR" = "nvidia" ]; then
        add_initramfs_entry "kms" "kernel/drivers/gpu/drm/nouveau"
        add_initramfs_entry "kms" "kernel/drivers/video/fbdev/nvidia"
      fi
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/i2c"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/scheduler"
      ###add_initramfs_entry "kms" "kernel/drivers/i2c/busses/i2c-amd*.ko"
      ###add_initramfs_entry "kms" "kernel/drivers/i2c/busses/i2c-piix4.ko"
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/uvesafb.ko"
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/vga16fb.ko"
    elif [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/vc4/vc4.ko"
      add_initramfs_entry "kms" "kernel/drivers/i2c"
    fi
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual Machine
    if [ "$VM_TYPE" = "hyperv" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # Hyper-V
      add_initramfs_entry "kms" "kernel/drivers/video/fbdev/hyperv_fb.ko"
    fi

    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "proxmox" ] || \
       [ "$VM_TYPE" = "qemu" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # libvirtd / Proxmox / QEMU
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/bochs/bochs-drm.ko"
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/virtio"
    fi

    if [ "$VM_TYPE" = "virtualbox" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # Virtualbox
      add_initramfs_entry "kms" "kernel/drivers/gpu/drm/vboxvideo/vboxvideo.ko"
    fi
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/kms.modules-orig \
    /etc/mkinitfs/features.d/kms.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/kms.modules-orig
}
EOF
  fi

  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then

    # lvm.modules
    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/lvm.modules \
    /etc/mkinitfs/features.d/lvm.modules-orig

EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/lvm.modules"
EOF

    initialise_initramfs_entry "lvm"
    add_initramfs_entry "lvm" "kernel/drivers/md/dm-mod.ko"
    add_initramfs_entry "lvm" "kernel/drivers/md/dm-snapshot.ko"
    add_initramfs_entry "lvm" "kernel/drivers/md/dm-thin-pool.ko"
    finish_initramfs_entry

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/lvm.modules-orig \
    /etc/mkinitfs/features.d/lvm.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/lvm.modules-orig
}
EOF
    fi
  fi

  # network.modules
  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/mkinitfs/features.d/network.modules \
  /etc/mkinitfs/features.d/network.modules-orig
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/network.modules"
EOF

  initialise_initramfs_entry "network"
  add_initramfs_entry "network" "kernel/net/packet/af_packet.ko"

  if [ "$IMAGE_DISABLE_IPV6" != "true" ]; then
    add_initramfs_entry "network" "kernel/net/ipv6/ipv6.ko"
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "network" "kernel/drivers/net/virtio_net.ko"

    if [ "$CLOUD_TYPE" = "aws" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # AWS
      add_initramfs_entry "network" "kernel/drivers/net/ethernet/amazon/ena"
    fi

    if [ "$CLOUD_TYPE" = "azure" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # Azure
      add_initramfs_entry "network" "kernel/drivers/net/hyperv"
    fi
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical machine
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      if [ -n "${IMAGE_ETHERNET_MODULE+x}" ]; then
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/${IMAGE_ETHERNET_MODULE}.ko"
        if [ "$IMAGE_ETHERNET_MODULE" = "realtek/r8169" ]; then
          add_initramfs_entry "network" "kernel/drivers/net/phy/realtek.ko"
        fi
      else
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/atheros/alx"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/broadcom/tg3.ko"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/e1000"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/e1000e"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/i40e"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/ice"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/igb"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/igbvf"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/igc"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/ixgb"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/ixgbe"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/intel/ixgbevf"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/nvidia"
        add_initramfs_entry "network" "kernel/drivers/net/ethernet/realtek/r8169.ko"
        add_initramfs_entry "network" "kernel/drivers/net/phy/realtek.ko"
      fi
      add_initramfs_entry "network" "kernel/drivers/net/mii.ko"
    elif [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
      add_initramfs_entry "network" "# No additions for Raspberry Pi machines"
    fi
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual machine
    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "proxmox" ] || \
       [ "$VM_TYPE" = "qemu" ] || \
       [ "$VM_TYPE" = "virtualbox" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # libvirtd / Proxmox / QEMU / Virtualbox
      add_initramfs_entry "network" "kernel/drivers/net/virtio_net.ko"
    fi

    if [ "$VM_TYPE" = "hyperv" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # Hyper-V
      add_initramfs_entry "network" "kernel/drivers/net/hyperv"
    fi

    if [ "$VM_TYPE" = "vmware" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # VMware
      add_initramfs_entry "network" "kernel/drivers/net/vmxnet3"
    fi
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/network.modules-orig \
    /etc/mkinitfs/features.d/network.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/network.modules-orig

  cp /etc/mkinitfs/features.d/nvme.modules \
    /etc/mkinitfs/features.d/nvme.modules-orig
}
EOF
  fi

  # nvme.modules
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/nvme.modules"
EOF

  initialise_initramfs_entry "nvme"
  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    if [ "$CLOUD_TYPE" = "aws" ] || \
       [ "$CLOUD_TYPE" = "generic" ]; then
      # AWS
      add_initramfs_entry "nvme" "kernel/drivers/nvme/host/nvme.ko"
    else
      add_initramfs_entry "nvme" "# This file is empty for non-AWS Cloud machines"
    fi
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      add_initramfs_entry "nvme" "kernel/drivers/nvme/host/nvme.ko"
    elif [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
      add_initramfs_entry "nvme" "# This file is empty for Raspberry Pi machines"
    fi
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual machine
    add_initramfs_entry "nvme" "# This file is empty for Virtual machines"
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/nvme.modules-orig \
    /etc/mkinitfs/features.d/nvme.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/nvme.modules-orig

  cp /etc/mkinitfs/features.d/scsi.modules \
    /etc/mkinitfs/features.d/scsi.modules-orig
}
EOF
fi

  # scsi.modules
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/scsi.modules"
EOF

  initialise_initramfs_entry "scsi"
  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "scsi" "kernel/drivers/scsi/scsi_mod.ko"
    add_initramfs_entry "scsi" "kernel/drivers/scsi/sd_mod.ko"
    add_initramfs_entry "scsi" "kernel/drivers/scsi/virtio_scsi.ko"
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      ###add_initramfs_entry "scsi" "kernel/drivers/scsi/scsi_mod.ko"
      add_initramfs_entry "scsi" "kernel/drivers/scsi/sd_mod.ko"
      add_initramfs_entry "scsi" "kernel/drivers/scsi/ses.ko"
      add_initramfs_entry "scsi" "kernel/drivers/scsi/sg.ko"
      #######add_initramfs_entry "scsi" "kernel/drivers/scsi/sr_mod.ko"
    elif [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
      add_initramfs_entry "scsi" "kernel/drivers/scsi/ses.ko"
    fi
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual machine
    add_initramfs_entry "scsi" "kernel/drivers/scsi/sd_mod.ko"
    add_initramfs_entry "scsi" "kernel/drivers/scsi/virtio_scsi.ko"
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/scsi.modules-orig \
    /etc/mkinitfs/features.d/scsi.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/scsi.modules-orig

  cp /etc/mkinitfs/features.d/usb.modules \
    /etc/mkinitfs/features.d/usb.modules-orig
}
EOF
  fi

  # usb.modules
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/usb.modules"
EOF

  initialise_initramfs_entry "usb"
  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "usb" "# This file is empty for Cloud machines"
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      ###add_initramfs_entry "usb" "kernel/drivers/usb/storage/uas.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/usbhid"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-generic.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-cherry.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-apple.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/ehci-hcd.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/ehci-pci.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/ehci-platform.ko"
      if [ -z "${IMAGE_CPU_VENDOR+x}" ] || \
         [ "$IMAGE_CPU_VENDOR" != "intel" ]; then
        add_initramfs_entry "usb" "kernel/drivers/usb/host/ohci-hcd.ko"
        add_initramfs_entry "usb" "kernel/drivers/usb/host/ohci-pci.ko"
        add_initramfs_entry "usb" "kernel/drivers/usb/host/ohci-platform.ko"
      else
        add_initramfs_entry "usb" "kernel/drivers/usb/host/uhci-hcd.ko"
      fi
      add_initramfs_entry "usb" "kernel/drivers/usb/host/xhci-hcd.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/xhci-pci.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/host/xhci-plat-hcd.ko"
      add_initramfs_entry "usb" "kernel/drivers/usb/storage/usb-storage.ko"
      add_initramfs_entry "usb" "kernel/fs/fat"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_cp*ko"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_iso8859*ko"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_utf8*ko"
    elif [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
      add_initramfs_entry "usb" "kernel/drivers/usb/storage/uas.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/usbhid"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-generic.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-cherry.ko"
      add_initramfs_entry "usb" "kernel/drivers/hid/hid-apple.ko"
      add_initramfs_entry "usb" "kernel/fs/fat"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_cp*ko"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_iso8859*ko"
      add_initramfs_entry "usb" "kernel/fs/nls/nls_utf8*ko"
    fi
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual machine
    add_initramfs_entry "usb" "# This file is empty for Virtual machines"
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/usb.modules-orig \
    /etc/mkinitfs/features.d/usb.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/usb.modules-orig

  cp /etc/mkinitfs/features.d/virtio.modules \
    /etc/mkinitfs/features.d/virtio.modules-orig
}
EOF
  fi

  # virtio.modules
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Setting up features.d/virtio.modules"
EOF

  initialise_initramfs_entry "virtio"
  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud
    add_initramfs_entry "virtio" "kernel/drivers/block/virtio_blk.ko"
    if [ "$CONSOLE_TYPE" = "normal" ] || \
       [ "$CONSOLE_TYPE" = "both" ]; then
      add_initramfs_entry "virtio" "kernel/drivers/char/virtio_console.ko"
    fi
    add_initramfs_entry "virtio" "kernel/drivers/char/hw_random/virtio-rng.ko"
    add_initramfs_entry "virtio" "kernel/drivers/crypto/virtio*"
    add_initramfs_entry "virtio" "kernel/drivers/virtio/virtio_pci.ko"
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical
    add_initramfs_entry "virtio" "# This file is empty for Physical machines"
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual machine
    add_initramfs_entry "virtio" "kernel/drivers/virtio/virtio_pci.ko"
    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "proxmox" ] || \
       [ "$VM_TYPE" = "qemu" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # libvirtd / Proxmox / QEMU
      add_initramfs_entry "virtio" "kernel/drivers/block/virtio_blk.ko"
      if [ "$CONSOLE_TYPE" = "normal" ] || \
         [ "$CONSOLE_TYPE" = "both" ]; then
        add_initramfs_entry "virtio" "kernel/drivers/char/virtio_console.ko"
      fi
      add_initramfs_entry "virtio" "kernel/drivers/char/hw_random/virtio-rng.ko"
      add_initramfs_entry "virtio" "kernel/drivers/crypto/virtio*"
      add_initramfs_entry "virtio" "kernel/drivers/virtio"
    fi

    if [ "$VM_TYPE" = "virtualbox" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      # Virtualbox
      add_initramfs_entry "virtio" "kernel/drivers/crypto/virtio*"
      add_initramfs_entry "virtio" "kernel/drivers/virt/vboxguest/vboxguest.ko"
      add_initramfs_entry "virtio" "kernel/drivers/virtio/virtio.ko"
      add_initramfs_entry "virtio" "kernel/drivers/virtio/virtio_ring.ko"
    fi
  fi
  finish_initramfs_entry

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/mkinitfs/features.d/virtio.modules-orig \
    /etc/mkinitfs/features.d/virtio.modules \
    >> /chroot.log \
    || true
  rm /etc/mkinitfs/features.d/virtio.modules-orig

  # Fudge
  sed -i -e 's|^set -e$|set -ex|' /sbin/mkinitfs
}
EOF
  fi
}


#
# Copy LUKS keyfile into place
#
copy_luks_keyfile_into_place() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Moving LUKS keyfile into chroot directory"
mv crypto_keyfile.bin "$CHROOT_DIRECTORY"/
chmod 400 "$CHROOT_DIRECTORY"/crypto_keyfile.bin
EOF
}


#
# For physical machines create the cloud-init YAML config files
#
create_cloud_init_yaml_files() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Creating cloud-init YAML files for physical machine"

write_log "  Create example YAML files"
mkdir /cidata/examples

cat <<-_SCRIPT_ > /cidata/examples/meta-data.yaml
	instance-id: iid-local0
	_SCRIPT_

cat <<-_SCRIPT_ > /cidata/examples/network-dhcp.yaml
	version: 2
	ethernets:
	  eth0:
	    dhcpv4: yes
	    dhcpv6: yes
	_SCRIPT_

cat <<-_SCRIPT_ > /cidata/examples/user-data.yaml
	#cloud-config
	
	apk_repos:
	  preserve_repositories: false
	  alpine_repo:
EOF

  cat <<EOF >> "$RUN_SCRIPT"
	    version: '$IMAGE_ALPINE_RELEASE'
	    base_url: $ALPINE_MIRROR_SITE
	    community_enabled: true
EOF

  if [ "$IMAGE_ALPINE_RELEASE" = "edge" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
	  testing_enabled: true
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"
	    testing_enabled: false
EOF
  fi

  if [ -n "${LOCAL_ALPINE_REPOSITORY+x}" ]; then
    cat <<EOF >> "$RUN_SCRIPT"
	  local_repo_base_url: $LOCAL_ALPINE_REPOSITORY
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
	
	debug:
	  verbose: false
	
	ssh:
	  # Whether to show either host keys or their fingerprints on console
	  emit_keys_to_console: false
	
	locale: \$LOCALE
	
	ntp:
	  enabled: true
	  servers:
	    - pool.ntp.org
	
	package_reboot_if_required: false
	package_update: false
	package_upgrade: false
	
	resize_rootfs: true
	
	ssh_authorized_keys:
	  - '??????'
	
	# Host keys: Pre-existing keys are deleted by default.
	ssh_deletekeys: true
	
	timezone: ????
	
	_SCRIPT_

write_log "  Creating meta-data.yaml"
cp /cidata/examples/meta-data.yaml \
  /cidata/meta-data.yaml

write_log "  Creating network-config-v2.yaml"
cp /cidata/examples/network-dhcp.yaml \
  /cidata/network-config-v2.yaml

write_log "  Creating user-data.yaml"
cp /cidata/examples/user-data.yaml \
  /cidata/user-data.yaml
EOF
}


#
# Create /etc/filesystems for Busybox mount
#
create_etc_filesystems() {
  local CONFIG_FS_TYPE=$1

  # Busybox mount command requires the following config

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Setting up /etc/filesystems for $CONFIG_FS_TYPE mount"
cat <<-_SCRIPT_ > /etc/filesystems
	#
	# /etc/filesystems
	#
	
	# Needed for cloud-init cidata $CONFIG_FS_TYPE
EOF

  if [ "$CONFIG_FS_TYPE" = "ISO" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
	iso9660
	_SCRIPT_
EOF
  else
    cat <<'EOF' >> "$RUN_SCRIPT"
	vfat
	_SCRIPT_
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  write_debug_log "    /etc/filesystems content:"
  cat /etc/filesystems >> /chroot.log
}
EOF
  fi
}


#
# Create the comment block at the start of the runscript
#
create_runscript_header() {
  cat <<EOF > "$RUN_SCRIPT"
#!/bin/sh -eu

#############################################################################
# Generated by create-alpine-disk-image version $SCRIPT_VERSION using the
# following options:
#
# $FULL_COMMAND_OPTIONS
#
#############################################################################

if [ "\$(id -u)" -ne 0 ]; then
  echo
  echo "This script must be run as the root user!"
  echo
  exit 1
fi

EOF
}


#
# Define list of packages in addition to base Alpine
#
define_additional_packages() {
  INITIAL_PACKAGES="ca-certificates chrony cloud-init dhcpcd kbd-bkeymaps"
  INITIAL_PACKAGES="$INITIAL_PACKAGES logrotate musl-locales openssh-server-pam"
  INITIAL_PACKAGES="$INITIAL_PACKAGES rng-tools rsyslog tzdata"

  if [ -n "${IMAGE_BOOTCHART+x}" ]; then
    INITIAL_PACKAGES="$INITIAL_PACKAGES acct"
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    INITIAL_PACKAGES="$INITIAL_PACKAGES cryptsetup"
    if [ "$REMOTE_UNLOCK" = "true" ]; then
      INITIAL_PACKAGES="$INITIAL_PACKAGES dropbear-convert dropbear-unlockdisk"
    fi
  fi

  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    INITIAL_PACKAGES="$INITIAL_PACKAGES lvm2"
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud Providers
    case $CLOUD_TYPE in
      aws )
        INITIAL_PACKAGES="${INITIAL_PACKAGES} aws-cli nvme-cli"
        ;;
      digitalocean )
        INITIAL_PACKAGES="${INITIAL_PACKAGES} doctl"
        ;;
      hetzner )
        INITIAL_PACKAGES="${INITIAL_PACKAGES} hcloud"
        ;;
    esac

  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Physical machine
    case $PHYSICAL_TYPE in
      pc )
        if [ -n "${IMAGE_CPU_VENDOR+x}" ] && \
           [ "$IMAGE_CPU_VENDOR" = "amd" ]; then
          INITIAL_PACKAGES="${INITIAL_PACKAGES} amd-ucode"
        elif [ -n "${IMAGE_CPU_VENDOR+x}" ] && \
             [ "$IMAGE_CPU_VENDOR" = "intel" ]; then
          INITIAL_PACKAGES="${INITIAL_PACKAGES} intel-ucode"
        else
          INITIAL_PACKAGES="${INITIAL_PACKAGES} amd-ucode intel-ucode"
        fi
        INITIAL_PACKAGES="${INITIAL_PACKAGES} irqbalance nvme-cli"
        ;;
      rpi2 | rpi3 | rpi4 )
	  	  INITIAL_PACKAGES="${INITIAL_PACKAGES} irqbalance mmc-utils raspberrypi"
        ;;
    esac

  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual Machine

    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "proxmox" ] || \
       [ "$VM_TYPE" = "qemu" ]; then
      INITIAL_PACKAGES="${INITIAL_PACKAGES} qemu-guest-agent"
    fi

    if [ "$VM_TYPE" = "virtualbox" ]; then
      INITIAL_PACKAGES="${INITIAL_PACKAGES} virtualbox-guest-additions"
    fi

    if [ "$VM_TYPE" = "vmware" ]; then
      INITIAL_PACKAGES="${INITIAL_PACKAGES} open-vm-tools open-vm-tools-guestinfo open-vm-tools-timesync open-vm-tools-vix"
    fi
  fi
}


#
# Define the cloud-init DataSource(s) to enable for the relevant Cloud type
#
define_cloud_settings() {
  case $CLOUD_TYPE in
    generic )
      DATASOURCE_LIST="'AliYun','Azure','BigStep','ConfigDrive','DigitalOcean','E24Cloud','Ec2','Exoscale','GCE','Hetzner','IBMCloud','Oracle','RbxCloud','Scaleway','UpCloud','Vultr'"
      ;;
    aliyun )
      DATASOURCE_LIST="'AliYun'"
      ;;
    aws )
      DATASOURCE_LIST="'Ec2'"
      if [ "$IMAGE_ARCH" = "aarch64" ]; then
        CONSOLE_NAME="ttyAMA1"
      fi
      CONSOLE_TYPE="both"
      if [ "$CONSOLE_TYPE" = "serial" ] || \
         [ "$CONSOLE_TYPE" = "both" ]; then
        SERIAL_PORT_NUMBER="0"
        if [ "$IMAGE_ARCH" = "aarch64" ]; then
          SERIAL_PORT_NAME="ttyAMA${SERIAL_PORT_NUMBER}"
        else
          SERIAL_PORT_NAME="ttyS${SERIAL_PORT_NUMBER}"
        fi
      fi
      ;;
    azure )
      DATASOURCE_LIST="'Azure'"
      ;;
    bigstep )
      DATASOURCE_LIST="'Bigstep'"
      ;;
    brightbox )
      DATASOURCE_LIST="'Ec2'"
      ;;
    digitalocean )
      DATASOURCE_LIST="'DigitalOcean'"
      ;;
    e24 )
      DATASOURCE_LIST="'E24Cloud'"
      ;;
    exoscale )
      DATASOURCE_LIST="'Exoscale'"
      ;;
    google )
      DATASOURCE_LIST="'GCE'"
      ;;
    hetzner )
      DATASOURCE_LIST="'Ec2'"
      ;;
    hyperone )
      DATASOURCE_LIST="'RbxCloud'"
      ;;
    ibmcloud )
      DATASOURCE_LIST="'IBMCloud'"
      ;;
    oracle )
      DATASOURCE_LIST="'Oracle'"
      if [ "$IMAGE_ARCH" = "aarch64" ]; then
        CONSOLE_NAME="ttyAMA1"
      fi
      CONSOLE_TYPE="both"
      if [ "$CONSOLE_TYPE" = "serial" ] || \
         [ "$CONSOLE_TYPE" = "both" ]; then
        SERIAL_PORT_NUMBER="0"
        if [ "$IMAGE_ARCH" = "aarch64" ]; then
          SERIAL_PORT_NAME="ttyAMA${SERIAL_PORT_NUMBER}"
        else
          SERIAL_PORT_NAME="ttyS${SERIAL_PORT_NUMBER}"
        fi
      fi
      ;;
    rootbox )
      DATASOURCE_LIST="'RbxCloud'"
      ;;
    scaleway )
      DATASOURCE_LIST="'Scaleway'"
      ;;
    tencent )
      DATASOURCE_LIST="'ConfigDrive'"
      ;;
    upcloud )
      DATASOURCE_LIST="'UpCloud'"
      ;;
    vultr )
      DATASOURCE_LIST="'Vultr'"
      ;;
  esac
}


#
# Define entries for kernel command line modules list
#
define_cmdline_for_modules() {
  local MODULES_LIST

  MODULES_LIST="jitterentropy_rng"

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # Add modules entry for dm-crypt
    MODULES_LIST="$MODULES_LIST,dm-crypt"

    if [ "$REMOTE_UNLOCK" = "true" ]; then
      # Add network module(s) need for remote encryption unlock
      case $IMAGE_CLASS in
        cloud | vm )
          if [ "$IMAGE_CLASS" = "vm" ] && \
             [ "$VM_TYPE" = "vmware" ]; then
            MODULES_LIST="$MODULES_LIST,vmxnet3"
          else
            # virtio_pci is *needed* even though its not a dep of virtio_net
            MODULES_LIST="$MODULES_LIST,virtio_net,virtio_pci"
          fi
          ;;
        physical )
          if [ "$PHYSICAL_TYPE" = "pc" ] && \
             [ -n "${REMOTE_UNLOCK_NETWORK_MODULE+x}" ]; then
            MODULES_LIST="$MODULES_LIST,$REMOTE_UNLOCK_NETWORK_MODULE"
          else
            MODULES_LIST="$MODULES_LIST,e1000"
          fi
          ;;
      esac
      if [ "$IMAGE_DISABLE_IPV6" != "true" ]; then
        MODULES_LIST="$MODULES_LIST,ipv6"
      fi
    fi
  fi

  echo "$MODULES_LIST"
}


#
# Define the cloud-init DataSource(s) to enable for the relevant VM type
#
define_virtual_settings() {
  case $VM_TYPE in
    generic )
      DATASOURCE_LIST="'AltCloud','Opennebula','Openstack','NoCloud','OVF'"
      ;;
    opennebula )
      DATASOURCE_LIST="'Opennebula'"
      ;;
    openstack )
      DATASOURCE_LIST="'Openstack'"
      ;;
    libvirtd | proxmox | qemu )
      DATASOURCE_LIST="'NoCloud'"
      if { [ "$CONSOLE_TYPE" = "serial" ] || \
           [ "$CONSOLE_TYPE" = "both" ]; } && \
         { [ "$IMAGE_ARCH" = "armv7" ] || \
           [ "$IMAGE_ARCH" = "aarch64" ]; }; then
        SERIAL_PORT_NUMBER="0"
        SERIAL_PORT_NAME="ttyAMA${SERIAL_PORT_NUMBER}"
      fi
      ;;
    rhevm )
      DATASOURCE_LIST="'AltCloud'"
      ;;
    test )
      DATASOURCE_LIST="'NoCloud'"
      DATASOURCE_LIST="$DATASOURCE_LIST,'AliYun','Azure','BigStep','CloudSigma','CloudStack','DigitalOcean','Ec2','Exoscale','GCE','Hetzner','IBMCloud','Oracle','RbxCloud','Scaleway','SmartOS','UpCloud','Vultr'"
      DATASOURCE_LIST="$DATASOURCE_LIST,'AltCloud',ConfigDrive','MAAS','OpenNebula','OpenStack','OVF'"

      DATASOURCE_SETTINGS=$(printf %s\\n "Ec2:" "  timeout: 5")
      ;;
    virtualbox )
      DATASOURCE_LIST="'NoCloud'"
      ;;
    vmware )
      DATASOURCE_LIST="'OVF'"
      ;;
    vsphere )
      DATASOURCE_LIST="'AltCloud'"
      ;;
  esac
}


#
# Delete unnecessary users & groups
#
delete_users_groups() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Delete unnecessary users"
for unrequired_user in cyrus ftp games guest halt lp man news ntp operator \
            postmaster shutdown smmsp squid sync vpopmail xfs
do
  deluser \$unrequired_user 2> /dev/null
done

write_log "Delete unnecessary groups"
for unrequired_group in abuild audio cdrom cdrw floppy kvm tape video
do
  delgroup \$unrequired_group
done
EOF
}


#
# Disable most of the gettys normally configured to run
#
disable_extra_getty() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Disabling extra getty processes"
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/inittab /etc/inittab-orig

EOF
  fi

  if [ "$IMAGE_CLASS" = "cloud" ] || \
     [ "$IMAGE_CLASS" = "vm" ]; then
    # Only have 1 getty for cloud/virtual machines
    FIRST_GETTY_TO_DISABLE="2"
  else
    # Keep 2 gettys for physical machines
    FIRST_GETTY_TO_DISABLE="3"
  fi

  cat <<EOF >> "$RUN_SCRIPT"
sed -i -E -e 's|^tty([${FIRST_GETTY_TO_DISABLE}-6].*)|#tty\1|g' /etc/inittab
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/inittab-orig /etc/inittab \
    >> /chroot.log \
    || true
  rm /etc/inittab-orig
}
EOF
  fi
}


#
# Disable a specific kernel module
#
disable_kernel_module() {
  local MODULE_NAME=$1

  cat <<EOF >> "$RUN_SCRIPT"
	install ${MODULE_NAME} /bin/true
EOF
}


#
# Disable non-server specific kernel modules
#
disable_kernel_modules() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Disable non-server kernel modules"
EOF

  initialise_disable_kernel_modules "drivers"
  if [ "$IMAGE_CLASS" = "vm" ] && \
     { [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "qemu" ] || \
       [ "$VM_TYPE" = "virtualbox" ] || \
       [ "$VM_TYPE" = "vmware" ]; } then
    disable_kernel_module "evdev"
  fi
  disable_kernel_module "mousedev"

  if [ "$IMAGE_CLASS" != "physical" ] || \
     [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -eq 0 ]; then
    # Not a physical machine or not a Raspberry Pi
    disable_kernel_module "psmouse"
  fi

  if [ "$IMAGE_CLASS" = "cloud" ] || \
     [ "$IMAGE_CLASS" = "vm" ]; then
    disable_kernel_module "ac"
    disable_kernel_module "battery"
    disable_kernel_module "i2c-piix4"
    disable_kernel_module "ehci_pci"
    disable_kernel_module "ohci_pci"
    disable_kernel_module "uhci_pci"
    disable_kernel_module "usb_common"
    disable_kernel_module "usbcore"
    disable_kernel_module "xhci_pci"
  fi

  if [ "$IMAGE_CLASS" = "vm" ]; then

    disable_kernel_module "xen-scsiback"
    disable_kernel_module "xen-scsifront"

    #case $VM_TYPE in
    #  libvirt | qemu )
    #    disable_kernel_module "???"
    #    ;;
    #esac
  fi
  finish_disable_kernel_modules
}


#
# Download tarball of statically compiled apk tool
#
download_static_apk() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Downloading statically built APK tool"
wget \
  -q \
  -O $TMPDIR/apk-tools-${APK_STATIC_VERSION}-x86_64-linux.tar.gz \
  ${APK_STATIC_URL}/apk-tools-${APK_STATIC_VERSION}-x86_64-linux.tar.gz \
  2>> "\$LOGFILE"
tar \
  --extract \
  -C \$TMPDIR \
  -z \
  -f \$TMPDIR/apk-tools-${APK_STATIC_VERSION}-x86_64-linux.tar.gz \
  >> "\$LOGFILE"
rm -f $TMPDIR/apk-tools-${APK_STATIC_VERSION}-x86_64-linux.tar.gz
EOF
}


#
# Enable getty for serial console
#
enable_serial_console() {
  if [ "$DEBUG" = "true" ]; then

    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/inittab /etc/inittab-orig
EOF

    if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
      # GRUB
      cat <<'EOF' >> "$RUN_SCRIPT"

cp /etc/default/grub /etc/default/grub-orig
EOF
    elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
      # Syslinux
      cat <<'EOF' >> "$RUN_SCRIPT"

cp /etc/update-extlinux.conf /etc/update-extlinux.conf-orig
EOF
    fi

  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Enable serial console"
EOF

  cat <<EOF >> "$RUN_SCRIPT"
write_log "  Enabling getty on ${SERIAL_PORT_NAME} for serial console"
sed -i \
  -e 's|^[#]*ttyS0::.*$|${SERIAL_PORT_NAME}::respawn:/sbin/getty -L ${SERIAL_PORT_NAME} ${SERIAL_PORT_SPEED} vt100|g' \
  /etc/inittab
EOF

  if [ "$DEBUG" = "true" ]; then

    cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
  diff /etc/inittab-orig /etc/inittab \
    >> /chroot.log \
    || true
  rm /etc/inittab-orig
}
EOF

  fi

  if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
    # GRUB
    cat <<EOF >> "$RUN_SCRIPT"
write_log "  Configure GRUB serial command"
echo 'GRUB_SERIAL_COMMAND="serial --unit=${SERIAL_PORT_NUMBER} --speed=${SERIAL_PORT_SPEED}"' \
  >> /etc/default/grub
write_log "  Configure GRUB for serial console"
EOF

    if [ "$CONSOLE_TYPE" = "both" ]; then
      cat <<EOF >> "$RUN_SCRIPT"
echo 'GRUB_TERMINAL="serial console"' \
  >> /etc/default/grub
EOF
    else
      cat <<EOF >> "$RUN_SCRIPT"
echo 'GRUB_TERMINAL="serial"' \
  >> /etc/default/grub
EOF
    fi

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
  diff /etc/default/grub-orig /etc/default/grub \
    >> /chroot.log \
    || true
  rm /etc/default/grub-orig
}
EOF
    fi

  elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
    # Syslinux
    cat <<EOF >> "$RUN_SCRIPT"
write_log "  Configure Syslinux serial port and speed"
sed -i \
  -e "s|^serial_port=.*|serial_port=${SERIAL_PORT_NUMBER}|g" \
  -e "s|^serial_baud=.*|serial_baud=${SERIAL_PORT_SPEED}|g" \
  /etc/update-extlinux.conf
EOF

    if [ "$CONSOLE_TYPE" = "serial" ]; then
      cat <<EOF >> "$RUN_SCRIPT"
write_log "  Disable normal Syslinux console"
sed -i -e "s|^console=.*|console=0|g" \
  /etc/update-extlinux.conf
EOF
    fi

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
{
  # Debug
  diff /etc/update-extlinux.conf-orig /etc/update-extlinux.conf \
    >> /chroot.log \
    || true
  rm /etc/update-extlinux.conf-orig
}
EOF
    fi

  fi
}


#
# Finish disabling specific kernel modules
#
finish_disable_kernel_modules() {
  cat <<EOF >> "$RUN_SCRIPT"
	_SCRIPT_
EOF
}


#
# Complete adding entries to the specified /etc/mkinitfs/features.d/*.modules file
#
finish_initramfs_entry() {
  cat <<EOF >> "$RUN_SCRIPT"
	_SCRIPT_
EOF
}


#
# Prep for disabling a specific kernel modules
#
initialise_disable_kernel_modules() {
  local MODULE_SECTION=$1

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Disabling ${MODULE_SECTION} kernel modules"
cat <<-_SCRIPT_ >> /etc/modprobe.d/disable-${MODULE_SECTION}-modules.conf
EOF
}


#
# Prep adding entries to the specified /etc/mkinitfs/features.d/*.modules file
#
initialise_initramfs_entry() {
  local modules_file=$1

  cat <<EOF >> "$RUN_SCRIPT"
cat <<-_SCRIPT_ > /etc/mkinitfs/features.d/${modules_file}.modules
EOF
}


#
# Install additional packages
#
install_additional_packages() {
  cat <<EOF >> "$RUN_SCRIPT"

INITIAL_PACKAGES="$INITIAL_PACKAGES"
EOF

  cat <<'EOF' >> "$RUN_SCRIPT"
write_log "Install additional packages: \$INITIAL_PACKAGES"
apk add \$INITIAL_PACKAGES >> /chroot.log 2>&1
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  write_debug_log "Full installed packages list:"
  apk info | sort >> /chroot.log
}
EOF
  fi
}


#
# Install base Alpine system
#
install_alpine_base() {
  BASE_PACKAGES="alpine-base"
  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    BASE_PACKAGES="$BASE_PACKAGES efibootmgr efivar"
  fi

  # RPI alpine-base doesn't depend on mkinitfs so add it to list.
  if [ "$IMAGE_CLASS" = "physical" ] && \
     [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
    BASE_PACKAGES="$BASE_PACKAGES mkinitfs"
  fi

  # Define bootloader-related packages
  if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
    BOOTLOADER_PACKAGES="grub"
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      BOOTLOADER_PACKAGES="$BOOTLOADER_PACKAGES dosfstools grub-efi"
    else
      BOOTLOADER_PACKAGES="$BOOTLOADER_PACKAGES grub-bios"
    fi
    BASE_PACKAGES="$BASE_PACKAGES $BOOTLOADER_PACKAGES"
  elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
    BOOTLOADER_PACKAGES="syslinux"
    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      BOOTLOADER_PACKAGES="$BOOTLOADER_PACKAGES dosfstools"
    fi
    BASE_PACKAGES="$BASE_PACKAGES $BOOTLOADER_PACKAGES"
  elif [ "$IMAGE_CLASS" = "physical" ] && \
       [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then

    BOOTLOADER_PACKAGES="raspberrypi-bootloader raspberrypi-bootloader-cutdown"
    BASE_PACKAGES="$BASE_PACKAGES $BOOTLOADER_PACKAGES"
  else
    BOOTLOADER_PACKAGES="none"
  fi

  cat <<EOF >> "$RUN_SCRIPT"

write_log "Bootloader packages to be installed are: $BOOTLOADER_PACKAGES"

write_log "Install base Alpine (plus bootloader packages) inside chroot"
# shellcheck disable=SC2086
\$TMPDIR/apk-tools-${APK_STATIC_VERSION}/apk \
  --arch "${IMAGE_ARCH}" \
  --initdb \
  --allow-untrusted \
  --root \$CHROOT_DIRECTORY \
  --update-cache \
  add \
  ${BASE_PACKAGES} \
  >> "\$LOGFILE" 2>&1
RET_CODE=\$?
if [ \$RET_CODE != 0 ]; then
  write_log "Failure while installing base Alpine, error code: \$RET_CODE"
  exit 1
fi
EOF
}


#
# Install GRUB onto disk
#
install_grub() {
  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  write_debug_log "grub.cfg contents:"
  cat /boot/grub/grub.cfg \
    >> /chroot.log \
    || true
}
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    GRUB_OPTIONS="--verbose"
  else
    GRUB_OPTIONS=""
  fi
  GRUB_EFI_OPTIONS="--bootloader-id=alpine --efi-directory=/efi --no-nvram"

  GRUB_MODULES_LIST="acpi disk echo elf ext2 gzio linux loadenv minicmd normal probe search test video_colors video_fb"
  if [ "$IMAGE_ENCRYPTED" = "true" ] && \
     [ "$IMAGE_BOOTLOADER" = "grub" ] && \
     [ "$REMOTE_UNLOCK" != "true" ]; then
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST gcry_rijndael gcry_sha256"
    if [ "$IMAGE_LUKS_VERSION" = 1 ]; then
      GRUB_MODULES_LIST="$GRUB_MODULES_LIST luks"
    else
      GRUB_MODULES_LIST="$GRUB_MODULES_LIST luks2"
    fi
  fi
  if [ -n "${IMAGE_LVM_ROOTFS+x}" ]; then
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST lvm"
  fi
  if [ -n "${IMAGE_BOOTLOADER_PASSWORD_PROTECTED+x}" ] && \
     [ "$IMAGE_BOOTLOADER_PASSWORD_PROTECTED" = "true" ]; then
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST password_pbkdf2"
  fi
  if [ "$CONSOLE_TYPE" = "serial" ] || \
     [ "$CONSOLE_TYPE" = "both" ]; then
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST serial"
  fi

  if [ "$IMAGE_CLASS" = "physical" ] && \
     [ "$PHYSICAL_TYPE" = "pc" ]; then
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST ahci at_keyboard scsi usb usb_keyboard"
    if [ -z "${IMAGE_CPU_VENDOR+x}" ] || \
       [ "$IMAGE_CPU_VENDOR" = "amd" ]; then
      GRUB_MODULES_LIST="$GRUB_MODULES_LIST ohci"
    fi
    if [ -z "${IMAGE_CPU_VENDOR+x}" ] || \
       [ "$IMAGE_CPU_VENDOR" = "intel" ]; then
      GRUB_MODULES_LIST="$GRUB_MODULES_LIST uhci"
    fi
  elif [ "$IMAGE_CLASS" = "cloud" ] || \
       [ "$IMAGE_CLASS" = "virtual" ]; then
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST video_bochs"
  fi

  if [ "$IMAGE_ARCH" = "aarch64" ] && [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    GRUB_TARGET="arm64-efi"
    GRUB_OPTIONS="$GRUB_OPTIONS $GRUB_EFI_OPTIONS"
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST all_video efi_gop efifwsetup gfxterm part_gpt"
  elif [ "$IMAGE_ARCH" = "x86" ]; then
    GRUB_TARGET="i386-pc"
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST biosdisk part_msdos vga vga_text"
  elif [ "$IMAGE_ARCH" = "x86_64" ] && [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    GRUB_TARGET="i386-pc"
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST biosdisk part_msdos vga vga_text"
  else
    GRUB_TARGET="x86_64-efi"
    GRUB_OPTIONS="$GRUB_OPTIONS $GRUB_EFI_OPTIONS"
    GRUB_MODULES_LIST="$GRUB_MODULES_LIST all_video efi_gop efifwsetup gfxterm part_gpt"
  fi

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Installing GRUB bootloader"
grub-install \
  $GRUB_OPTIONS \
  --install-modules="$GRUB_MODULES_LIST" \
  --target=$GRUB_TARGET \
  \$LOOP_DEVICE \
  >> /chroot.log \
  2>&1
EOF

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

mkdir -p /efi/EFI/boot
EOF

    case $IMAGE_ARCH in
      aarch64 )
        EFI_ARCH_FILE_INSERT="aa64"
        ;;
      x86_64 )
        EFI_ARCH_FILE_INSERT="x64"
        ;;
    esac
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Creating UEFI default boot file"
cp /efi/EFI/alpine/grub${EFI_ARCH_FILE_INSERT}.efi \
  /efi/EFI/boot/boot${EFI_ARCH_FILE_INSERT}.efi
EOF
  fi
}


#
# Install relevant kernel package
#
install_kernel() {
  if [ "$IMAGE_CLASS" = "cloud" ] || \
     [ "$IMAGE_CLASS" = "vm" ]; then
    # Cloud or Virtual machine
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Installing kernel linux-virt"
apk add linux-virt >> /chroot.log 2>&1
EOF

  else
    # Physical machine
    if [ "$PHYSICAL_TYPE" = "pc" ]; then
      # PC
      cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Installing kernel linux-lts"
apk add linux-lts linux-firmware-none >> /chroot.log 2>&1
EOF

    elif [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
      # Raspberry Pi
      case $PHYSICAL_TYPE in
        rpi2 | rpi3 )
          if [ "$IMAGE_ARCH" = "armv7" ]; then
            RPI_KERNEL="linux-rpi2"
          else
            RPI_KERNEL="linux-rpi"
          fi
          ;;
        rpi4 )
          RPI_KERNEL="linux-rpi4"
          ;;
      esac
      cat <<EOF >> "$RUN_SCRIPT"

write_log "Installing kernel $RPI_KERNEL"
apk add $RPI_KERNEL >> /chroot.log 2>&1
EOF

    fi
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

KERNEL_VERSION=\$(get_kernel_version)
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_debug_log "Kernel is: \$KERNEL_VERSION"
EOF
  fi
}


#
# Install Syslinux onto disk
#
install_syslinux() {
 if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /boot/extlinux.conf /boot/extlinux.conf-orig
write_debug_log "/boot/extlinux.conf contents at start:"
cat /boot/extlinux.conf >> /chroot.log
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Installing Syslinux"
EOF

  if [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
    # BIOS
    cat <<'EOF' >> "$RUN_SCRIPT"
write_log "  Installing BIOS MBR"
dd \
  bs=440 \
  count=1 \
  conv=notrunc \
  if=/usr/share/syslinux/mbr.bin \
  of="$LOOP_DEVICE" \
  >> /chroot.log 2>&1
write_log "  Installing Syslinux files in /boot directory"
extlinux --install /boot/ >> /chroot.log 2>&1
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
write_debug_log "/boot/extlinux.conf contents after extlinux --install:"
cat /boot/extlinux.conf >> /chroot.log
EOF
    fi

  else
    # UEFI
    cat <<'EOF' >> "$RUN_SCRIPT"
###write_log "  Installing Syslinux files in EFI/boot"
###mkdir -p /boot/EFI/BOOT
###cp \
###  /usr/share/syslinux/efi64/syslinux.efi \
###  /boot/EFI/boot/bootx64.efi
###cp \
###  /boot/initramfs-* \
###  /boot/vmlinuz-* \
###  /usr/share/syslinux/efi64/ldlinux.e64 \
###  /boot/EFI/alpine/*.c32 \
###  /boot/EFI/boot/

write_log "  Installing Syslinux UEFI files in EFI/BOOT aka /boot"
cp \
  /usr/share/syslinux/efi64/syslinux.efi \
  /boot/bootx64.efi
rm \
  /boot/*.c32
cp \
  /usr/share/syslinux/efi64/syslinux.c32 \
  /usr/share/syslinux/efi64/ldlinux.e64 \
  /usr/share/syslinux/efi64/libcom32.c32 \
  /usr/share/syslinux/efi64/libutil.c32 \
  /usr/share/syslinux/efi64/mboot.c32 \
  /usr/share/syslinux/efi64/menu.c32 \
  /usr/share/syslinux/efi64/vesamenu.c32 \
  /boot/
EOF

    if [ "$DEBUG" = "true" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
write_debug_log "  After installing Syslinux UEFI files"
ls -ltrR /boot/ >> /chroot.log
write_debug_log "/boot/extlinux.conf contents:"
cat /boot/extlinux.conf >> /chroot.log

EOF
    fi

  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
write_debug_log "  Before update-extlinux"
ls -ltrR /boot/ >> /chroot.log

EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
write_log "  Updating extlinux.conf file"
update-extlinux --verbose --warn-only >> /chroot.log 2>&1
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
write_debug_log "/boot/extlinux.conf contents after update-extlinux:"
cat /boot/extlinux.conf >> /chroot.log

EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
write_log "  Fix permissions on extlinux.conf files"
chmod g=,o= /boot/extlinux.conf*
EOF

  if [ "$DEBUG" = "true" ]; then

    if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
      # UEFI
      cat <<'EOF' >> "$RUN_SCRIPT"

write_debug_log "/boot/extlinux.conf contents after everything:"
cat /boot/extlinux.conf >> /chroot.log
write_debug_log "  /boot contents:"
ls -ltrR /boot/ >> /chroot.log
EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"

diff /boot/extlinux.conf-orig /boot/extlinux.conf \
  >> /chroot.log \
  || true
rm /boot/extlinux.conf-orig

write_debug_log "  extlinux.conf contents:"
cat /boot/extlinux.conf >> /chroot.log

EOF
  fi
}


#
# Create relevant filesystems for the disk image and mount these
# inside the chroot directory.
#
format_and_mount_fs() {
	cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Formatting and mounting filesystems"
EOF

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    # Machines booting via UEFI have ESP partition
    cat <<EOF >> "$RUN_SCRIPT"

UEFI_PART_DEVICE="\${LOOP_DEVICE}p${UEFI_PART_NUM}"

write_log "  Formatting FAT32 filesystem on ESP partition"
mkfs.fat -F32 -n SYSTEM_EFI "\$UEFI_PART_DEVICE" >> "\$LOGFILE" 2>&1
EOF

    if [ "$IMAGE_BOOT_REFERENCE" = "uuid" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"
ESP_FS_UUID="$(get_uuid_from_device "$UEFI_PART_DEVICE")"
EOF
    fi
  fi

  if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

BOOT_PART_DEVICE="\${LOOP_DEVICE}p${BOOT_PART_NUM}"
EOF

    if [ "$IMAGE_CLASS" = "physical" ] && \
       [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Formatting FAT16 filesystem on RPI boot partition"
mkfs.fat -F16 -s 2 -S 512 -n BOOT "$BOOT_PART_DEVICE" \
	>> "$LOGFILE" 2>&1
EOF

      if [ "$IMAGE_BOOT_REFERENCE" = "uuid" ]; then
        cat <<'EOF' >> "$RUN_SCRIPT"
BOOT_FS_UUID="$(get_uuid_from_device "$BOOT_PART_DEVICE")"
EOF
      fi
    else
      # Ensure EXT4 inode size is 256 bytes rather than 128 in order to
      # avoid Year 2038 problems/warning.
      bootfs_options="-I 256"
      if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
        # Syslinux requires 64bit flag be disabled for boot filesystem
        bootfs_options="$bootfs_options -O ^64bit"
      fi

      cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting Ext4 filesystem on boot partition"
# shellcheck disable=SC2086
mkfs.ext4 -q -L $DEFAULT_BOOTFS_LABEL $bootfs_options \
  "\$BOOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF

      if [ "$IMAGE_BOOT_REFERENCE" = "uuid" ]; then
        cat <<'EOF' >> "$RUN_SCRIPT"
BOOT_FS_UUID="$(get_uuid_from_device "$BOOT_PART_DEVICE")"
EOF
      fi
    fi
  fi

  if [ "$IMAGE_CLASS" = "physical" ]; then
    cat <<EOF >> "$RUN_SCRIPT"

CIDATA_PART_DEVICE="\${LOOP_DEVICE}p${CIDATA_PART_NUM}"

write_log "  Formatting FAT16 filesystem on cidata partition"
mkfs.fat -F16 -s 1 -S 512 -n CIDATA "\$CIDATA_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

ROOT_PART_DEVICE="/dev/mapper/cryptroot"
EOF
  else
    cat <<EOF >> "$RUN_SCRIPT"

ROOT_PART_DEVICE="\${LOOP_DEVICE}p${ROOT_PART_NUM}"
EOF
  fi

  # Ensure EXT4 inode size is 256 bytes rather than 128 in order to avoid
  # Year 2038 problems/warning.
  rootfs_options="-I 256"
  if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
    # Syslinux requires 64bit flag be disabled for boot filesystem
    rootfs_options="$rootfs_options -O ^64bit"
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    ROOT_ON="LUKS device"
  else
	  ROOT_ON="root partition"
  fi
  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting Ext4 filesystem on ${ROOT_ON}"
# shellcheck disable=SC2086
mkfs.ext4 -q -L $DEFAULT_ROOTFS_LABEL $rootfs_options "\$ROOT_PART_DEVICE" \
  >> "\$LOGFILE" 2>&1
EOF

  if [ "$IMAGE_BOOT_REFERENCE" = "uuid" ] && \
     [ "$IMAGE_ENCRYPTED" = "false" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
ROOT_FS_UUID="$(get_uuid_from_device "$ROOT_PART_DEVICE")"
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Mounting root filesystem onto $CHROOT_DIRECTORY"
mkdir -p "$CHROOT_DIRECTORY"
mount -o private "$ROOT_PART_DEVICE" "$CHROOT_DIRECTORY" >> "$LOGFILE" 2>&1
EOF

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Mounting ESP filesystem onto $CHROOT_DIRECTORY/efi"
mkdir -p "$CHROOT_DIRECTORY"/efi
mount -o private "$UEFI_PART_DEVICE" "$CHROOT_DIRECTORY"/efi \
  >> "$LOGFILE" 2>&1
EOF
  fi

  if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Mounting boot filesystem onto $CHROOT_DIRECTORY/boot"
mkdir -p "$CHROOT_DIRECTORY"/boot
mount -o private "$BOOT_PART_DEVICE" "$CHROOT_DIRECTORY"/boot \
  >> "$LOGFILE" 2>&1
EOF
  elif [ "$IMAGE_BOOT_TYPE" = "uefi" ] && \
       [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
    # When using Syslinux with UEFI then, as kernel & initramfs files need
    # to be in EFI/BOOT directory of ESP partition, EFI/BOOT directory of
    # ESP partition is bind-mounted to /boot. This ensures that kernel,
    # initramfs, and extlinux.conf files are in ESP partition.
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Bind mounting ESP filesystem's EFI/boot onto $CHROOT_DIRECTORY/boot"
mkdir -p "$CHROOT_DIRECTORY"/efi/EFI/boot
mkdir -p "$CHROOT_DIRECTORY"/boot
mount -t none -o bind "$CHROOT_DIRECTORY"/efi/EFI/boot \
  "$CHROOT_DIRECTORY"/boot >> "$LOGFILE" 2>&1
EOF
  fi

  if [ "$IMAGE_CLASS" = "physical" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Mounting cloud-init YAML filesystem onto $CHROOT_DIRECTORY/cidata"
mkdir -p "$CHROOT_DIRECTORY"/cidata
mount -o private "$CIDATA_PART_DEVICE" "$CHROOT_DIRECTORY"/cidata >> "$LOGFILE"
EOF
  fi
}


#
# Parse options given on the command line
#
parse_cli_options() {
  IMAGE_DISABLE_IPV4=false
  IMAGE_DISABLE_IPV6=false

  if ! CLI=$(getopt -s sh \
    -o h \
    -l apk-static-url:,apk-static-version:,arch:,boot-by-label,bootchart,bootloader:,boottype:,chroot-directory:,cloud:,cpu-vendor:,debug,disable-normal-console,disable-serial-console,disable-unnecessary-modules,ethernet-module:,encrypt,encrypt-passphrase:,encrypt-remote-unlock,graphics-vendor:,help,image-filename:,images-directory:,ipv4only,ipv6only,keymap:,local-repo:,local-repo-sig-file:,locale:,lvm,mirror:,password:,physical:,ramdisk-directory:,release:,remote-unlock-network-module:,remote-unlock-ssh-port:,remote-unlock-static-gateway:,remote-unlock-static-interface:,remote-unlock-static-ip:,remote-unlock-static-netmask:,script-filename:,ssh-public-key:,use-ramdisk,username:,virtual: \
    -n "$0" -- "$@"); then
    echo
    echo "Terminating..." >&2
    echo
    exit 2
  fi

  eval set -- "$CLI"

  while true; do
    case "$1" in
      --apk-static-url )
        APK_STATIC_URL="$2"
        shift 2
        ;;
      --apk-static-version )
        APK_STATIC_VERSION="$2"
        shift 2
        ;;
      --arch )
        case $2 in
          aarch64 | armv7 | x86 | x86_64 )
            IMAGE_ARCH=$2
            ;;
          * )
            echo
            echo "Unknown arch!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --boot-by-label )
        IMAGE_BOOT_REFERENCE="label"
        shift
        ;;
      --bootchart )
        IMAGE_BOOTCHART="true"
        shift
        ;;
      --bootloader )
        IMAGE_BOOTLOADER="$2"
        shift 2
        ;;
      --boottype )
        case $2 in
          bios | none | uefi )
            IMAGE_BOOT_TYPE=$2
            ;;
          * )
            echo
            echo "Unknown boot type, valid values are 'bios', 'none', and 'uefi'"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --chroot-directory )
        CHROOT_DIRECTORY="$2"
        shift 2
        ;;
      --cloud )
        IMAGE_CLASS="cloud"
        case $2 in
          aliyun | aws | azure | bigstep | brightbox | digitalocean | e24 | exoscale | generic | google | hetzner | hyperone | ibmcloud | oracle | rootbox | scaleway | tencent | upcloud | vultr )
            CLOUD_TYPE=$2
            ;;
          *)
            echo
            echo "Unknown cloud type!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --cpu-vendor )
        IMAGE_CPU_VENDOR="$2"
        shift 2
        ;;
      --debug )
        DEBUG=true
        shift
        ;;
      --disable-normal-console )
        CONSOLE_TYPE="serial"
        shift
        ;;
      --disable-serial-console )
        CONSOLE_TYPE="normal"
        shift
        ;;
      --disable-unnecessary-modules )
        DISABLE_UNNECESSARY_MODULES="true"
        shift
        ;;
      --ethernet-module )
        IMAGE_ETHERNET_MODULE="$2"
        shift 2
        ;;
      --encrypt )
        IMAGE_ENCRYPTED=true
        shift
        ;;
      --encrypt-passphrase )
        IMAGE_ENCRYPTION_PASSPHRASE="$2"
        shift 2
        ;;
      --encrypt-remote-unlock )
        IMAGE_ENCRYPTED=true
        REMOTE_UNLOCK=true
        shift
        ;;
      --graphics-vendor )
        IMAGE_GRAPHICS_VENDOR="$2"
        shift 2
        ;;
      -h | --help )
        usage
        exit 0
        ;;
      --image-filename )
        IMAGE_FILENAME="$2"
        shift 2
        ;;
      --images-directory )
        IMAGES_DIRECTORY="$2"
        shift 2
        ;;
      --ipv4only )
        IMAGE_DISABLE_IPV4=false
        IMAGE_DISABLE_IPV6=true
        shift
        ;;
      --ipv6only )
        IMAGE_DISABLE_IPV4=true
        IMAGE_DISABLE_IPV6=false
        shift
        ;;
      --keymap )
        IMAGE_KEYMAP="$2"
        shift 2
        ;;
      --local-repo )
        LOCAL_ALPINE_REPOSITORY="$2"
        shift 2
        ;;
      --local-repo-sig-file )
        LOCAL_REPO_SIGNATURE_FILE="$2"
        shift 2
        ;;
      --locale )
        IMAGE_LOCALE="$2"
        shift 2
        ;;
      --lvm )
        IMAGE_LVM_ROOTFS=true
        shift
        ;;
      --mirror )
        ALPINE_MIRROR_SITE="$2"
        shift 2
        ;;
      --password )
        IMAGE_DEFAULT_USER_PASSWORD="$2"
        shift 2
        ;;
      --physical )
        IMAGE_CLASS="physical"
        case $2 in
          pc | rpi2 | rpi3 | rpi4 )
            PHYSICAL_TYPE=$2
            ;;
          * )
            echo
            echo "Unknown physical machine type!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --ramdisk-directory )
        RAMDISK_DIRECTORY="$2"
        shift 2
        ;;
      --release )
        case $2 in
          3.13 | 3.14 )
            IMAGE_ALPINE_RELEASE=v$2
            ;;
          edge )
            IMAGE_ALPINE_RELEASE=$2
            ;;
          * )
            echo
            echo "Unknown or unsupported Alpine release!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      --remote-unlock-network-module )
        REMOTE_UNLOCK_NETWORK_MODULE="$2"
        shift 2
        ;;
      --remote-unlock-ssh-port )
        REMOTE_UNLOCK_SSH_PORT="$2"
        shift 2
        ;;
      --remote-unlock-static-gateway )
        REMOTE_UNLOCK_STATIC_GATEWAY="$2"
        shift 2
        ;;
      --remote-unlock-static-interface )
        REMOTE_UNLOCK_STATIC_INTERFACE="$2"
        shift 2
        ;;
      --remote-unlock-static-ip )
        REMOTE_UNLOCK_STATIC_IP="$2"
        shift 2
        ;;
      --remote-unlock-static-netmask )
        REMOTE_UNLOCK_STATIC_NETMASK="$2"
        shift 2
        ;;
      --script-filename )
        SCRIPT_FILENAME=$2
        shift 2
        ;;
      --ssh-public-key )
        if [ -f "$2" ]; then
          SSH_PUBLIC_KEY=$(cat "$2")
        else
          echo
          echo "SSH keyfile $2 not found!"
          echo
          exit 2
        fi
        shift 2
        ;;
      --use-ramdisk )
        USE_RAMDISK=true
        shift
        ;;
      --username )
        IMAGE_DEFAULT_USERNAME=$2
        shift 2
        ;;
      --virtual )
        IMAGE_CLASS="vm"
        case $2 in
          generic | hyperv | libvirtd | proxmox | qemu | virtualbox | vmware )
            VM_TYPE=$2
            ;;
          * )
            echo
            echo "Unknown virtual machine type!"
            echo
            exit 2
            ;;
        esac
        shift 2
        ;;
      -- )
        shift
        break
        ;;
    esac
  done
}


#
# Partition the disk image for booting via BIOS
#
partition_bios() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Partitioning disk image for BIOS"

write_debug_log "  Creating MSDOS disk label"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME mklabel msdos \
  >> "\$LOGFILE" 2>&1
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # Disk encryption

    if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
      # When using Syslinux with encrypted rootfs or when using remote
      # unlock (whether with Grub or Syslinux) we need to create a separate
      # boot partition which will be unencrypted.
      BOOT_PART_NUM=1
      BOOT_PART_START="0%"
      BOOT_PART_END="${BOOT_PART_SIZE}MiB"

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${BOOT_PART_SIZE}MiB boot partition with boot flag on"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${BOOT_PART_START} "${BOOT_PART_END}" \
  set $BOOT_PART_NUM boot on \
  >> "\$LOGFILE" 2>&1
EOF

      if [ "$IMAGE_CLASS" = "physical" ]; then
        CIDATA_PART_NUM=2
        CIDATA_PART_START="${BOOT_PART_SIZE}MiB"
        CIDATA_PART_END="$((BOOT_PART_SIZE+CIDATA_PART_SIZE))MiB"

        cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$CIDATA_PART_START" ${CIDATA_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

        LUKS_PART_NUM=3
        LUKS_PART_START="$((BOOT_PART_SIZE+CIDATA_PART_SIZE))MiB"
        LUKS_PART_END="100%"
      else
        LUKS_PART_NUM=2
        LUKS_PART_START="${BOOT_PART_SIZE}MiB"
        LUKS_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating LUKS partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$LUKS_PART_START" ${LUKS_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF
    else
      # GRUB and no remote unlock enabled

      if [ "$IMAGE_CLASS" = "physical" ]; then
        CIDATA_PART_NUM=1
        CIDATA_PART_START="0%"
        CIDATA_PART_END="${CIDATA_PART_SIZE}MiB"

        cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} ${CIDATA_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

        LUKS_PART_NUM=2
        LUKS_PART_START="${CIDATA_PART_SIZE}MiB"
        LUKS_PART_END="100%"

      else
        LUKS_PART_NUM=1
        LUKS_PART_START="0%"
        LUKS_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating LUKS partition with boot flag on"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${LUKS_PART_START} ${LUKS_PART_END} \
  set $LUKS_PART_NUM boot on \
  >> "\$LOGFILE" 2>&1
EOF
    fi

  else
    # No disk encryption

    if [ "$IMAGE_CLASS" = "physical" ]; then
      CIDATA_PART_NUM=1
      CIDATA_PART_START="0%"
      CIDATA_PART_END="${CIDATA_PART_SIZE}MiB"

      cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} ${CIDATA_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

      ROOT_PART_NUM=2
      ROOT_PART_START="${CIDATA_PART_SIZE}MiB"
      ROOT_PART_END="100%"
    else
      ROOT_PART_NUM=1
      ROOT_PART_START="0%"
      ROOT_PART_END="100%"
    fi

    cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating root partition with boot flag on"
parted --machine --script --align=optimal "\$IMAGE_FULL_FILENAME" \
  unit MiB \
  mkpart primary ${ROOT_PART_START} ${ROOT_PART_END} \
  set $ROOT_PART_NUM boot on \
  >> "\$LOGFILE" 2>&1
EOF
  fi
}


#
# Partition for Raspberry Pi use
#
partition_rpi() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Partitioning disk image for Raspberry Pi"

write_debug_log "  Creating MSDOS disk label"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME mklabel msdos \
  >> "\$LOGFILE" 2>&1
EOF

  BOOT_PART_NUM="1"
  BOOT_PART_START="0%"
  BOOT_PART_END="${BOOT_PART_SIZE}MiB"

  # Create partition for RPI built-in bootloader
  cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${BOOT_PART_SIZE}MiB boot partition with boot flag on"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${BOOT_PART_START} "${BOOT_PART_END}" \
  set $BOOT_PART_NUM lba on \
  >> "\$LOGFILE" 2>&1
EOF

  CIDATA_PART_NUM="2"
  CIDATA_PART_START="${BOOT_PART_SIZE}MiB"
  CIDATA_PART_END="$((BOOT_PART_SIZE+CIDATA_PART_SIZE))MiB"

  # Create partition for cloud-init use
  cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$CIDATA_PART_START" "${CIDATA_PART_END}" \
  >> "\$LOGFILE" 2>&1
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # Disk encryption
    LUKS_PART_NUM=3
    LUKS_PART_START="$((BOOT_PART_SIZE+CIDATA_PART_SIZE))MiB"
    LUKS_PART_END="100%"

    cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating LUKS partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$LUKS_PART_START" ${LUKS_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF
  else
    # No disk encryption
    ROOT_PART_NUM="3"
    ROOT_PART_START="$((BOOT_PART_SIZE+CIDATA_PART_SIZE))MiB"
    ROOT_PART_END="100%"

    cat <<EOF >> "$RUN_SCRIPT"
write_debug_log "  Creating root parition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "$ROOT_PART_START" ${ROOT_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF
  fi
}


# 
# Partition the disk image for booting via UEFI
#
partition_uefi() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Partitioning disk image for UEFI"

write_debug_log "  Creating GPT disk label"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME mklabel gpt \
  >> "\$LOGFILE" 2>&1
EOF

  UEFI_PART_NUM=1
  UEFI_PART_START="0%"
  UEFI_PART_END="${UEFI_PART_SIZE}MiB"

  # Create EFI partition
  cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating ${UEFI_PART_SIZE}MiB ESP partition"
parted --machine --script --align optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary fat32 ${UEFI_PART_START} ${UEFI_PART_END} \
  set $UEFI_PART_NUM esp on \
  >> "\$LOGFILE" 2>&1
EOF

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    # Disk encryption

    if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
      # When using remote unlock with GRUB we need to create a separate boot
      # partition which will be unencrypted. This is not needed for Syslinux
      # as in that case the EFI partition contains the boot files.
      BOOT_PART_NUM=2
      BOOT_PART_START="${UEFI_PART_END}"
      BOOT_PART_END="$((UEFI_PART_SIZE+BOOT_PART_SIZE))MiB"

      cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating ${BOOT_PART_SIZE}MiB boot partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${BOOT_PART_START} "${BOOT_PART_END}" \
  >> "\$LOGFILE" 2>&1
EOF

      if [ "$IMAGE_CLASS" = "physical" ]; then
        CIDATA_PART_NUM=3
        CIDATA_PART_START="${BOOT_PART_END}"
        CIDATA_PART_END="$((UEFI_PART_SIZE+BOOT_PART_SIZE+CIDATA_PART_SIZE))MiB"

        cat <<EOF >> "$RUN_SCRIPT"

# shellcheck disable=SC2003
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} "${CIDATA_PART_END}" \
  >> "\$LOGFILE" 2>&1
EOF

        LUKS_PART_NUM=4
        LUKS_PART_START="${CIDATA_PART_END}"
        LUKS_PART_END="100%"
      else
        LUKS_PART_NUM=3
        LUKS_PART_START="${BOOT_PART_END}"
        LUKS_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating LUKS partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${LUKS_PART_START} ${LUKS_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF

    else
      if [ "$IMAGE_CLASS" = "physical" ]; then
        CIDATA_PART_NUM=2
        CIDATA_PART_START="${UEFI_PART_END}"
        CIDATA_PART_END="$((UEFI_PART_SIZE+CIDATA_PART_SIZE))MiB"

        cat <<EOF >> "$RUN_SCRIPT"

# shellcheck disable=SC2003
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} "${CIDATA_PART_END}" \
  >> "\$LOGFILE" 2>&1
EOF

        LUKS_PART_NUM=3
        LUKS_PART_START="${CIDATA_PART_END}"
        LUKS_PART_END="100%"
      else
        LUKS_PART_NUM=2
        LUKS_PART_START="${UEFI_PART_END}"
        LUKS_PART_END="100%"
      fi

      cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating LUKS partition"
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${LUKS_PART_START} ${LUKS_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF
    fi
  else
    # No disk encryption
    if [ "$IMAGE_CLASS" = "physical" ]; then
      CIDATA_PART_NUM=2
      CIDATA_PART_START="${UEFI_PART_END}"
      CIDATA_PART_END="$((UEFI_PART_SIZE+CIDATA_PART_SIZE))MiB"

      cat <<EOF >> "$RUN_SCRIPT"

# shellcheck disable=SC2003
write_debug_log "  Creating ${CIDATA_PART_SIZE}MiB cidata partition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary ${CIDATA_PART_START} "${CIDATA_PART_END}" \
  >> "\$LOGFILE" 2>&1
EOF

      ROOT_PART_NUM=3
      ROOT_PART_START="${CIDATA_PART_END}"
      ROOT_PART_END="100%"
    else
      ROOT_PART_NUM=2
      ROOT_PART_START="${UEFI_PART_END}"
      ROOT_PART_END="100%"
    fi

    cat <<EOF >> "$RUN_SCRIPT"

write_debug_log "  Creating root partition"
# shellcheck disable=SC2003
parted --machine --script --align=optimal \$IMAGE_FULL_FILENAME \
  unit MiB \
  mkpart primary "${ROOT_PART_START}" ${ROOT_PART_END} \
  >> "\$LOGFILE" 2>&1
EOF
  fi
}


#
# Create the /etc/crypttab file
#
setup_crypttab() {
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Creating /etc/crypttab"
EOF

  if [ "$IMAGE_BOOTLOADER" = "syslinux" ] || \
     [ "$REMOTE_UNLOCK" = "true" ]; then
    # unlock via typed passphrase
    cat <<'EOF' >> "$RUN_SCRIPT"
echo "cryptroot UUID=${LUKS_PART_UUID} none luks" > /etc/crypttab
EOF
  else
    # unlock via keyfile
    cat <<'EOF' >> "$RUN_SCRIPT"
echo "cryptroot UUID=${LUKS_PART_UUID} /crypto_keyfile.bin luks" > /etc/crypttab
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
write_debug_log "    /etc/crypttab contents:"
cat /etc/crypttab >> /chroot.log
EOF
  fi
}


#
# Create Dropbear authorized_keys file
#
setup_dropbear_authorized_keys() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Setup Dropbear authorized_keys file"
echo $SSH_PUBLIC_KEY > /etc/dropbear/authorized_keys
chown root:root /etc/dropbear/authorized_keys
chmod 600 /etc/dropbear/authorized_keys
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
write_debug_log "  Dropbear authorized_keys contents:"
cat /etc/dropbear/authorized_keys >> "$LOGFILE"
EOF
  fi
}


#
# Configure modules to be loaded upon boot
#
setup_etc_modules() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Setup /etc/modules"
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/modules /etc/modules-orig

EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
cat <<-_SCRIPT_ > /etc/modules
	af_packet
EOF

  if [ "$IMAGE_DISABLE_IPV6" != "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"
	ipv6
EOF
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

	# LUKS
	dm-crypt
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

	# Used by rngd
	jitterentropy_rng
EOF

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Cloud machine
    cat <<'EOF' >> "$RUN_SCRIPT"

	# Cloud-specific modules
	virtio-rng
EOF
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Virtual machine
    if [ "$VM_TYPE" = "libvirtd" ] || \
       [ "$VM_TYPE" = "proxmox" ] || \
       [ "$VM_TYPE" = "qemu" ] || \
       [ "$VM_TYPE" = "generic" ]; then
      cat <<'EOF' >> "$RUN_SCRIPT"

	# VM-specific modules
	ptp_kvm
	virtio-rng
EOF
    fi

    cat <<'EOF' >> "$RUN_SCRIPT"
	_SCRIPT_
EOF

  else
    # Physical machine
    cat <<'EOF' >> "$RUN_SCRIPT"
	_SCRIPT_
EOF
  fi

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff \
    /etc/modules-orig \
    /etc/modules \
    >> /chroot.log \
    || true
  rm /etc/modules-orig
}
EOF
  fi
}


#
# Setup the LUKS device
#
setup_luks_device() {
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Setting up LUKS device"
LUKS_DEVICE="\${LOOP_DEVICE}p${LUKS_PART_NUM}"
EOF
  if [ "$IMAGE_ALPINE_RELEASE" = "v3.13" ]; then
    IMAGE_LUKS_VERSION="1"
  else
    IMAGE_LUKS_VERSION="1"
    ###IMAGE_LUKS_VERSION="2"
  fi

  cat <<EOF >> "$RUN_SCRIPT"

write_log "  Formatting partition as LUKS version ${IMAGE_LUKS_VERSION}"
echo "\$ENCRYPTION_PASSPHRASE" | \
  cryptsetup \
    -q \
    luksFormat \
      --cipher aes-xts-plain64 \
      --hash sha256 \
      --key-size 512 \
      --pbkdf pbkdf2 \
      --type luks$IMAGE_LUKS_VERSION \
    "\$LUKS_DEVICE" \
  >> "\$LOGFILE"
EOF

  if [ "$IMAGE_BOOTLOADER" = "grub" ] && \
     [ "$REMOTE_UNLOCK" != "true" ]; then
    # When bootloader is GRUB and not enabling Remote SSH Unlock, create
    # keyfile - this will be placed in the initramfs and used to unlock the
    # rootfs - this prevents being prompted for passphrase twice, once by
    # GRUB and then again by initramfs.
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Creating keyfile for LUKS"
dd \
  bs=512 \
  count=4 \
  if=/dev/random \
  of=crypto_keyfile.bin \
  iflag=fullblock \
  >> "\$LOGFILE" 2>&1

write_log "  Adding keyfile to LUKS device"
echo "\$ENCRYPTION_PASSPHRASE" | \
  cryptsetup \
    luksAddKey \
    "\$LUKS_DEVICE" \
    ./crypto_keyfile.bin \
  >> "\$LOGFILE"

write_log "  Opening LUKS device"
cryptsetup \
  open \
    --type luks$IMAGE_LUKS_VERSION \
    --key-file ./crypto_keyfile.bin \
  "\$LUKS_DEVICE" \
  cryptroot
EOF
  else
    # Remote unlock enabled, use default passphrase to open
    cat <<EOF >> "$RUN_SCRIPT"

write_log "  Opening LUKS device"
echo "\$ENCRYPTION_PASSPHRASE" | \
  cryptsetup \
    open \
      --type luks$IMAGE_LUKS_VERSION \
    "\$LUKS_DEVICE" \
    cryptroot \
    -
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
LUKS_PART_UUID=$(get_uuid_from_device "$LUKS_DEVICE")
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Show LUKS device details"
cryptsetup luksDump "$LUKS_DEVICE" >> "$LOGFILE"
EOF
  fi
}


#
# Change the default OpenSSH server config to be more secure
#
tighten_sshd_configuration() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "  Tighten the SSH server configuration"
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
cp /etc/conf.d/sshd /etc/conf.d/sshd-orig
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "    Only generate ED25519 & 3072bit RSA host keys"
sed -i \
  -e 's/^#key_types_to_generate=.*$/key_types_to_generate="ed25519 rsa"/' \
  -e 's/^#rsa_bit_size=.*$/rsa_bit_size="3072"/' \
  /etc/conf.d/sshd
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/conf.d/sshd-orig /etc/conf.d/sshd \
  >> /chroot.log \
  || true
  rm /etc/conf.d/sshd-orig

  cp /etc/ssh/sshd_config /etc/ssh/sshd_config-orig
}
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"

# Configure sshd to:
#   - only use ED25519 & RSA host keys
#   - prevent root logins
#   - prevent password-based logins
#   - enable PAM
write_log "    Prevent root login, prevent password logins"
sed -i \
  -e 's|^#HostKey /etc/ssh/ssh_host_ed25519_key$|HostKey /etc/ssh/ssh_host_ed25519_key|' \
  -e 's|^#HostKey /etc/ssh/ssh_host_rsa_key$|HostKey /etc/ssh/ssh_host_rsa_key|' \
  -e 's|^#PermitRootLogin .*$|PermitRootLogin no|' \
  -e 's|^#PasswordAuthentication .*$|PasswordAuthentication no|' \
  -e 's|^#UsePAM .*$|UsePAM yes|' \
  /etc/ssh/sshd_config
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  diff /etc/ssh/sshd_config-orig /etc/ssh/sshd_config \
    >> /chroot.log \
    || true
  rm /etc/ssh/sshd_config-orig
}
EOF
  fi
}


#
# Upgrade Alpine packages
#
update_upgrade_packages() {
  cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Updating package list"
apk update >> /chroot.log

write_log "Upgrading base packages if necessary"
apk upgrade >> /chroot.log
EOF

  if [ "$DEBUG" = "true" ]; then
    cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
apk info | sort > /base-packages.list
EOF
  fi
}


#
# Help text
#
usage() {
  echo "Usage: $0 [ options ]"
  echo
  echo "When called with no options is equivalent to"
  echo "'--arch x86_64 --release edge --bootloader syslinux -virtual qemu'."
  echo
  echo "Options:"
  echo
  echo "  --apk-static-url < url >"
  echo
  echo "    Base url to download statically compiled APK tool from."
  echo
  echo "  --apk-static-version < version >"
  echo
  echo "    Version of the statically compiled APK tool to download/use."
  echo
  echo "  --arch < aarch64 | armv7 | x86 | x86_64 >"
  echo
  echo "    Defaults to x86_86, except when '--physical rpi*' specified when it"
  echo "    defaults to aarch64."
  echo
  echo "  --boot-by-label"
  echo
  echo "    Use Labels rather than UUIDs in /etc/fstab and bootloader to refer to"
  echo "    filesystems."
  echo
  echo "  --bootchart"
  echo
  echo "    Enables bootchart creation during boot."
  echo
  echo "  --bootloader < grub | syslinux >"
  echo
  echo "    Defaults to Syslinux. Not relevant for RPI physical machines."
  echo
  echo "  --boottype < bios | uefi >"
  echo
  echo "    Defaults to UEFI."
  echo
  echo "  --chroot-directory < directory >"
  echo
  echo "    Directory to use for building the Alpine image. Defaults to './chroot'."
  echo
  echo "  --cloud <cloud type>"
  echo
  echo "    Valid values are:"
  echo "      generic aliyun aws azure bigstep brightbox digitalocean e24 exoscale"
  echo "      google hetzner hyperone ibmcloud oracle rootbox scaleway tencent"
  echo "      upcloud vultr"
  echo
  echo "  --cpu_vendor < amd | intel >"
  echo
  echo "    Used to decide if only AMD or Intel relevant microcode is installed and"
  echo "    whether vendor-specific kernal modules are included in the initramfs."
  echo
  echo "  --debug"
  echo
  echo "    Enable debug-specific logging."
  echo
  echo "  --disable-normal-console"
  echo
  echo "    Disable normal display-based Linux console. Can be used when serial"
  echo "    console is enabled if only serial is required."
  echo
  echo "  --disable-serial-console"
  echo
  echo "    Disable serial-based Linux console."
  echo
  echo "  --disable-unnecessary-modules"
  echo
  echo "    Prevent kernel modules from being loaded that are typically not relevant"
  echo "    for servers."
  echo
  echo "  --ethernet-module < module-name >"
  echo
  echo "    When remote unlocking of encrypted filesystem is enabled this parameter"
  echo "    is also required to specific the relevant kernel module for the ethernet"
  echo "    device as the driver must be included in the initramfs as (obviously) it"
  echo "    cannot be loaded from the (still encrypted at that point) rootfs."
  echo
  echo "  --encrypt"
  echo
  echo "    Enable encryption of the rootfs."
  echo
  echo "  --encrypt-passphrase < passphrase >"
  echo
  echo "    The passphrase to use for the encrypted filesystem. Defaults to"
  echo "    'InsecureDefault' if not specified."
  echo
  echo "  --encrypt-remote-unlock"
  echo
  echo "    Enable functionality for the remote-unlocking of encrypted filesystems"
  echo "    at boottime over SSH."
  echo
  echo "  --graphics-vendor < amd | intel | nvidia >"
  echo
  echo "    Indicate the vendor of server's graphics card so that the initramfs can"
  echo "    be generated containing only that vendor's drivers and firmware."
  echo
  echo "  --image-filename < filename >"
  echo
  echo "    Filename to use for the created Alpine disk image."
  echo
  echo "  --images-directory < directory >"
  echo
  echo "    The directory where to store the created disk image."
  echo
  echo "  --ipv4only"
  echo
  echo "    Do not enable IPv6 in the created disk image."
  echo
  echo "  --ipv6only"
  echo
  echo "    Do not enable IPv4 in the created disk image."
  echo
  echo "  --keymap '< keymap >'"
  echo
  echo "    Defaults to 'us us'."
  echo
  echo "  --local-repo < url >"
  echo
  echo "    Local Alpine repository for *additional* packages."
  echo
  echo "  --local-repo-sig-file < filename >"
  echo
  echo "    Signature file used to sign packages in local Alpine repository."
  echo
  echo "  --locale < locale >"
  echo
  echo "    Defaults to 'en_US'."
  echo
  echo "  --lvm"
  echo
  echo "    Use LVM for root filesystem. If '--encrypt' is also specified then"
  echo "    create LVM-on-LUKS filesystem."
  echo
  echo "  --mirror < mirror url >"
  echo
  echo "    URL of Alpine mirror site to use."
  echo
  echo "  --password < password >"
  echo
  echo "    Password for default user created upon 1st boot. Defaults to 'ChangeMe'."
  echo
  echo "  --physical < pc | rpi2 | rpi3 | rpi4 >"
  echo
  echo "    The type of physical machine to be created."
  echo
  echo "  --ramdisk-directory < directory >"
  echo
  echo "    When '--use-ramdisk' is also specified this value indicates the directory"
  echo "    in which to store the ramdisk file."
  echo
  echo "  --release < 3.13 | 3.14 | edge >"
  echo
  echo "    Which Alpine Release to use for the disk image. If not specified then"
  echo "    defaults to 'edge'."
  echo
  echo "  --remote-unlock-network-module < kernel module name >"
  echo
  echo "    Specifies the name of the network device kernel module to be loaded."
  echo
  echo "  --remote-unlock-ssh-port < port number >"
  echo
  echo "    Specifies the TCP port that the temporary SSH daemon should listen on."
  echo "    If not specified then defaults to '22'."
  echo
  echo "  --remote-unlock-static-gateway < IP address >"
  echo
  echo "    Specifies the IP address of the local router. Only applicable when"
  echo "    '--remote-unlock-static-ip' has also been specified."
  echo
  echo "  --remote-unlock-static-interface < interface name >"
  echo
  echo "    Specifies the network interface name. Only applicable when"
  echo "    '--remote-unlock-static-ip' has also been specified."
  echo
  echo "  --remote-unlock-static-ip < IP addrss >"
  echo
  echo "    Specifies the (temporary) IP address for the machine to use for remote"
  echo "    unlock functionality. If not specified then DHCP is used instead."
  echo
  echo "  --remote-unlock-static-netmask < netmask >"
  echo
  echo "    Specifies the network netmask to use. Only applicable when"
  echo "    '--remote-unlock-static-ip' has also been specified."
  echo
  echo "  --script-filename < filename >"
  echo
  echo "    The filename of the script to be created."
  echo
  echo "  --ssh-public-key < filename >"
  echo
  echo "    File containing the SSH public key that is permitted to connect to the"
  echo "    temporary SSH server used for remote unlocking of disk encryption."
  echo
  echo "  --use-ramdisk"
  echo
  echo "    Indicates to use a (temporary) ramdisk when creating the disk image to"
  echo "    speed up creation and/or to reduce disk writes (i.e. on SSD)."
  echo
  echo "  --username <username>"
  echo
  echo "    Name of the default account to create upon 1st boot. Defaults to 'alpine'."
  echo
  echo "  --virtual <vm type>"
  echo
  echo "    Valid values are:  generic hyperv libvirtd openstack proxmox qemu"
  echo "                       virtualbox vmware"
  echo
}


#
# Check that the combination of CLI options make sense
#
validate_cli_options() {
  # If --debug not specified then debug defaults to off
  if [ -z ${DEBUG+x} ]; then
    DEBUG=false
  fi

  if [ -z "$SCRIPT_FILENAME" ]; then
    echo
    echo "You must specify a filename for the script to be created!"
    echo
    exit 2
  fi

  # Don't disable unnecessary modules by default
  if [ -z ${DISABLE_UNNECESSARY_MODULES+x} ]; then
    DISABLE_UNNECESSARY_MODULES="false"
  fi

  # If console name not specified then assume default
  if [ -z ${CONSOLE_NAME+x} ]; then
    CONSOLE_NAME=$DEFAULT_CONSOLE_NAME
  fi

  # If console type not specified then assume default
  if [ -z ${CONSOLE_TYPE+x} ]; then
    CONSOLE_TYPE="normal"
  fi

  # If Alpine release not specified then assume default
  if [ -z ${IMAGE_ALPINE_RELEASE+x} ]; then
    IMAGE_ALPINE_RELEASE=$DEFAULT_ALPINE_RELEASE
  fi

  # If arch not specified then assume default
  if [ -z ${IMAGE_ARCH+x} ]; then
    IMAGE_ARCH=$DEFAULT_ARCH
  fi

  # If neither Cloud / VM / Physical specified then assume QEMU VM
  if [ -z ${IMAGE_CLASS+x} ]; then
    IMAGE_CLASS="vm"
    VM_TYPE="qemu"
  fi

  if [ -z "${IMAGE_FILENAME+x}" ]; then
    IMAGE_BASE_FILENAME="alpine-$IMAGE_ALPINE_RELEASE-$IMAGE_ARCH-$IMAGE_CLASS"
    case $IMAGE_CLASS in
      cloud )
        IMAGE_FILENAME="$IMAGE_BASE_FILENAME-$CLOUD_TYPE.img"
        ;;
      physical )
        IMAGE_FILENAME="$IMAGE_BASE_FILENAME-$PHYSICAL_TYPE.img"
        ;;
      vm )
        IMAGE_FILENAME="$IMAGE_BASE_FILENAME-$VM_TYPE.img"
        ;;
    esac
  fi

  # Log filename is based on image filename
  LOGFILE=$(echo $IMAGE_FILENAME | sed -e 's|\.img$|\.log|')

  # If version of APK-static is not specified then assume default
  if [ -z ${APK_STATIC_VERSION+x} ]; then
    APK_STATIC_VERSION=$DEFAULT_APK_STATIC_VERSION
  fi

  # If URL to download APK-static is not specified then assume default
  if [ -z ${APK_STATIC_URL+x} ]; then
    APK_STATIC_URL=$DEFAULT_APK_STATIC_URL
  fi

  # If chroot directory not specified then assume default
  if [ -z ${CHROOT_DIRECTORY+x} ]; then
    CHROOT_DIRECTORY=$DEFAULT_CHROOT_DIRECTORY
  fi

  # If images directory not specified then assume default
  if [ -z ${IMAGES_DIRECTORY+x} ]; then
    IMAGES_DIRECTORY=$DEFAULT_IMAGES_DIRECTORY
  fi

  # If USE_RAMDISK specified then assume disabled
  if [ -n "${USE_RAMDISK+x}" ]; then
    if [ -z "${RAMDISK_DIRECTORY+x}" ]; then
      # If ramdisk directory not specified then assume default
      RAMDISK_DIRECTORY=$DEFAULT_RAMDISK_DIRECTORY
    fi
  else
    USE_RAMDISK="false"
  fi

  # If Alpine repo mirror site not specified then assume default
  if [ -z ${ALPINE_MIRROR_SITE+x} ]; then
    ALPINE_MIRROR_SITE=$DEFAULT_MIRROR_SITE
  fi

  # If boot_by_label not specified then assume default
  if [ -z ${IMAGE_BOOT_REFERENCE+x} ]; then
    IMAGE_BOOT_REFERENCE=$DEFAULT_BOOT_REFERENCE
  fi

  if [ -z ${IMAGE_DEFAULT_USERNAME+x} ]; then
    IMAGE_DEFAULT_USERNAME=$DEFAULT_USERNAME
  fi

  if [ -z ${IMAGE_DEFAULT_USER_PASSWORD+x} ]; then
    IMAGE_DEFAULT_USER_PASSWORD=$DEFAULT_USER_PASSWORD
  fi

  if [ -z ${IMAGE_ENCRYPTED+x} ]; then
    IMAGE_ENCRYPTED=false
  fi

  if [ -z ${REMOTE_UNLOCK+x} ]; then
    REMOTE_UNLOCK=false
  fi

  if [ -z ${IMAGE_KEYMAP+x} ]; then
    IMAGE_KEYMAP=$DEFAULT_KEYMAP
  fi

  if [ -z ${IMAGE_LOCALE+x} ]; then
    IMAGE_LOCALE=$DEFAULT_LOCALE
  fi

  if [ "$IMAGE_ENCRYPTED" = "true" ]; then
    if [ "$IMAGE_CLASS" = "cloud" ] && \
       [ "$CLOUD_TYPE" = "aws" ]; then
      echo
      echo "For AWS you should use an encrypted EBS device!"
      echo
      exit 2
    fi

    if [ -z "${IMAGE_ENCRYPTION_PASSPHRASE+x}" ]; then
      IMAGE_ENCRYPTION_PASSPHRASE="$DEFAULT_LUKS_PASSPHRASE"
    fi
  fi

  if [ "$REMOTE_UNLOCK" = "true" ]; then
    if [ "$IMAGE_CLASS" = "cloud" ]; then
      echo
      echo "Remote unlocking of encrypted rootfs is not supported in cloud!"
      echo
      exit 2
    fi
  fi

  if [ "$IMAGE_CLASS" = "cloud" ]; then
    # Check for cloud machines that other specified settings make sense
    case $IMAGE_ARCH in
      aarch64 )
        if [ -n "${IMAGE_BOOTLOADER+x}" ]; then
          if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
            echo
            echo "aarch64 cloud machine can only use Grub bootloader!"
            echo
            exit 2
          fi
        else
          IMAGE_BOOTLOADER="grub"
        fi
        case $CLOUD_TYPE in
          aws | oracle )
            ;;
          * )
            echo
            echo "aarch64 cloud images cannot be created for this cloud provider!"
            echo
            exit 2
            ;;
        esac
        # aarch VMs always use UEFI
        IMAGE_BOOT_TYPE="uefi"
        ;;

      x86_64 )
        case $CLOUD_TYPE in
          oracle )
            IMAGE_BOOT_TYPE="bios"
            IMAGE_BOOTLOADER="syslinux"
            ;;
          * )
            IMAGE_BOOT_TYPE="bios"
            IMAGE_BOOTLOADER="grub"
            ;;
        esac
        ;;
    esac
  elif [ "$IMAGE_CLASS" = "physical" ]; then
    # Check for physical machines that other specified settings make sense
    case $PHYSICAL_TYPE in
      pc )
        if [ "$IMAGE_ARCH" = "x86" ]; then
          # x86
          if [ -z "${IMAGE_BOOTLOADER+x}" ]; then
            IMAGE_BOOTLOADER="syslinux"
          fi
          if [ -n "${IMAGE_BOOT_TYPE+x}" ]; then
            IMAGE_BOOT_TYPE="bios"
          elif [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
            echo
            echo "UEFI is not supported for x86!"
            echo
            exit 2
          fi
        else
          # x86_64
          if [ -z "${IMAGE_BOOT_TYPE+x}" ]; then
            IMAGE_BOOT_TYPE="uefi"
            if [ -z "${IMAGE_BOOTLOADER+x}" ]; then
              IMAGE_BOOTLOADER="grub"
            fi
          fi
          if [ -z "${IMAGE_BOOTLOADER+x}" ]; then
            IMAGE_BOOTLOADER="syslinux"
          fi
        fi
        ;;
      rpi2 | rpi3 | rpi4 )
        if [ -z "${IMAGE_BOOTLOADER+x}" ]; then
          IMAGE_BOOTLOADER="none"

          if [ -z ${IMAGE_BOOT_TYPE+x} ]; then
            IMAGE_BOOT_TYPE="none"
          elif [ "$IMAGE_BOOT_TYPE" != "none" ]; then
            echo
            echo "An invalid boot type was specified! For an RPI only 'none' is valid"
            echo
            exit 2
          fi
        elif [ "${IMAGE_BOOTLOADER}" != "none" ]; then
          echo
          echo "An invalid bootloader was specified!"
          echo
          exit 2
        fi
        ;;
    esac
  elif [ "$IMAGE_CLASS" = "vm" ]; then
    # Check for Virtual Machines that other specified settings make sense
    case $IMAGE_ARCH in
      armv7 )
        echo
        echo "armv7 virtual machines are not supported!"
        echo
        exit 2
        ;; 
      aarch64 )
        if [ -n "${IMAGE_BOOTLOADER+x}" ]; then
          if [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
            echo
            echo "aarch64 virtual machine can only use Grub bootloader!"
            echo
            exit 2
          fi
        else
          IMAGE_BOOTLOADER="grub"
        fi

        if [ "$VM_TYPE" = "virtualbox" ]; then
          echo
          echo "aarch64 Virtualbox images cannont be created!"
          echo
          exit 2
        fi

        # aarch VMs always use UEFI
        IMAGE_BOOT_TYPE="uefi"
        ;;
      x86 )
        if [ -n "${IMAGE_BOOTLOADER+x}" ]; then
          IMAGE_BOOTLOADER="syslinux"
        fi

        if [ -n "${IMAGE_BOOT_TYPE+x}" ]; then
          IMAGE_BOOT_TYPE="bios"
        elif [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
          echo
          echo "UEFI is not supported for x86!"
          echo
          exit 2
        fi
        ;;
      x86_64 )
        if [ -z ${IMAGE_BOOTLOADER+x} ]; then
          if [ -z ${IMAGE_BOOT_TYPE+x} ]; then
            IMAGE_BOOTLOADER="syslinux"
            IMAGE_BOOT_TYPE="uefi"
          elif [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
            IMAGE_BOOTLOADER="syslinux"
          else
            IMAGE_BOOTLOADER="syslinux"
          fi
        elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
          if [ -z ${IMAGE_BOOT_TYPE+x} ]; then
            IMAGE_BOOT_TYPE="uefi"
          fi
        else
          if [ -z ${IMAGE_BOOT_TYPE+x} ]; then
            IMAGE_BOOT_TYPE="uefi"
          fi
        fi
        ;;
    esac
  fi

  if { [ "$IMAGE_CLASS" = "physical" ] && \
       [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; } || \
     { [ "$IMAGE_BOOTLOADER" = "syslinux" ]  && \
       [ "$IMAGE_BOOT_TYPE" = "bios" ] && \
       [ "$IMAGE_ENCRYPTED" = "true" ]; } || \
     { [ "$IMAGE_BOOTLOADER" = "grub" ] && \
       [ "$REMOTE_UNLOCK" = "true" ]; }; then
    # A separate boot partition is required in the following situations:
    # (a) its a Raspberry Pi
    # (b) Syslinux is used as bootloader for BIOS with encrypted rootfs
    # (c) GRUB is used as bootloader with remote unlock of encrypted rootfs
    NEEDS_BOOT_PARTITION=true
  else
    NEEDS_BOOT_PARTITION=false
  fi

  # Sort out partition sizing
  case $IMAGE_CLASS in
    cloud )
      if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
        BOOT_PART_SIZE=$CLOUD_BOOT_PART_SIZE
        ROOT_PART_SIZE=$CLOUD_ROOT_PART_SIZE
      else
        ROOT_PART_SIZE=$((CLOUD_BOOT_PART_SIZE + CLOUD_ROOT_PART_SIZE))
      fi
      ;;
    physical )
      if [ "$PHYSICAL_TYPE" = "pc" ]; then
        # PC
        if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
          BOOT_PART_SIZE=$PHYSICAL_BOOT_PART_SIZE
          ROOT_PART_SIZE=$PHYSICAL_ROOT_PART_SIZE
        else
          ROOT_PART_SIZE=$((PHYSICAL_BOOT_PART_SIZE + PHYSICAL_ROOT_PART_SIZE))
        fi
      else
        # Raspberry Pi
        BOOT_PART_SIZE=$RPI_BOOT_PART_SIZE
        ROOT_PART_SIZE=$RPI_ROOT_PART_SIZE
      fi
      ;;
    vm )
      if [ "$NEEDS_BOOT_PARTITION" = "true" ]; then
        BOOT_PART_SIZE=$VIRTUAL_BOOT_PART_SIZE
        ROOT_PART_SIZE=$VIRTUAL_ROOT_PART_SIZE
      else
        ROOT_PART_SIZE=$((VIRTUAL_BOOT_PART_SIZE + VIRTUAL_ROOT_PART_SIZE))
      fi
      ;;
  esac
}

#############################################################################
##		Main Section
#############################################################################

FULL_COMMAND_OPTIONS="$*"

echo
echo "create-alpine-disk-image version $SCRIPT_VERSION"

parse_cli_options "$@"
validate_cli_options

echo
echo "Using the following settings:"
echo "  Image arch: $IMAGE_ARCH"
echo "  Image class: $IMAGE_CLASS"
case $IMAGE_CLASS in
  cloud )
    echo "  Cloud type: $CLOUD_TYPE"
    ;;
  physical )
    echo "  Physical machine type: $PHYSICAL_TYPE"
    ;;
  vm )
    echo "  VM type: $VM_TYPE"
    ;;
esac
echo "  Alpine release: $IMAGE_ALPINE_RELEASE"
echo "  Boot Type: $IMAGE_BOOT_TYPE"
echo "  Bootloader: $IMAGE_BOOTLOADER"

#############################################################################
##		Prepare the run script
#############################################################################

RUN_SCRIPT=$SCRIPT_FILENAME
create_runscript_header
add_runscript_functions

cat <<EOF >> "$RUN_SCRIPT"

check_for_required_packages
check_binfmt_packages $IMAGE_ARCH

mkdir -p \$IMAGES_DIRECTORY

EOF

if [ "$USE_RAMDISK" = "true" ]; then
  cat <<EOF >> "$RUN_SCRIPT"
write_log "Setting up ramdisk"
mkdir -p \$RAMDISK_DIRECTORY
mount -t tmpfs -o size=$RAMDISK_SIZE tmpfs \$RAMDISK_DIRECTORY >> \$LOGFILE
EOF
fi

IMAGE_SIZE=$(calculate_image_size)

cat <<EOF >> "$RUN_SCRIPT"
write_log "Creating sparse disk image of ${IMAGE_SIZE}MiB"
truncate -s ${IMAGE_SIZE}M \$IMAGE_FULL_FILENAME >> \$LOGFILE
EOF

if [ "$IMAGE_BOOT_TYPE" = "none" ]; then
  partition_rpi
elif [ "$IMAGE_BOOT_TYPE" = "bios" ]; then
  partition_bios
else
  partition_uefi
fi

if [ "$DEBUG" = "true" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"

write_debug_log "  Resultant partition layout:"
parted --machine --script --align=optimal $IMAGE_FULL_FILENAME \
  unit MiB \
  print \
  >> $LOGFILE
EOF
fi

cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Setting up loop device for disk image"
LOOP_DEVICE=$(losetup -P --show -f $IMAGE_FULL_FILENAME 2>> $LOGFILE)
if [ -z "$LOOP_DEVICE" ]; then
  echo
  echo "There was a problem creating the loop device. Aborting!"
  echo
  exit 1
fi
EOF

if [ "$IMAGE_ENCRYPTED" = "true" ]; then
  setup_luks_device
fi

format_and_mount_fs

if [ "$IMAGE_ENCRYPTED" = "true" ] && \
   [ "$IMAGE_BOOTLOADER" = "grub" ] && \
   [ "$REMOTE_UNLOCK" != "true" ]; then
  # LUKS keyfile is only used with Grub when Grub's own Cryptodisk is
  # enabled (so does not apply when Remote Unlock enabled).
  copy_luks_keyfile_into_place
fi

download_static_apk

cat <<EOF >> "$RUN_SCRIPT"

mkdir -p "\$CHROOT_DIRECTORY"/etc

write_log "Copying system's /etc/resolv.conf into chroot filesystem"
cp /etc/resolv.conf "\$CHROOT_DIRECTORY"/etc/

mkdir -p "\$CHROOT_DIRECTORY"/etc/apk/keys
write_log "Creating /etc/apk/repositories file inside chroot"
echo \
  "$ALPINE_MIRROR_SITE/$IMAGE_ALPINE_RELEASE/main" \
  > "\$CHROOT_DIRECTORY"/etc/apk/repositories
EOF

if [ -n "${LOCAL_REPO_SIGNATURE_FILE+x}" ]; then
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Copy local repo key to /etc/apk/keys/ directory inside chroot"
cp "$LOCAL_REPO_SIGNATURE_FILE" "\$CHROOT_DIRECTORY"/etc/apk/keys/
EOF
fi

install_alpine_base

cat <<EOF >> "$RUN_SCRIPT"

rm -Rf \$TMPDIR/apk-tools-$APK_STATIC_VERSION

write_log "Mounting /proc, /sys, and /dev special filesystems in chroot"
{
  mount -t proc none \$CHROOT_DIRECTORY/proc
  mount -t none -o rbind /sys \$CHROOT_DIRECTORY/sys
  mount --make-rprivate \$CHROOT_DIRECTORY/sys
  mount -t none -o rbind /dev \$CHROOT_DIRECTORY/dev
  mount --make-rprivate \$CHROOT_DIRECTORY/dev
} >> \$LOGFILE 2>&1
EOF

define_additional_packages

# shellcheck disable=SC2129
cat <<'EOF' >> "$RUN_SCRIPT"

#############################################################################
##		Start of Chroot section
#############################################################################

chroot "$CHROOT_DIRECTORY" /bin/sh -eu <<EOT

EOF

cat <<EOF >> "$RUN_SCRIPT"
KEYMAP="$IMAGE_KEYMAP"
LOCALE="$IMAGE_LOCALE"
EOF

cat <<'EOF' >> "$RUN_SCRIPT"

############################################################################
##		Chroot Functions
############################################################################

add_fstab_entry() {
  local ENTRY_TYPE=\$1
  local ENTRY_VALUE=\$2
  local MOUNT_POINT=\$3
  local FS_TYPE=\$4
  local FS_OPTIONS=\$5
  local ENTRY_LOG=\$6

  if [ "\$ENTRY_TYPE" = "BIND" ]; then
    local FS_OPTIONS="bind,\${FS_OPTIONS}"
    local FS_PASSNO="0"
  elif [ "\$MOUNT_POINT" = "/" ]; then
    local FS_PASSNO="1"
  else
    local FS_PASSNO="2"
  fi

  if [ "\$ENTRY_TYPE" = "BIND" ] ||
     [ "\$ENTRY_TYPE" = "DEVICE" ]; then
    FSTAB_ENTRY="\${ENTRY_VALUE}"
  else
    FSTAB_ENTRY="\${ENTRY_TYPE}=\${ENTRY_VALUE}"
  fi
	# shellcheck disable=SC1117
  FSTAB_ENTRY="\${FSTAB_ENTRY}\t\${MOUNT_POINT}\t\${FS_TYPE}\t\${FS_OPTIONS} 0 \${FS_PASSNO}"

  write_log "  Add \${ENTRY_LOG} entry"
  # shellcheck disable=SC2169,SC3036
  echo -e "\${FSTAB_ENTRY}" >> /etc/fstab
}
EOF

if [ "$IMAGE_ENCRYPTED" = "true" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"


define_cmdline_for_encryption() {
  local CMDLINE

  CMDLINE="cryptroot=UUID=${LUKS_PART_UUID}"
  CMDLINE="\$CMDLINE cryptdm=cryptroot"
EOF

  if [ "$REMOTE_UNLOCK" = "true" ]; then
    if [ -n "${REMOTE_UNLOCK_STATIC_IP+x}" ]; then
      # Indicate the IP address to use by initramfs for configuring
      # the ethernet interface for Dropbear to listen on.
      if [ -n "${REMOTE_UNLOCK_STATIC_GATEWAY+x}" ]; then
        STATIC_GATEWAY=$REMOTE_UNLOCK_STATIC_GATEWAY
      else
        STATIC_GATEWAY=""
      fi
      if [ -n "${REMOTE_UNLOCK_STATIC_INTERFACE+x}" ]; then
        STATIC_INTERFACE=$REMOTE_UNLOCK_STATIC_INTERFACE
      else
        STATIC_INTERFACE=""
      fi
      if [ -n "${REMOTE_UNLOCK_STATIC_NETMASK+x}" ]; then
        STATIC_NETMASK=$REMOTE_UNLOCK_STATIC_NETMASK
      else
        STATIC_NETMASK=""
      fi
      cat <<EOF >> "$RUN_SCRIPT"
      CMDLINE="\$CMDLINE ip=$REMOTE_UNLOCK_STATIC_IP::$STATIC_GATEWAY:$STATIC_NETMASK::$STATIC_INTERFACE:none:"
EOF
    else
      # Indicate that DHCP should be used by initramfs' init.
      cat <<'EOF' >> "$RUN_SCRIPT"
      CMDLINE="\$CMDLINE ip=dhcp"
EOF
    fi

    # Indicate that Dropbear should be run by initramfs' init.
    cat <<'EOF' >> "$RUN_SCRIPT"
    CMDLINE="\$CMDLINE remote_unlock_luks"
EOF

    if [ -n "${REMOTE_UNLOCK_SSH_PORT+x}" ]; then
      # Indicate the port that Dropbear should listen on
      cat <<EOF >> "$RUN_SCRIPT"
      CMDLINE="\$CMDLINE remote_unlock_luks_ssh_port=$REMOTE_UNLOCK_SSH_PORT"
EOF
    fi
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
  echo "\$CMDLINE"
}
EOF
fi

cat <<'EOF' >> "$RUN_SCRIPT"


get_kernel_version() {
EOF

case $IMAGE_CLASS in
  cloud | vm )
    KERNEL_PACKAGE="virt" ;;
  physical )
    case $PHYSICAL_TYPE in
      pc )
        KERNEL_PACKAGE="lts" ;;
      rpi2 | rpi3 )
        if [ "$IMAGE_ARCH" = "armv7" ]; then
          KERNEL_PACKAGE="rpi2"
        else
          KERNEL_PACKAGE="rpi"
        fi
        ;;
      rpi4 )
        KERNEL_PACKAGE="rpi4" ;;
    esac
    ;;
esac

cat <<EOF >> "$RUN_SCRIPT"
  apk info linux-$KERNEL_PACKAGE | head -n 1 | sed -e 's/^linux-$KERNEL_PACKAGE-//' -e 's/-r/-/' -e 's/ .*//' -Ee 's/^(.*)\$/\\1-$KERNEL_PACKAGE/'
}

write_debug_log() {
EOF

if [ "$DEBUG" = "true" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"
  current_time=\$(printf "[%s]" "\$(date -u "+%Y-%m-%d %H:%M:%S")")
  echo "\$current_time chroot: \$1" >> /chroot.log
EOF
else
  cat <<'EOF' >> "$RUN_SCRIPT"
  # Debug not enabled so do nothing
  true
EOF
fi

cat <<'EOF' >> "$RUN_SCRIPT"
}

write_log() {
  current_time=\$(printf "[%s]" "\$(date -u "+%Y-%m-%d %H:%M:%S")")
  echo "\$current_time chroot: \$1" >> /chroot.log
  echo "chroot: \$1"
}

############################################################################
##		Chroot Main Section
############################################################################

EOF

configure_fstab

add_additional_repos

update_upgrade_packages

basic_os_configuration

setup_etc_modules

delete_users_groups

disable_extra_getty

add_base_init_d

install_additional_packages

additional_os_configuration

configure_cloud_init

if [ "$CONSOLE_TYPE" = "serial" ] || \
   [ "$CONSOLE_TYPE" = "both" ]; then
  enable_serial_console
fi

add_additional_init_d

if [ "$DISABLE_UNNECESSARY_MODULES" = "true" ]; then
  disable_kernel_modules
fi

configure_mkinitfs

if [ "$IMAGE_ENCRYPTED" = "true" ] && \
   [ -n "${SSH_PUBLIC_KEY+x}" ]; then
  setup_dropbear_authorized_keys
fi

install_kernel

if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
  configure_bootloader_grub
elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
  configure_bootloader_syslinux
elif [ "$IMAGE_CLASS" = "physical" ] && \
     [ "$(expr "$PHYSICAL_TYPE" : 'rpi[2-4]')" -gt 0 ]; then
  configure_bootloader_rpi
fi

if [ "$IMAGE_ENCRYPTED" = "true" ] && \
   [ "$IMAGE_BOOTLOADER" = "grub" ] && \
   [ "$REMOTE_UNLOCK" != "true" ]; then
  # Ensure that initramfs is only readable by root as it
  # contains the keyfile to decrypt the root partition.
  case $IMAGE_CLASS in
    cloud | vm )
      INITRAMFS_FILENAME="initramfs-virt"
      ;;
    rpi )
      INITRAMFS_FILENAME="initramfs-rpi"
      ;;
    * )
      INITRAMFS_FILENAME="initramfs-lts"
      ;;
  esac
  cat <<EOF >> "$RUN_SCRIPT"

chmod 600 /boot/$INITRAMFS_FILENAME
EOF
fi

if [ "$DEBUG" = "true" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  write_debug_log "mkinitfs contents:"
  mkinitfs -l "\$KERNEL_VERSION" >> /chroot.log
}
EOF
fi

if [ "$IMAGE_BOOTLOADER" = "grub" ]; then
  install_grub
elif [ "$IMAGE_BOOTLOADER" = "syslinux" ]; then
  install_syslinux
fi

if [ "$DEBUG" = "true" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"

{
  # Debug
  df -k >> /chroot.log
  write_debug_log "/boot contents:"
  ls -laR /boot/ >> /chroot.log
EOF

  if [ "$IMAGE_BOOT_TYPE" = "uefi" ]; then
    # UEFI
    cat <<'EOF' >> "$RUN_SCRIPT"

  write_debug_log "Contents of /efi directory:"
  ls -lR /efi >> $LOGFILE
EOF
  fi

  cat <<'EOF' >> "$RUN_SCRIPT"
}
EOF
fi

cat <<'EOF' >> "$RUN_SCRIPT"

EOT

#############################################################################
##		End of Chroot section
#############################################################################

cat "$CHROOT_DIRECTORY"/chroot.log >> "$LOGFILE"
rm "$CHROOT_DIRECTORY"/chroot.log

write_log "Finished chroot section"

write_log "Removing temporary /etc/resolv.conf from chroot filesystem"
rm "$CHROOT_DIRECTORY"/etc/resolv.conf
EOF

if [ "$DEBUG" = "true" ]; then
  cat <<'EOF' >> "$RUN_SCRIPT"

# Debug
mv "$CHROOT_DIRECTORY"/base-packages.list .
EOF
fi

cat <<'EOF' >> "$RUN_SCRIPT"

write_log "Cleaning up"
normal_cleanup
EOF

if [ "$USE_RAMDISK" = "true" ]; then
  cat <<EOF >> "$RUN_SCRIPT"

write_log "Copying image from ramdisk to final location"
cp "\$IMAGE_FULL_FILENAME" "\$IMAGES_DIRECTORY/"

write_log "Unmounting ramdisk"
umount \$RAMDISK_DIRECTORY >> \$LOGFILE
rmdir \$RAMDISK_DIRECTORY
EOF
fi

cat <<'EOF' >> "$RUN_SCRIPT"

# Clear exit trap function
trap EXIT

exit

EOF

if [ "$DEBUG" = "true" ]; then
  shellcheck -s ash "$RUN_SCRIPT"
  # shellcheck disable=SC2034
  RET_CODE=$?
  #if [ $RET_CODE != 0 ]; then
  #  exit 2
  #fi
fi

chmod +x "$RUN_SCRIPT"

echo
echo "Created tailored script '$RUN_SCRIPT'."
echo "This script must be run as user 'root'."
echo

exit
